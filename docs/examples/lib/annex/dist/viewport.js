/*!
 * @oktarintentakel/annex v0.1.19-beta
 */
/*!
 * Module Viewport
 */
const MODULE_NAME="Viewport";import{hasValue,orDefault,isWindow,isPlainObject,isArray,isFunction,isElement,isBoolean,isNumber,Deferred,Observable,assert,min,minMax,round}from"./basic.js";import{isInDom}from"./elements.js";import{EasingFunctions}from"./animation.js";import{requestAnimationFrame,cancelAnimationFrame}from"./timers.js";import{throttle,defer}from"./functions.js";import{warn}from"./logging.js";import{fire}from"./events.js";const VISIBILITY_BASE_FPS=15,DISTANCE_BASE_FPS=4,BREAKPOINT_BASE_FPS=4;function getBoundingClientRect(e){let t;try{t=e.getBoundingClientRect()}catch(e){t=window.DOMRect?new DOMRect(0,0,0,0):{top:0,right:0,bottom:0,left:0,width:0,height:0}}return t}class SimplePollingObserver{#e="SimplePollingObserver";#t;#i;#s;#r;constructor(e,t){this.#t=e,this.#i=new Set,this.#s=t?.targetFps??15,this.connect()}connect(){this.disconnect();const e=round(1e3/this.#s),t=throttle(e,(()=>{this.#t(Array.from(this.#i).map((e=>{const t=getBoundingClientRect(e),i=window.innerWidth,s=window.innerHeight,r=t.top<0?Math.abs(t.top):0,n=t.top+t.height>s?t.top+t.height-s:0,o=minMax(0,t.height-r-n,round(t.height)),l={target:e,rootBounds:isInDom(e)?{top:0,right:i,bottom:s,left:0,width:i,height:s}:null,boundingClientRect:t,intersectionRect:{height:o}};return l.intersectionRatio=o/l.boundingClientRect.height,l})))})).bind(this),i=()=>{t(),this.#r=requestAnimationFrame(i)};return this.#r=requestAnimationFrame(i),this}disconnect(){return cancelAnimationFrame(this.#r),this.#r=null,this.#i.clear(),this}observe(e){return this.#i.add(e),this}unobserve(e){return this.#i.delete(e),this}}class VisibilityState{#e="VisibilityState";#n="visibilitystate";#o;#l=!1;#a=!1;#h=!1;#u=!1;#d=0;#c=0;calculateScrolled=!1;#p=0;#b=null;#w=null;calculateDistance=!1;#g=Number.POSITIVE_INFINITY;#v=Number.POSITIVE_INFINITY;#f=null;#m=null;autoHandleTooLargeElements=!0;#I=null;#V=null;#S=null;constructor(e,t=!1,i=!1,s=!0){this.#o=e,this.calculateScrolled=!!t,this.calculateDistance=!!i,this.autoHandleTooLargeElements=!!s}inViewport(e=null){if(hasValue(e)){const t=this.#l;this.#l=!!e,this.#B(t,this.#l,"enteredviewport","leftviewport")}return this.#l}fullyInViewport(e=null){if(hasValue(e)){const t=this.#a;this.#a=!!e,this.#B(t,this.#a,"fullyenteredviewport","fullyleftviewport")}return this.#a}upperBoundInViewport(e=null){if(hasValue(e)){const t=this.#h;this.#h=!!e,this.#B(t,this.#h,"upperboundenteredviewport","upperboundleftviewport")}return this.#h}lowerBoundInViewport(e=null){if(hasValue(e)){const t=this.#u;this.#u=!!e,this.#B(t,this.#u,"lowerboundenteredviewport","lowerboundleftviewport")}return this.#u}visiblePercent(e=null){if(hasValue(e)){const t=this.#d;this.#d=minMax(0,round(parseFloat(e),2),100),this.#B(t,this.#d,"visiblepercent")}return this.#d}visiblePixels(e=null){if(hasValue(e)){const t=this.#c;this.#c=minMax(0,round(parseFloat(e)),round(this.#o.scrollHeight)),this.#B(t,this.#c,"visiblepixels")}return this.#c}scrolledPercent(e=null){if(hasValue(e)){const t=this.#p;this.#p=minMax(0,round(parseFloat(e),2),100),this.#B(t,this.#p,"scrolledpercent")}return this.#p}distancePixels(e=null){if(hasValue(e)){const t=this.#g;this.#g=round(parseFloat(e)),this.#B(t,this.#g,"distancepixels")}return this.#g}distanceViewports(e=null){if(hasValue(e)){const t=this.#v;this.#v=round(parseFloat(e),2),this.#B(t,this.#v,"distanceviewports")}return this.#v}startAutoScrolledPercentUpdates(e,t=15,i=!0){if(this.calculateScrolled&&!hasValue(this.#b)){this.#b=e;const s=round(1e3/t);this.#w=this.#b.subscribe(throttle(s,(()=>{const e=getBoundingClientRect(this.#o),t=window.innerHeight;this.scrolledPercent((e.top-t)/(-e.height-t)*100),i&&this.#O()})))}return this}stopAutoScrolledPercentUpdates(){return hasValue(this.#b)&&this.#b.unsubscribe(this.#w),this.#w=null,this.#b=null,this}startAutoDistanceUpdates(e,t=15){if(this.calculateDistance&&!hasValue(this.#f)){this.#f=e;const i=round(1e3/t);this.#m=this.#f.subscribe(throttle(i,(()=>{const e=getBoundingClientRect(this.#o),t=window.innerHeight,i=e.top-t,s=e.bottom,r=Math.abs(i)<Math.abs(s)?i:s;this.distancePixels(r),this.distanceViewports(r/t)})))}return this}stopAutoDistanceUpdates(){return hasValue(this.#f)&&this.#f.unsubscribe(this.#m),this.#m=null,this.#f=null,this}startAutoTooLargeUpdates(e,t=15){if(this.autoHandleTooLargeElements&&!hasValue(this.#I)){this.#I=e;const i=round(1e3/t);this.#V=this.#I.subscribe(throttle(i,(()=>{this.#O()})))}return this}stopAutoTooLargeUpdates(){return hasValue(this.#I)&&this.#I.unsubscribe(this.#V),this.#V=null,this.#I=null,this}toJson(){const e={inViewport:this.inViewport(),fullyInViewport:this.fullyInViewport(),upperBoundInViewport:this.upperBoundInViewport(),lowerBoundInViewport:this.lowerBoundInViewport(),visiblePercent:this.visiblePercent(),visiblePixels:this.visiblePixels()};return this.calculateScrolled&&(e.scrolledPercent=this.scrolledPercent()),this.calculateDistance&&(e.distancePixels=this.distancePixels(),e.distanceViewports=this.distanceViewports()),e}#E(e,t=null){return this.#o.dispatchEvent(new CustomEvent(`${e}.${this.#n}`,{detail:t??{}})),fire(this.#o,`${e}.${this.#n}`,t??{}),this}#P(){return hasValue(this.#S)||(this.#S=defer((()=>{this.#S=null,this.#E("changed")})),this.#S()),this}#B(e,t,i,s){return hasValue(t)&&(isBoolean(t)?t&&!e?(this.#E(i),this.#P()):!t&&e&&(this.#E(s),this.#P()):isNumber(t)&&t!==e&&(this.#E(i??s,t),this.#P())),this}#O(){const e=getBoundingClientRect(this.#o),t=window.innerHeight,i=e.top<0?Math.abs(e.top):0,s=e.top+e.height>t?e.top+e.height-t:0;return this.upperBoundInViewport(e.top>=0&&e.top<=t),this.lowerBoundInViewport(e.bottom>=0&&e.bottom<=t),this.visiblePixels(e.height-i-s),this.visiblePercent(this.visiblePixels()/e.height*100),this}}export function isInViewport(e,t=!1){if(t=orDefault(t,!1,"bool"),!isInDom(e))return!1;const i=e.getBoundingClientRect(),s=window.innerWidth,r=window.innerHeight;let n;return n=t?{top:0,right:s,bottom:r,left:0}:{top:1-(i.bottom-i.top),right:s+(i.right-i.left)+1,bottom:r+(i.bottom-i.top)+1,left:1-(i.right-i.left)},i.top>=n.top&&i.right<=n.right&&i.left>=n.left&&i.bottom<=n.bottom}export function scrollTo(e,t=1e3,i=0,s="easeInOutCubic",r=!1,n=!1){const o="scrollTo";t=orDefault(t,1e3,"int"),i=orDefault(i,0,"int"),s=orDefault(s,"easeInOutCubic","str"),r=orDefault(r,!1,"bool"),n=orDefault(n,!1,"bool"),assert(isElement(e)||isWindow(e),`Viewport:${o} | element unusable`),assert(t>0,`Viewport:${o} | durationMs must be > 0`),s=isFunction(EasingFunctions[s])?EasingFunctions[s]:EasingFunctions.easeInOutCubic;const l=new Deferred,a=e.self===e,h=!a&&isInDom(e),u=!(a||!h)&&isInViewport(e,!0);if((h||a)&&(r||!u)){let r,o,h=!1;const u=window.scrollY??window.pageYOffset;o=a?i:u+getBoundingClientRect(e).top-round(window.innerHeight/2)+i;const d=o-u,c=function(e){if(!h){hasValue(r)||(r=e);const i=e-r,n=s(Math.min(i/t,1));window.scrollTo(0,u+d*n),i<t&&n<1?requestAnimationFrame(c):l.resolve()}};if(n){const e=function(){h=!0,l.reject(new Error("cancelled")),window.removeEventListener("DOMMouseScroll",e),window.removeEventListener("mousewheel",e)};window.addEventListener("DOMMouseScroll",e),window.addEventListener("mousewheel",e)}0!==d&&requestAnimationFrame(c)}return l}class VisibilityObserver{#e="VisibilityObserver";#n="visibilityobserver";#U="html element required";#_;#T=!1;#D=!1;#H;#s;#R;#y;#M;#k;#F;#$;#C;#L;#N;#x;#A;constructor(e=10,t=15,i=!1){this.#_=new Map,this.connect(e,t,i)}connect(e=10,t=15,i=!1){this.disconnect(),this.#H=min(orDefault(e,10,"int"),1),this.#s=minMax(1,orDefault(t,15,"int"),120);const s=round(1e3/t);let r;this.#R=throttle(s,this.#z,!0,!0).bind(this),this.#y=throttle(s,this.#j,!0,!0).bind(this),this.#M=throttle(s,this.#Y,!0,!0).bind(this),this.#k=throttle(s,this.#E,!0,!0).bind(this);try{r=i?SimplePollingObserver:IntersectionObserver}catch(e){warn(`Viewport:${this.#e}.connect | IntersectionObserver not available, falling back to SimplePollingObserver`),r=SimplePollingObserver}return this.#q(),this.#$=new r(this.#W.bind(this),{threshold:this.#F,targetFps:this.#s}),this.#J(),this.#K(),this.#T=!0,this}disconnect(){return this.#G(),hasValue(this.#$)&&(this.#$.disconnect(),this.#$=null),this.#_.clear(),this.#T=!1,this.#D=!1,this}observe(e,t=!1,i=!1,s=!0){if(this.#Q()){const r="addElement";assert(isElement(e),`Viewport:${this.#e}.${r} | ${this.#U}`),isInDom(e)||warn(`Viewport:${this.#e}.${r} | element not in DOM`),this.#_.set(e,new VisibilityState(e,t,i,s)),this.#$.observe(e)}return this}unobserve(e){return this.#_.has(e)&&(this.#_.delete(e),this.#$.unobserve(e)),this}getViewportInfo(){return this.#Q()?this.#N:null}getViewportObservable(){return this.#Q()?this.#A:null}getState(e){return this.#Q()&&this.#_.has(e)?this.#_.get(e):null}#Q(){return!!this.#T||(warn(`Viewport:${this.#e}.${__methodName__} | not running, call connect() before`),!1)}#q(){const e=[];for(let t=0;t<=this.#H;t++)e.push(round(t/this.#H,2));return this.#F=e,this}#J(e=!1){const t=window.innerWidth,i=window.innerHeight;if(hasValue(this.#N)){const s=window.scrollY??window.pageYOffset;s>this.#N.scrollTop?this.#N.scrollDirection="down":s<this.#N.scrollTop&&(this.#N.scrollDirection="up"),s>this.#x+10?(this.#N.fuzzyScrollDirection="down",this.#x=s):s<this.#x-10&&(this.#N.fuzzyScrollDirection="up",this.#x=s),this.#N.scrollTop=s,e||(this.#N.width=t,this.#N.height=i,this.#N.bounds.right=t,this.#N.bounds.bottom=i,this.#N.bounds.width=t,this.#N.bounds.height=i)}else this.#N={scrollTop:window.scrollY??window.pageYOffset,scrollDirection:"down",fuzzyScrollDirection:"down",width:t,height:i,bounds:{top:0,right:t,bottom:i,left:0,width:t,height:i}},this.#x=this.#N.scrollTop,this.#A=new Observable(`${this.#N.scrollTop}${this.#N.width}${this.#N.height}`);const s=`${this.#N.scrollTop}${this.#N.width}${this.#N.height}`;return s!==this.#A.getValue()&&(this.#A.setValue(s),this.#k("viewportchanged",this.#N)),this.#N}#z(){return this.#J(!0),this}#j(){return this.#J(),this}#Y(){return this.#J(),this}#X(){return this.#J(),this}#W(e){return e.forEach((e=>{if(hasValue(e.rootBounds)){const t=this.#_.get(e.target);hasValue(t)&&(t.inViewport(e.intersectionRatio>0),t.fullyInViewport(e.intersectionRatio>=1),t.upperBoundInViewport(e.boundingClientRect.top>=e.rootBounds.top&&e.boundingClientRect.top<=e.rootBounds.bottom),t.lowerBoundInViewport(e.boundingClientRect.bottom>=e.rootBounds.top&&e.boundingClientRect.bottom<=e.rootBounds.bottom),t.visiblePercent(100*e.intersectionRatio),t.visiblePixels(e.intersectionRect.height),t.calculateScrolled&&(t.scrolledPercent((e.boundingClientRect.top-e.rootBounds.height)/(-e.boundingClientRect.height-e.rootBounds.height)*100),t.fullyInViewport()?t.startAutoScrolledPercentUpdates(this.#A,this.#s):t.stopAutoScrolledPercentUpdates()),t.calculateDistance&&(t.inViewport()?(t.stopAutoDistanceUpdates(),t.distancePixels(0),t.distanceViewports(0)):t.startAutoDistanceUpdates(this.#A,4)),t.autoHandleTooLargeElements&&e.boundingClientRect.height>e.rootBounds.height&&(t.inViewport()?(t.startAutoTooLargeUpdates(this.#A,this.#s),t.calculateScrolled&&t.startAutoScrolledPercentUpdates(this.#A,this.#s,!1)):(t.stopAutoTooLargeUpdates(),t.calculateScrolled&&t.stopAutoScrolledPercentUpdates())))}})),this.#D||(this.#D=!0,this.#E("initialized")),this.#k("updated"),this}#E(e,t=null){return document.body.dispatchEvent(new CustomEvent(`${e}.${this.#n}`,{detail:t??{}})),fire(document.body,`${e}.${this.#n}`,t??{}),this}#K(){window.addEventListener("scroll",this.#R),window.addEventListener("resize",this.#y),this.#L=new MutationObserver(this.#M),this.#L.observe(document.body,{attributes:!0,childList:!0,subtree:!0});const e=round(1e3/this.#s),t=round(e/10);return this.#C=window.setInterval(this.#X.bind(this),t),this}#G(){return window.clearInterval(this.#C),window.removeEventListener("scroll",this.#R),window.removeEventListener("resize",this.#y),hasValue(this.#L)&&(this.#L.disconnect(),this.#L=null),this}}export{VisibilityObserver};class BreakpointObserver{#e="BreakpointObserver";#Z="handler must be function";#t;#ee;#te;#ie;#se;#y;constructor(e=null,t=4){hasValue(e)&&(assert(isFunction(e),`Viewport:${this.#e}.constructor | ${this.#Z}`),this.#t=e),this.#ee=(e,t)=>{Object.keys(this.#te).length>0&&this.#t?.(e,t)},t=minMax(1,orDefault(t,15,"int"),120);const i=round(1e3/t);this.#y=throttle(i,this.#j,!0,!0).bind(this),this.connect(e)}connect(e=null){return this.disconnect(),hasValue(e)&&(assert(isFunction(e),`Viewport:${this.#e}.connect | ${this.#Z}`),this.#t=e),this.#ie.subscribe(this.#ee),this.#ie.subscribe((e=>{this.#se.setValue(e)})),this.#K(),this}disconnect(){return this.#te={},this.#ie=new Observable,this.#se=new Observable,this.#G(),this}getBreakpoint(e){if(isNumber(e)){let t=null;for(const i in this.#te)if(e===this.#te[i]){t=i;break}return t}return this.#te[`${e}`]??null}getBreakpoints(){return{...this.#te}}getCurrentBreakpoint(){return this.#ie.getValue()}getCurrentBreakpointObservable(){return this.#se}observe(...e){const t=this.#re(e);return this.#te={...this.#te,...t},this.#ne(),this}unobserve(...e){const t=this.#re(e,!0);return Object.keys(t).forEach((e=>{delete this.#te[e]})),this.#ne(),this}#re(e,t=!1){const i="#parseBreakpointList",s="unusable breakpoint";let r={};return Array.from(e).forEach((e=>{if(isPlainObject(e)){for(const t in e)e[t]=parseInt(e[t],10),assert(!isNaN(e[t])&&e[t]>=0,`Viewport:${this.#e}.${i} | ${s} "${t}"`);r={...r,...e}}else if(isArray(e))if(2!==e.length||isPlainObject(e[0])||isArray(e[0])||isPlainObject(e[1])||isArray(e[1]))r={...r,...this.#re(e,t)};else{const t=`${e[0]}`;r[t]=parseInt(e[1],10),assert(!isNaN(r[t])&&r[t]>=0,`Viewport:${this.#e}.${i} | ${s} "${t}"`)}else t&&(r[`${e}`]=null)})),r}#ne(){const e=window.innerWidth,t=Object.entries(this.#te).sort(((e,t)=>e[1]===t[1]?0:e[1]>t[1]?1:-1));let i=null;return t.forEach((([t,s])=>{e>=s&&(i=t)})),this.#ie.setValue(i),this}#j(){return this.#ne(),this}#K(){return window.addEventListener("resize",this.#y),this}#G(){return window.removeEventListener("resize",this.#y),this}}export{BreakpointObserver};
//# sourceMappingURL=viewport.js.map

{"version":3,"file":"events.js","names":["MODULE_NAME","assert","isA","isEventTarget","isPlainObject","orDefault","hasValue","isEmpty","isSelector","slugify","removeFrom","EVENT_MAP","Map","DEFAULT_NAMESPACE","EVENT_OPTION_SUPPORT","capture","once","passive","signal","options","window","addEventListener","removeEventListener","err","prepareEventMethodBaseParams","methodName","targets","events","handler","handlerIsOptional","length","targetsAreEventTargets","delegatedTargetsAreSelectorsAndHaveAncestor","forEach","target","targetIndex","ancestor","map","event","replace","replaceAll","prepareEventMethodAdditionalTargetInfo","prevTarget","nextTarget","hasDelegation","isDelegation","prepareEventMethodEventInfo","eventName","defaultNamespace","defaultEvent","eventParts","split","namespace","gatherTargetEvents","delegation","__methodName__","name","targetEvents","get","gatheredTargetEvents","nameSpaceScope","delegations","Set","add","Object","keys","ns","ev","cleanUpEventMap","concat","desertedTargets","has","targetNamespace","targetEvent","targetScope","handlerCount","handlers","delegationHandlerCount","push","desertedTarget","delete","createDelegatedHandler","e","delegationSelector","matches","syntheticTarget","createHandlerRemover","handlerScope","removedHandlers","filter","existingHandler","removedHandler","action","createSelfRemovingHandler","removeLocatedHandler","delegationScope","removeHandlers","removedCount","Array","from","removeDelegatedHandlers","pauseLocatedHandlers","paused","pausedHandlers","pausedHandler","pauseHandlers","pausedCount","pauseDelegatedHandlers","createPauseAwareAction","managedHandler","nonPauseAwareAction","compileEventListenerOptions","supportedOptions","option","createSyntheticEvent","payload","bubbles","cancelable","EventConstructor","eventOptions","console","warn","CustomEvent","detail","syntheticTargetElements","defineProperty","querySelectorAll","on","removers","set","__default","remover","eventListenerOptions","off","pause","resume","fire","fireCount","syntheticEvent","emit","emitCount","element","dispatchEvent"],"sources":["events.js"],"mappings":"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","sourcesContent":["/*!\n * Module Events\n */\n\n/**\n * @namespace Events\n */\n\nconst MODULE_NAME = 'Events';\n\n\n\n//###[ IMPORTS ]########################################################################################################\n\nimport {assert, isA, isEventTarget, isPlainObject, orDefault, hasValue, isEmpty, isSelector} from './basic.js';\nimport {slugify} from './strings.js';\nimport {removeFrom} from './arrays.js';\n\n\n\n//###[ DATA ]###########################################################################################################\n\nexport const EVENT_MAP = new Map();\n\nconst\n\tDEFAULT_NAMESPACE = '__default',\n\tEVENT_OPTION_SUPPORT = {\n\t\tcapture : false,\n\t\tonce : false,\n\t\tpassive : false,\n\t\tsignal : false\n\t}\n;\n\ntry {\n\tconst options = {\n\t\tget capture(){\n\t\t\tEVENT_OPTION_SUPPORT.capture = true;\n\t\t\treturn false;\n\t\t},\n\t\tget once(){\n\t\t\tEVENT_OPTION_SUPPORT.once = true;\n\t\t\treturn false;\n\t\t},\n\t\tget passive(){\n\t\t\tEVENT_OPTION_SUPPORT.passive = true;\n\t\t\treturn false;\n\t\t},\n\t\tget signal(){\n\t\t\tEVENT_OPTION_SUPPORT.signal = true;\n\t\t\treturn false;\n\t\t},\n\t};\n\n\twindow.addEventListener('test', null, options);\n\twindow.removeEventListener('test', null, options);\n} catch (err){}\n\n\n\n//###[ HELPERS ]########################################################################################################\n\n/*\n * Takes the standard set of event function parameters, sanitizes the values and asserts basic compatability.\n * Returns the transformed parameters as a object, with keys of the same name as the relevant parameters.\n */\nfunction prepareEventMethodBaseParams(methodName, targets, events, handler, handlerIsOptional=false){\n\ttargets = orDefault(targets, [], 'arr');\n\tassert(targets.length > 0, `${MODULE_NAME}:${methodName} | no targets provided`);\n\tevents = orDefault(events, [], 'arr');\n\tassert(events.length > 0, `${MODULE_NAME}:${methodName} | no events provided`);\n\tif( !handlerIsOptional || hasValue(handler) ){\n\t\tassert(isA(handler, 'function'), `${MODULE_NAME}:${methodName} | handler is not a function`);\n\t}\n\n\tlet\n\t\ttargetsAreEventTargets = true,\n\t\tdelegatedTargetsAreSelectorsAndHaveAncestor = true\n\t;\n\n\ttargets.forEach((target, targetIndex) => {\n\t\tif( isA(target, 'string') ){\n\t\t\tconst ancestor = (targetIndex > 0) ? targets[targetIndex - 1] : null;\n\t\t\tdelegatedTargetsAreSelectorsAndHaveAncestor &&= isSelector(target) && isEventTarget(ancestor);\n\t\t} else {\n\t\t\ttargetsAreEventTargets &&= isEventTarget(target);\n\t\t}\n\t});\n\n\tassert(targetsAreEventTargets, `${MODULE_NAME}:${methodName} | not all targets are event targets`);\n\tassert(\n\t\tdelegatedTargetsAreSelectorsAndHaveAncestor,\n\t\t`${MODULE_NAME}:${methodName} | not all delegated targets are a selector or have an ancestor`\n\t);\n\n\tevents = events\n\t\t.map(event => event.replace(`.${DEFAULT_NAMESPACE}`, '.-default-ns'))\n\t\t.map(event => slugify(event, {\n\t\t\t'.' : '___dot___',\n\t\t\t'*' : '___star___'\n\t\t}))\n\t\t.map(event => event.replaceAll('___dot___', '.'))\n\t\t.map(event => event.replaceAll('___star___', '*'))\n\t\t.map(event => event.replace('.-default-ns', `.${DEFAULT_NAMESPACE}`))\n\t;\n\n\treturn {targets, events, handler};\n}\n\n\n\n/*\n * Prepares basic information about the current target in a list of targets.\n * The current target is identified by index, since the same target may appear multiple times in a list,\n * for example as a target and a delegation ancestor.\n */\nfunction prepareEventMethodAdditionalTargetInfo(methodName, targets, targetIndex){\n\tconst\n\t\tprevTarget =  ((targetIndex - 1) >= 0) ? targets[targetIndex - 1] : null,\n\t\tnextTarget =  (targetIndex < (targets.length - 1)) ? targets[targetIndex + 1] : null,\n\t\thasDelegation = isSelector(nextTarget),\n\t\tisDelegation = isSelector(targets[targetIndex])\n\t;\n\n\tassert(\n\t\t!isDelegation || (isDelegation && isEventTarget(prevTarget)),\n\t\t`${MODULE_NAME}:${methodName} | delegation has no ancestor`\n\t);\n\n\treturn {prevTarget, nextTarget, hasDelegation, isDelegation};\n}\n\n\n\n/*\n * Prepares basic information about the current event in a list of events.\n * The current event is identified by a complete eventName string containing the event itself,\n * as well as the complete dot-separated namespace.\n */\nfunction prepareEventMethodEventInfo(eventName, defaultNamespace=null, defaultEvent=null){\n\tconst\n\t\teventParts = eventName.replace('.', '/////').split('/////'),\n\t\tevent = (isEmpty(eventParts[0]) || (eventParts[0] === '*')) ? defaultEvent : eventParts[0],\n\t\tnamespace = (isEmpty(eventParts[1]) || (eventParts[1] === '*')) ? defaultNamespace : eventParts[1]\n\t;\n\n\treturn {event, namespace};\n}\n\n\n\n/*\n * Gathers matching events with namespaces for a given target (with or without a delegation).\n * Returns the found namespaces and events as a dictionary of namespaces with values of sets containing\n * the corresponding event names.\n */\nfunction gatherTargetEvents(target, namespace=null, event=null, delegation=null){\n\tconst __methodName__ = gatherTargetEvents.name;\n\n\tconst targetEvents = EVENT_MAP.get(target);\n\tassert(isPlainObject(targetEvents), `${MODULE_NAME}:${__methodName__} | invalid target \"${target}\"`);\n\n\tconst gatheredTargetEvents = {};\n\n\tif( !hasValue(namespace) && !hasValue(event) ){\n\t\tObject.keys(targetEvents).forEach(ns => {\n\t\t\tgatheredTargetEvents[ns] = new Set([]);\n\t\t\tObject.keys(targetEvents[ns]).forEach(ev => {\n\t\t\t\tif( !hasValue(delegation) || hasValue(targetEvents[ns][ev].delegations[delegation]) ){\n\t\t\t\t\tgatheredTargetEvents[ns].add(ev);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t} else if( !hasValue(event) ){\n\t\tconst nameSpaceScope = targetEvents[namespace];\n\t\tif( hasValue(nameSpaceScope) ){\n\t\t\tgatheredTargetEvents[namespace] = new Set([]);\n\t\t\tObject.keys(targetEvents[namespace]).forEach(ev => {\n\t\t\t\tif( !hasValue(delegation) || hasValue(nameSpaceScope[ev].delegations[delegation]) ){\n\t\t\t\t\tgatheredTargetEvents[namespace].add(ev);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t} else if( !hasValue(namespace) ){\n\t\tObject.keys(targetEvents).forEach(ns => {\n\t\t\tconst nameSpaceScope = targetEvents[ns];\n\t\t\tif(\n\t\t\t\thasValue(nameSpaceScope[event])\n\t\t\t\t&& (!hasValue(delegation) || hasValue(nameSpaceScope[event].delegations[delegation]))\n\t\t\t){\n\t\t\t\tif( !hasValue(gatheredTargetEvents[ns]) ){\n\t\t\t\t\tgatheredTargetEvents[ns] = new Set([]);\n\t\t\t\t}\n\t\t\t\tgatheredTargetEvents[ns].add(event);\n\t\t\t}\n\t\t});\n\t} else {\n\t\tconst nameSpaceScope = targetEvents[namespace];\n\t\tif(\n\t\t\thasValue(nameSpaceScope)\n\t\t\t&& hasValue(nameSpaceScope[event])\n\t\t\t&& (!hasValue(delegation) || hasValue(nameSpaceScope[event].delegations[delegation]))\n\t\t){\n\t\t\tif( !hasValue(gatheredTargetEvents[namespace]) ){\n\t\t\t\tgatheredTargetEvents[namespace] = new Set([]);\n\t\t\t}\n\t\t\tgatheredTargetEvents[namespace].add(event);\n\t\t}\n\t}\n\n\treturn gatheredTargetEvents;\n}\n\n\n\n/*\n * Iterates through the event map (starting with a specific target or using all targets) and searches for\n * deserted handler definitions. Deletes definitions that do not contain any handlers anymore and recursively\n * removes the path back to the starting point(s) if it turns out to be empty afterwards.\n */\nfunction cleanUpEventMap(targets){\n\ttargets = hasValue(targets) ? new Set([].concat(targets)) : null;\n\n\tconst desertedTargets = [];\n\n\tEVENT_MAP.forEach((targetEvents, target) => {\n\t\tif( !hasValue(targets) || targets.has(target) ){\n\t\t\tObject.keys(targetEvents).forEach(targetNamespace => {\n\t\t\t\tObject.keys(targetEvents[targetNamespace]).forEach(targetEvent => {\n\t\t\t\t\tconst targetScope = targetEvents[targetNamespace][targetEvent];\n\t\t\t\t\tlet handlerCount = targetScope.handlers.length;\n\n\t\t\t\t\tObject.keys(targetScope.delegations).forEach(delegation => {\n\t\t\t\t\t\tconst delegationHandlerCount = targetScope.delegations[delegation].handlers.length;\n\t\t\t\t\t\thandlerCount += delegationHandlerCount;\n\n\t\t\t\t\t\tif( delegationHandlerCount === 0 ){\n\t\t\t\t\t\t\tdelete targetScope.delegations[delegation];\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\tif( handlerCount === 0){\n\t\t\t\t\t\tdelete targetEvents[targetNamespace][targetEvent];\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tif( Object.keys(targetEvents[targetNamespace]).length === 0 ){\n\t\t\t\t\tdelete targetEvents[targetNamespace];\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif( Object.keys(targetEvents).length === 0 ){\n\t\t\t\tdesertedTargets.push(target);\n\t\t\t}\n\t\t}\n\t});\n\n\tdesertedTargets.forEach(desertedTarget => {\n\t\tEVENT_MAP.delete(desertedTarget);\n\t});\n}\n\n\n\n/*\n * Takes a handler function and returns a new function wrapping the handler, making sure, that the handler only\n * executes, if the event target matches the given delegation selector. So, the returned function automatically\n * checks if the delegation is actually met.\n */\nfunction createDelegatedHandler(delegation, handler){\n\treturn function delegatedHandler(e){\n\t\tconst\n\t\t\tdelegationSelector = `${delegation}`,\n\t\t\tdelegationFulfilled = hasValue(e.target?.matches)\n\t\t\t\t? e.target.matches(delegationSelector)\n\t\t\t\t: (\n\t\t\t\t\tisEventTarget(e.syntheticTarget)\n\t\t\t\t\t|| (\n\t\t\t\t\t\tisA(e.syntheticTarget, 'array')\n\t\t\t\t\t\t&& isSelector(e.syntheticTarget[1])\n\t\t\t\t\t)\n\t\t\t\t\t? (\n\t\t\t\t\t\tisEventTarget(e.syntheticTarget)\n\t\t\t\t\t\t? e.syntheticTarget.matches(delegationSelector)\n\t\t\t\t\t\t: (e.syntheticTarget[1] === delegationSelector))\n\t\t\t\t\t: null\n\t\t\t\t)\n\t\t;\n\n\t\tif( delegationFulfilled ){\n\t\t\thandler(e);\n\t\t}\n\t};\n}\n\n\n\n/*\n * Takes a handler function and returns a new function, which, when executed, removes the handler from the exact\n * path in the EVENT_MAP, defined by the given target, namespace and event (and, optionally, a delegation selector).\n * Using this function, one can undo the setting of a handler, using \"on\" or \"once\".\n */\nfunction createHandlerRemover(target, namespace, event, handler, delegation=null){\n\tconst\n\t\t__methodName__ = createHandlerRemover.name,\n\t\ttargetEvents = EVENT_MAP.get(target)\n\t;\n\tlet handlerScope = targetEvents?.[namespace]?.[event];\n\n\tif( hasValue(delegation) ){\n\t\tassert(isSelector(delegation), `${MODULE_NAME}:${__methodName__} | invalid delegation \"${delegation}\"`);\n\t\thandlerScope = handlerScope.delegations[`${delegation}`];\n\t}\n\n\tassert(isPlainObject(handlerScope), `${MODULE_NAME}:${__methodName__} | invalid handlerScope`);\n\n\treturn function handlerRemover(){\n\t\tconst removedHandlers = handlerScope.handlers.filter(existingHandler => existingHandler.handler === handler);\n\t\thandlerScope.handlers = removeFrom(handlerScope.handlers, removedHandlers);\n\n\t\tremovedHandlers.forEach(removedHandler => {\n\t\t\ttarget.removeEventListener(event, removedHandler.action);\n\t\t});\n\n\t\tcleanUpEventMap(target);\n\t};\n}\n\n\n\n/*\n * Takes a handler function and returns a new function, which, when executed, calls the handler and, afterwards,\n * automatically removes the handler from the path in the EVENT_MAP, defined by the given target, namespace and event\n * (and, optionally, a delegation selector). So, the returned function is essentially a self-destructing handler.\n */\nfunction createSelfRemovingHandler(target, namespace, event, handler, delegation=null){\n\treturn function selfRemovingHandler(e){\n\t\thandler(e);\n\t\tcreateHandlerRemover(target, namespace, event, handler, delegation)();\n\t};\n}\n\n\n\n/*\n * Removes (a) handler(s) from a path in the EVENT_MAP, defined by the given target, namespace, event and handler\n * (and, optionally, a delegation selector).\n */\nfunction removeLocatedHandler(target, namespace, event, handler, delegation=null){\n\tconst\n\t\t__methodName__ = removeLocatedHandler.name,\n\t\ttargetEvents = EVENT_MAP.get(target),\n\t\ttargetScope = targetEvents?.[namespace]?.[event]\n\t;\n\n\tassert(isPlainObject(targetScope), `${MODULE_NAME}:${__methodName__} | invalid targetScope`);\n\n\tlet handlerScope;\n\tif( hasValue(delegation) ){\n\t\tconst delegationScope = targetScope.delegations[`${delegation}`];\n\t\tassert(isPlainObject(delegationScope), `${MODULE_NAME}:${__methodName__} | invalid delegation \"${delegation}\"`);\n\t\thandlerScope = delegationScope;\n\t} else {\n\t\thandlerScope = targetScope;\n\t}\n\tconst removedHandlers = handlerScope.handlers.filter(existingHandler => {\n\t\treturn hasValue(handler)\n\t\t\t? (handler === existingHandler.handler)\n\t\t\t: true\n\t\t;\n\t});\n\n\thandlerScope.handlers = removeFrom(handlerScope.handlers, removedHandlers);\n\n\tremovedHandlers.forEach(removedHandler => {\n\t\ttarget.removeEventListener(event, removedHandler.action);\n\t});\n\n\treturn removedHandlers.length;\n}\n\n\n\n/*\n * Removes all handlers matching the given definition provided by target, namespace, event and handler\n * (and, optionally, a delegation selector). Leaving out namespace, event or handler works as a wildcard.\n */\nfunction removeHandlers(target, namespace=null, event=null, handler=null, delegation=null){\n\tconst targetEvents = gatherTargetEvents(target, namespace, event, delegation);\n\n\tlet removedCount = 0;\n\n\tObject.keys(targetEvents).forEach(ns => {\n\t\tArray.from(targetEvents[ns]).forEach(ev => {\n\t\t\tremovedCount += removeLocatedHandler(target, ns, ev, handler, delegation);\n\t\t});\n\t});\n\n\treturn removedCount;\n}\n\n\n\n/*\n * Shorthand-function for \"removeHandlers\" with more sane parameter order for delegations.\n */\nfunction removeDelegatedHandlers(ancestor, delegation, namespace=null, event=null, handler=null){\n\treturn removeHandlers(ancestor, namespace, event, handler, delegation);\n}\n\n\n\n/*\n * Pauses (a) handler(s) from a path in the EVENT_MAP, defined by the given target, namespace, event and handler\n * (and, optionally, a delegation selector). If paused is false, the function instead resumes the handlers.\n */\nfunction pauseLocatedHandlers(target, namespace, event, handler, delegation=null, paused=true){\n\tconst\n\t\t__methodName__ = pauseLocatedHandlers.name,\n\t\ttargetEvents = EVENT_MAP.get(target),\n\t\ttargetScope = targetEvents?.[namespace]?.[event]\n\t;\n\n\tassert(isPlainObject(targetScope), `${MODULE_NAME}:${__methodName__} | invalid targetScope`);\n\n\tlet handlerScope;\n\tif( hasValue(delegation) ){\n\t\tconst delegationScope = targetScope.delegations[`${delegation}`];\n\t\tassert(isPlainObject(delegationScope), `${MODULE_NAME}:${__methodName__} | invalid delegation \"${delegation}\"`);\n\t\thandlerScope = delegationScope;\n\t} else {\n\t\thandlerScope = targetScope;\n\t}\n\n\tconst pausedHandlers = handlerScope.handlers.filter(existingHandler => {\n\t\treturn hasValue(handler)\n\t\t\t? (handler === existingHandler.handler)\n\t\t\t: true\n\t\t;\n\t});\n\n\tpausedHandlers.forEach(pausedHandler => {\n\t\tpausedHandler.paused = !!paused;\n\t});\n\n\treturn pausedHandlers.length;\n}\n\n\n\n/*\n * Pauses all handlers matching the given definition provided by target, namespace, event and handler\n * (and, optionally, a delegation selector). Leaving out namespace, event or handler works as a wildcard.\n * If paused is false, the function instead resumes the handlers.\n */\nfunction pauseHandlers(target, namespace=null, event=null, handler=null, delegation=null, paused=true){\n\tconst targetEvents = gatherTargetEvents(target, namespace, event, delegation);\n\n\tlet pausedCount = 0;\n\n\tObject.keys(targetEvents).forEach(ns => {\n\t\tArray.from(targetEvents[ns]).forEach(ev => {\n\t\t\tpausedCount += pauseLocatedHandlers(target, ns, ev, handler, delegation, paused);\n\t\t});\n\t});\n\n\treturn pausedCount;\n}\n\n\n\n/*\n * Shorthand-function for \"pauseHandlers\" with more sane parameter order for delegations.\n */\nfunction pauseDelegatedHandlers(ancestor, delegation, namespace=null, event=null, handler=null, paused=true){\n\treturn pauseHandlers(ancestor, namespace, event, handler, delegation, paused);\n}\n\n\n\n/*\n * Takes a handler object and a corresponding action, which is not yet aware of its pause state and\n * returns an action function, which checks if the handler is paused, before executing the original action.\n * Using this, we can wrap handler actions to automatically react to the handler's pause state, preventing any\n * handler execution if the handler is currently paused.\n */\nfunction createPauseAwareAction(managedHandler, nonPauseAwareAction){\n\treturn function pauseAwareHandler(e){\n\t\tif( !managedHandler.paused ){\n\t\t\tnonPauseAwareAction(e);\n\t\t}\n\t};\n}\n\n\n\n/*\n * Takes an event listener options object as provided by the user, to be used as the third parameter of\n * addEventListener, and returns a sanitized version, taking into regard what options the browser actually supports\n * and falling back to boolean capture values, if the browser does not know about listener options at all.\n */\nfunction compileEventListenerOptions(options){\n\tif( isA(options, 'boolean') ) return options;\n\tif( !isA(options, 'object') ) return null;\n\n\tconst supportedOptions = {};\n\n\tObject.keys(EVENT_OPTION_SUPPORT).forEach(option => {\n\t\tif( !!EVENT_OPTION_SUPPORT[option] && hasValue(options[option]) ){\n\t\t\tsupportedOptions[option] = options[option];\n\t\t}\n\t});\n\n\tif( (Object.keys(supportedOptions).length === 0) && !!options.capture ){\n\t\treturn true;\n\t}\n\n\treturn supportedOptions;\n}\n\n\n\n/*\n * Creates a synthetic event to dispatch on an event target.\n */\nfunction createSyntheticEvent(\n\tevent,\n\tnamespace=null,\n\tpayload=null,\n\tbubbles=null,\n\tcancelable=null,\n\tsyntheticTarget=null,\n\tEventConstructor=null,\n\teventOptions=null\n){\n\tconst __methodName__ = createSyntheticEvent.name;\n\n\tevent = `${event}`;\n\tbubbles = orDefault(bubbles, false, 'bool');\n\tcancelable = orDefault(cancelable, bubbles, 'bool');\n\teventOptions = isPlainObject(eventOptions) ? eventOptions : {};\n\n\tlet e;\n\tif( isA(EventConstructor, 'function') ){\n\t\tif( isPlainObject(payload) ){\n\t\t\tconsole.warn(`${MODULE_NAME}:${__methodName__} | can't add payload to event \"${EventConstructor.name}\", skipping`);\n\t\t}\n\t\te = new EventConstructor(event, {bubbles, cancelable, ...eventOptions});\n\t} else {\n\t\te = isPlainObject(payload)\n\t\t\t? new CustomEvent(event, {detail : payload, bubbles, cancelable, ...eventOptions})\n\t\t\t// we could use new Event() here, but jsdom and ava cannot use that constructor for dispatchEvent :(\n\t\t\t: new CustomEvent(event, {bubbles, cancelable, ...eventOptions})\n\t\t;\n\t}\n\n\tif( hasValue(namespace) ){\n\t\te.namespace = `${namespace}`;\n\t}\n\n\tif( isEventTarget(syntheticTarget) ){\n\t\te.syntheticTarget = syntheticTarget;\n\t\te.syntheticTargetElements = [syntheticTarget]\n\t} else if(\n\t\tisA(syntheticTarget, 'array')\n\t\t&& isEventTarget(syntheticTarget[0])\n\t\t&& isSelector(syntheticTarget[1])\n\t){\n\t\te.syntheticTarget = syntheticTarget;\n\t\tObject.defineProperty(e, 'syntheticTargetElements', {\n\t\t\tget(){\n\t\t\t\treturn Array.from(syntheticTarget[0].querySelectorAll(`${syntheticTarget[1]}`));\n\t\t\t}\n\t\t});\n\t}\n\n\treturn e;\n}\n\n\n\n//###[ EXPORTS ]########################################################################################################\n\n/**\n * @namespace Events:on\n */\n\n/**\n * Registers (an) event listener(s) to (a) valid EventTarget(s) (most likely (a) DOM-element(s)).\n *\n * This method is inspired by jQuery and cash, though not identical.\n * You may define one or more targets as well as one or more events to register a handler to, by either providing single\n * arguments or arrays. You may also, additionally, namespace events, like in jQuery/cash, by adding it after the event\n * name, separated by a dot ('click.namespace').\n *\n * This method returns a remover function, which removes all event registrations done by this method call.\n * So, in essence, calling that function, removes exactly, what was added, in a single call.\n *\n * @param {EventTarget|Array<EventTarget>} targets - the target(s) to register event handlers on\n * @param {String|Array<String>} events - the event name(s) to listen to, can be either a single name or a list of names, each name may also have a namespace, separated by a dot, to target all events/namespaces, you may use \"*\"/\"*.*\"\n * @param {Function} handler - the callback to execute if the event(s) defined in events are being received on target\n * @param {?Object|Boolean} [options=null] - event listener options according to \"addEventListener\"-syntax, will be ignored, if browser does not support this, if boolean, will be used as \"useCapture\", the same will happen if options are not supported, but you defined \"{capture : true}\", \"{once : true}\" will not be applied directly to the listener, but will, instead, set the \"once\"-parameter to true (otherwise delegated listeners would self-destroy immediately on any check)\n * @param {?Boolean} [once=false] - defines if the handler should only execute once, after which it self-destroys automatically, this will automatically be enabled, if you set options.once to true\n * @throws error in case no targets are defined\n * @throws error in case no events are defined\n * @throws error in case no handler is not a function\n * @throws error in case targets are not all usable event targets\n * @throws error in case delegations are missing viable ancestor targets\n * @returns {Function} remover function, which removes all handlers again, added by the current execution\n *\n * @memberof Events:on\n * @alias on\n * @see off\n * @see once\n * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget\n * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener?retiredLocale=de#syntax\n * @example\n * on(linkElement, 'click', e => {\te.stopPropagation(); });\n * on(someElementWithCustomEvents, 'crash.test', () => { alert('crashed!'); });\n * on([ancestorElement, 'a'], 'click', e => { e.target.classList.add('clicked'); });\n * on(buttonElement, 'click', () => { console.log('click twice, but I'll just print once); }, {passive : true, once : true});\n * on([ancestorElement, '.btn[data-foobar=\"test\"]'], 'click', () => { console.log('I'll just fire once); }, null, true);\n * on(document.body, 'click', e => { console.log(`oh, a bubbled event, let's see what has been clicked: \"${e.target}\"`); });\n * on([foo, foo, 'button', bar], ['mousedown', 'touchstart'], e => { e.target.classList.add('interaction-start'); });\n */\nexport function on(targets, events, handler, options=null, once=false){\n\tconst __methodName__ = on.name;\n\n\t({targets, events, handler} = prepareEventMethodBaseParams(__methodName__, targets, events, handler));\n\tonce = !!once || !!options?.once;\n\tdelete options?.once;\n\n\tconst removers = [];\n\n\ttargets.forEach((target, targetIndex) => {\n\t\tconst {\n\t\t\tprevTarget,\n\t\t\thasDelegation,\n\t\t\tisDelegation\n\t\t} = prepareEventMethodAdditionalTargetInfo(__methodName__, targets, targetIndex);\n\n\t\tlet targetEvents = EVENT_MAP.get(target);\n\t\tif( isDelegation ){\n\t\t\ttargetEvents = EVENT_MAP.get(prevTarget);\n\t\t} else if( !hasValue(targetEvents) ){\n\t\t\tEVENT_MAP.set(target, {[DEFAULT_NAMESPACE] : {}});\n\t\t\ttargetEvents = EVENT_MAP.get(target);\n\t\t}\n\n\t\tif( !hasDelegation ){\n\t\t\tevents.forEach(eventName => {\n\t\t\t\tconst {event, namespace} = prepareEventMethodEventInfo(eventName, DEFAULT_NAMESPACE);\n\n\t\t\t\tif( !hasValue(targetEvents[namespace]) ){\n\t\t\t\t\ttargetEvents[namespace] = {};\n\t\t\t\t}\n\n\t\t\t\tif( !hasValue(targetEvents[namespace][event]) ){\n\t\t\t\t\ttargetEvents[namespace][event] = {\n\t\t\t\t\t\ttarget : isDelegation ? prevTarget : target,\n\t\t\t\t\t\thandlers : [],\n\t\t\t\t\t\tdelegations : {}\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tconst targetScope = targetEvents[namespace][event];\n\t\t\t\tlet handlerScope, action, remover;\n\n\t\t\t\tif( isDelegation ){\n\t\t\t\t\tif( !hasValue(targetScope.delegations[target]) ){\n\t\t\t\t\t\ttargetScope.delegations[target] = {handlers : []};\n\t\t\t\t\t}\n\t\t\t\t\thandlerScope = targetScope.delegations[target];\n\n\t\t\t\t\taction = !!once\n\t\t\t\t\t\t? createDelegatedHandler(\n\t\t\t\t\t\t\ttarget,\n\t\t\t\t\t\t\tcreateSelfRemovingHandler(targetScope.target, namespace, event, handler, target)\n\t\t\t\t\t\t)\n\t\t\t\t\t\t: createDelegatedHandler(target, handler)\n\t\t\t\t\t;\n\t\t\t\t\tremover = createHandlerRemover(targetScope.target, namespace, event, handler, target);\n\t\t\t\t} else {\n\t\t\t\t\thandlerScope = targetScope;\n\t\t\t\t\taction = !!once\n\t\t\t\t\t\t? createSelfRemovingHandler(targetScope.target, namespace, event, handler)\n\t\t\t\t\t\t: handler\n\t\t\t\t\t;\n\t\t\t\t\tremover = createHandlerRemover(targetScope.target, namespace, event, handler);\n\t\t\t\t}\n\n\t\t\t\tconst managedHandler = {\n\t\t\t\t\thandler,\n\t\t\t\t\tremover,\n\t\t\t\t\tpaused : false,\n\t\t\t\t};\n\t\t\t\tmanagedHandler.action = createPauseAwareAction(managedHandler, action);\n\t\t\t\thandlerScope.handlers = handlerScope.handlers.concat(managedHandler);\n\n\t\t\t\tconst eventListenerOptions = compileEventListenerOptions(options);\n\t\t\t\tif( hasValue(eventListenerOptions) ){\n\t\t\t\t\ttargetScope.target.addEventListener(event, managedHandler.action, eventListenerOptions);\n\t\t\t\t} else {\n\t\t\t\t\ttargetScope.target.addEventListener(event, managedHandler.action);\n\t\t\t\t}\n\n\t\t\t\tremovers.push(remover);\n\t\t\t});\n\t\t}\n\t});\n\n\treturn (removers.length > 1)\n\t\t? function(){\n\t\t\tremovers.forEach(remover => remover());\n\t\t}\n\t\t: (\n\t\t\t(removers.length > 0)\n\t\t\t? removers[0]\n\t\t\t: null\n\t\t)\n\t;\n}\n\n\n\n/**\n * @namespace Events:once\n */\n\n/**\n * Registers (an) event listener(s) to (a) valid EventTarget(s) (most likely (a) DOM-element(s)).\n *\n * This version automatically removes the handler, after it has fired once.\n *\n * This method is inspired by jQuery and cash, though not identical.\n * You may define one or more targets as well as one or more events to register a handler to, by either providing single\n * arguments or arrays. You may also, additionally, namespace events, like in jQuery/cash, by adding it after the event\n * name, separated by a dot ('click.namespace').\n *\n * This method returns a remover function, which removes all event registrations done by this method call.\n * So, in essence, calling that function, removes exactly, what was added, in a single call.\n *\n * @param {EventTarget|Array<EventTarget>} targets - the target(s) to register event handlers on\n * @param {String|Array<String>} events - the event name(s) to listen to, can be either a single name or a list of names, each name may also have a namespace, separated by a dot, to target all events/namespaces, you may use \"*\"/\"*.*\"\n * @param {Function} handler - the callback to execute if the event(s) defined in events are being received on target\n * @param {?Object|Boolean} [options=null] - event listener options according to \"addEventListener\"-syntax, will be ignored, if browser does not support this, if boolean, will be used as \"useCapture\", the same will happen if options are not supported, but you defined \"{capture : true}\", \"{once : true}\" makes no sense in this case, because the behaviour will automatically be applied anyway\n * @throws error in case no targets are defined\n * @throws error in case no events are defined\n * @throws error in case no handler is not a function\n * @throws error in case targets are not all usable event targets\n * @throws error in case delegations are missing viable ancestor targets\n * @returns {Function} remover function, which removes all handlers again, added by the current execution\n *\n * @memberof Events:once\n * @alias once\n * @see on\n * @see off\n * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget\n * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener?retiredLocale=de#syntax\n * @example\n * once(linkElement, 'click', e => {\te.stopPropagation(); });\n * once(someElementWithCustomEvents, 'crash.test', () => { alert('crashed!'); });\n * once([ancestorElement, 'a'], 'click', e => { e.target.classList.add('clicked'); });\n * once(buttonElement, 'click', () => { console.log('click twice, but I'll just print once); }, {passive : true});\n * once([ancestorElement, '.btn[data-foobar=\"test\"]'], 'click', () => { console.log('I'll just fire once); });\n * once(document.body, 'click', e => { console.log(`oh, a bubbled event, let's see what has been clicked: \"${e.target}\"`); });\n * once([foo, foo, 'button', bar], ['mousedown', 'touchstart'], e => { e.target.classList.add('interaction-start'); });\n */\nexport function once(targets, events, handler, options=null){\n\treturn on(targets, events, handler, options, true);\n}\n\n\n\n/**\n * @namespace Events:off\n */\n\n/**\n * Removes (a), previously defined, event listener(s) on (a) valid EventTarget(s) (most likely (a) DOM-element(s)).\n *\n * The definition of targets and events works exactly as in \"on\" and \"once\", the only difference being, that the handler\n * is optional in this case, which results in the removal of all handlers, without targeting a specific one.\n *\n * To specifically target handlers without a namespace, please use the namespace-string \"__default\".\n *\n * @param {EventTarget|Array<EventTarget>} targets - the target(s) to remove event handlers from\n * @param {String|Array<String>} events - the event name(s) to remove, can be either a single name or a list of names, each name may also have a namespace, separated by a dot, to target all events/namespaces, you may use \"*\"/\"*.*\"\n * @param {?Function} [handler=null] - a specific callback function to remove\n * @throws error in case no targets are defined\n * @throws error in case no events are defined\n * @throws error in case no handler is not a function\n * @throws error in case targets are not all usable event targets\n * @throws error in case delegations are missing viable ancestor targets\n * @returns {Number} the number of handlers actually removed by the function call, may also be 0 if nothing matched\n *\n * @memberof Events:off\n * @alias off\n * @see on\n * @see once\n * @example\n * off(buttonElement, 'click');\n * off(bar, '*.__default');\n * off(customEventElement, 'crash');\n * off([ancestorElement, 'a'], 'click');\n * off([ancestorElement, '.btn[data-foobar=\"test\"]'], '*.delegated', fSpecificHandler);\n * off(linkElement, '*', fSpecificHandler);\n * off(customEventElement, ['*.test', '*.site']);\n * off([ancestorElement, 'a', ancestorElement, '.btn[data-foobar=\"test\"]'], '*.*', fSpecificHandler);\n * off(buttonElement, '*.*');\n */\nexport function off(targets, events, handler=null){\n\tconst __methodName__ = off.name;\n\n\t({targets, events, handler} = prepareEventMethodBaseParams(__methodName__, targets, events, handler, true));\n\n\tlet removedCount = 0;\n\n\ttargets.forEach((target, targetIndex) => {\n\t\tconst {\n\t\t\tprevTarget,\n\t\t\thasDelegation,\n\t\t\tisDelegation\n\t\t} = prepareEventMethodAdditionalTargetInfo(__methodName__, targets, targetIndex);\n\n\t\tif( !hasDelegation ){\n\t\t\tconst targetEvents = isDelegation ? EVENT_MAP.get(prevTarget) : EVENT_MAP.get(target);\n\n\t\t\tif( hasValue(targetEvents) ){\n\t\t\t\tevents.forEach(eventName => {\n\t\t\t\t\tconst {event, namespace} = prepareEventMethodEventInfo(eventName);\n\n\t\t\t\t\tif( isDelegation ){\n\t\t\t\t\t\tremovedCount += removeDelegatedHandlers(prevTarget, target, namespace, event, handler);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tremovedCount += removeHandlers(target, namespace, event, handler);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tcleanUpEventMap(isDelegation ? prevTarget : target);\n\t\t\t}\n\t\t}\n\t});\n\n\treturn removedCount;\n}\n\n\n\n/**\n * @namespace Events:pause\n */\n\n/**\n * Pauses (a), previously defined, event listener(s), without actually removing anything. Subsequent executions\n * of the handler will not fire, while the handler is paused, which also means, that paused handlers, set up to only\n * fire once, will not self-destroy while being paused.\n *\n * The definition of targets and events works exactly as in \"on\" and \"once\", the only difference being, that the handler\n * is optional in this case, which results in the pausing of all handlers, without targeting a specific one.\n *\n * To specifically target handlers without a namespace, please use the namespace-string \"__default\".\n *\n * @param {EventTarget|Array<EventTarget>} targets - the target(s) to pause event handlers on\n * @param {String|Array<String>} events - the event name(s) to pause, can be either a single name or a list of names, each name may also have a namespace, separated by a dot, to target all events/namespaces, you may use \"*\"/\"*.*\"\n * @param {?Function} [handler=null] - a specific callback function to pause\n * @param {?Boolean} [paused=true] - defines if the matched handlers are being paused or resumed\n * @throws error in case no targets are defined\n * @throws error in case no events are defined\n * @throws error in case no handler is not a function\n * @throws error in case targets are not all usable event targets\n * @throws error in case delegations are missing viable ancestor targets\n * @returns {Number} the number of handlers actually paused by the function call, may also be 0 if nothing matched\n *\n * @memberof Events:pause\n * @alias pause\n * @see on\n * @see resume\n * @example\n * pause(buttonElement, 'click');\n * pause(linkElement, '*.__default');\n * pause(customEventElement, 'crash');\n * pause([ancestorElement, 'a'], 'click');\n * pause([ancestorElement, '.btn[data-foobar=\"test\"]'], '*.delegated', fSpecificHandler);\n */\nexport function pause(targets, events, handler=null, paused=true){\n\tconst __methodName__ = pause.name;\n\n\t({targets, events, handler} = prepareEventMethodBaseParams(__methodName__, targets, events, handler, true));\n\n\tlet pausedCount = 0;\n\n\ttargets.forEach((target, targetIndex) => {\n\t\tconst {\n\t\t\tprevTarget,\n\t\t\thasDelegation,\n\t\t\tisDelegation\n\t\t} = prepareEventMethodAdditionalTargetInfo(__methodName__, targets, targetIndex);\n\n\t\tif( !hasDelegation ){\n\t\t\tconst targetEvents = isDelegation ? EVENT_MAP.get(prevTarget) : EVENT_MAP.get(target);\n\n\t\t\tif( hasValue(targetEvents) ){\n\t\t\t\tevents.forEach(eventName => {\n\t\t\t\t\tconst {event, namespace} = prepareEventMethodEventInfo(eventName);\n\n\t\t\t\t\tif( isDelegation ){\n\t\t\t\t\t\tpausedCount += pauseDelegatedHandlers(prevTarget, target, namespace, event, handler, paused);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpausedCount += pauseHandlers(target, namespace, event, handler, null, paused);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t});\n\n\treturn pausedCount;\n}\n\n\n\n/**\n * @namespace Events:resume\n */\n\n/**\n * Resumes (a), previously paused, event listener(s). Subsequent executions of the handler will fire again.\n *\n * The definition of targets and events works exactly as in \"on\" and \"once\", the only difference being, that the handler\n * is optional in this case, which results in the un-pausing of all handlers, without targeting a specific one.\n *\n * To specifically target handlers without a namespace, please use the namespace-string \"__default\".\n *\n * @param {EventTarget|Array<EventTarget>} targets - the target(s) to resume event handlers on\n * @param {String|Array<String>} events - the event name(s) to resume, can be either a single name or a list of names, each name may also have a namespace, separated by a dot, to target all events/namespaces, you may use \"*\"/\"*.*\"\n * @param {?Function} [handler=null] - a specific callback function to resume\n * @throws error in case no targets are defined\n * @throws error in case no events are defined\n * @throws error in case no handler is not a function\n * @throws error in case targets are not all usable event targets\n * @throws error in case delegations are missing viable ancestor targets\n * @returns {Number} the number of handlers actually resumed by the function call, may also be 0 if nothing matched\n *\n * @memberof Events:resume\n * @alias resume\n * @see on\n * @see pause\n * @example\n * resume(linkElement, '*', fSpecificHandler);\n * resume(customEventElement, ['*.test', '*.site']);\n * resume([ancestorElement, 'a', ancestorElement, '.btn[data-foobar=\"test\"]'], '*.*', fSpecificHandler);\n * resume(buttonElement, '*.*');\n */\nexport function resume(targets, events, handler=null){\n\treturn pause(targets, events, handler, false);\n}\n\n\n\n/**\n * @namespace Events:fire\n */\n\n/**\n * Fires event handlers of all matched targets for given events.\n *\n * This function does not actually dispatch events, but identifies matches in the internal event map, based on\n * previously registered handlers using \"on\" and \"once\" and executes the attached handlers, providing them a synthetic\n * CustomEvent as first parameter, carrying the event name as well as a potential payload. So this, function is\n * using the event map as an event bus, instead of the DOM, so these events also will never bubble, but just hit the\n * currently present handlers identified exactly by the provided parameters.\n *\n * The definition of targets and events works exactly as in \"on\" and \"once\", the only difference being, that we have no\n * handler, since if we'd have the handler already, we could just call it.\n *\n * Since we do not use the DOM in this function, we also do not have native events, and therefore we do not have normal\n * event targets we can work with. Instead, this implementation adds the \"syntheticTarget\" and the\n * \"syntheticTargetElements\" event properties to the event that is given to the handler. \"syntheticTarget\" contains\n * the defined event map target, either as a EventTarget or an array of an EventTarget and a corresponding delegation\n * selector (just as you defined them before), while \"syntheticTargetElements\" returns the actual elements as an\n * iterable array. So, in case of a delegation, this gives you the power to actually work with the current delegation\n * targets, without having to write own logic for this.\n *\n * @param {EventTarget|Array<EventTarget>} targets - the target(s) to execute event handlers on\n * @param {String|Array<String>} events - the event name(s) to fire, can be either a single name or a list of names, each name may also have a namespace, separated by a dot, to target all events/namespaces, you may use \"*\"/\"*.*\"\n * @param {?Object} [payload=null] - a plain object payload to relay to the event handlers via the detail of the CustomEvent given to the handler as first parameter\n * @throws error in case no targets are defined\n * @throws error in case no events are defined\n * @throws error in case targets are not all usable event targets\n * @throws error in case delegations are missing viable ancestor targets\n * @returns {Number} the number of handlers actually executed by the function call, may also be 0 if nothing matched\n *\n * @memberof Events:fire\n * @alias fire\n * @see on\n * @see once\n * @see emit\n * @example\n * fire(buttonElement, 'click');\n * fire(linkElement, '*.__default', {importantFlag : true});\n * fire(divElement, 'crash');\n * fire([ancestorElement, 'a'], 'click', {linkWasClicked : true});\n * fire([ancestorElement, '.btn[data-foobar=\"test\"]'], '*.delegated');\n * fire(linkElement, '*');\n * fire([ancestorElement, 'a', ancestorElement, '.btn[data-foobar=\"test\"]'], '*.*');\n * fire(buttonElement, 'click.*', {price : 666});\n */\nexport function fire(targets, events, payload=null){\n\tconst __methodName__ = fire.name;\n\n\t({targets, events} = prepareEventMethodBaseParams(__methodName__, targets, events, null, true));\n\n\tlet fireCount = 0;\n\n\ttargets.forEach((target, targetIndex) => {\n\t\tconst {\n\t\t\tprevTarget,\n\t\t\thasDelegation,\n\t\t\tisDelegation\n\t\t} = prepareEventMethodAdditionalTargetInfo(__methodName__, targets, targetIndex);\n\n\t\tif( !hasDelegation ){\n\t\t\tconst targetEvents = isDelegation ? EVENT_MAP.get(prevTarget) : EVENT_MAP.get(target);\n\n\t\t\tif( hasValue(targetEvents) ){\n\t\t\t\tevents.forEach(eventName => {\n\t\t\t\t\tconst {event, namespace} = prepareEventMethodEventInfo(eventName);\n\n\t\t\t\t\tlet gatheredTargetEvents;\n\t\t\t\t\tif( isDelegation ){\n\t\t\t\t\t\tgatheredTargetEvents = gatherTargetEvents(prevTarget, namespace, event, target);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgatheredTargetEvents = gatherTargetEvents(target, namespace, event);\n\t\t\t\t\t}\n\n\t\t\t\t\tObject.keys(gatheredTargetEvents).forEach(ns => {\n\t\t\t\t\t\tArray.from(gatheredTargetEvents[ns]).forEach(ev => {\n\t\t\t\t\t\t\tconst\n\t\t\t\t\t\t\t\thandlerScope = isDelegation\n\t\t\t\t\t\t\t\t\t? targetEvents[ns][ev].delegations[target]\n\t\t\t\t\t\t\t\t\t: targetEvents[ns][ev]\n\t\t\t\t\t\t\t\t,\n\t\t\t\t\t\t\t\tsyntheticEvent = isDelegation\n\t\t\t\t\t\t\t\t\t? createSyntheticEvent(ev, ns, payload, false, false, [prevTarget, target])\n\t\t\t\t\t\t\t\t\t: createSyntheticEvent(ev, ns, payload, false, false, target)\n\t\t\t\t\t\t\t;\n\n\t\t\t\t\t\t\thandlerScope.handlers.forEach(handler => {\n\t\t\t\t\t\t\t\thandler.action(syntheticEvent);\n\t\t\t\t\t\t\t\tfireCount++;\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t});\n\n\treturn fireCount;\n}\n\n\n\n/**\n * @namespace Events:emit\n */\n\n/**\n * Dispatches synthetic events on all given targets.\n *\n * In contrast to \"fire\", this function actually dispatches bubbling events on the provided EventTargets. Delegations\n * are resolved using \"querySelectorAll\". This function does not check actual handler presence using the event map, but\n * blindly emits what has been given, purely using the DOM as the event bus. Handlers defined with \"on\" and \"once\" will\n * of course still be triggered if hit, since they always also register a native event listener. The events emitted\n * are purely synthetic basic Events and CustomEvents, lacking special properties, which, for example, MouseEvents\n * provide. So, using \"screenX\" in the handler will not work. If you need a certain base class for the created events,\n * use the \"EventConstructor\" to provide the base class and add special options via \"eventOptions\".\n *\n * The definition of targets and events works almost as in \"on\" and \"once\", the only differences being, that we have no\n * handler, and we cannot leave out the event name. Using a wildcard for the namespace will leave out the namespace in\n * the created events.\n *\n * @param {EventTarget|Array<EventTarget>} targets - the target(s) to dispatch events on\n * @param {String|Array<String>} events - the event name(s) to emit, can be either a single name or a list of names, each name may also have a namespace, separated by a dot, to target all events/namespaces, you may use \"*\"/\"*.*\"\n * @param {?Object} [payload=null] - a plain object payload to relay to the event handlers via the detail of the CustomEvent given to the handler as first parameter\n * @param {?Function} [EventConstructor=null] - the default constructor is Event/CustomEvent, if you need another specific synthetic event, provide a constructor such as MouseEvent here\n * @param {?Object} [eventOptions=null] - use this plain object to provide constructor specific options to use in event construction, this should especially come in handy in case you provide a custom EventConstructor\n * @throws error in case no targets are defined\n * @throws error in case no events are defined\n * @throws error in case targets are not all usable event targets\n * @throws error in case delegations are missing viable ancestor targets\n * @returns {Number} the number of events actually dispatched by the function call, may also be 0 if nothing matched\n *\n * @memberof Events:emit\n * @alias emit\n * @see on\n * @see once\n * @see fire\n * @example\n * emit([buttonElement, ancestorElement, 'a'], 'click');\n * emit(linkElement, 'click.__default', {defaultClick: true});\n * emit([divElement, document.body], 'crash');\n * emit([ancestorElement, 'a'], 'click', {trackingId : 'abc123'});\n * emit([ancestorElement, '.btn[data-foobar=\"test\"]'], 'click.delegated');\n * emit(ancestorElement, ['crash.test', 'crash.site'], {damage : 1000});\n * emit([ancestorElement, 'a', ancestorElement, '.btn[data-foobar=\"test\"]'], 'click.delegated', null, null, {bubbles : false});\n * emit(buttonElement, 'click.*', {price : 666}, MouseEvent, {bubbles : false});\n */\nexport function emit(targets, events, payload=null, EventConstructor=null, eventOptions=null){\n\tconst __methodName__ = emit.name;\n\n\t({targets, events} = prepareEventMethodBaseParams(__methodName__, targets, events, null, true));\n\n\tlet emitCount = 0;\n\n\ttargets.forEach((target, targetIndex) => {\n\t\tconst {\n\t\t\tprevTarget,\n\t\t\thasDelegation,\n\t\t\tisDelegation\n\t\t} = prepareEventMethodAdditionalTargetInfo(__methodName__, targets, targetIndex);\n\n\t\tif( !hasDelegation ){\n\t\t\tevents.forEach(eventName => {\n\t\t\t\tconst {event, namespace} = prepareEventMethodEventInfo(eventName);\n\n\t\t\t\tassert(hasValue(event), `${MODULE_NAME}:${__methodName__} | missing event name`);\n\n\t\t\t\tif( isDelegation ){\n\t\t\t\t\tArray.from(prevTarget.querySelectorAll(target)).forEach(element => {\n\t\t\t\t\t\telement.dispatchEvent(\n\t\t\t\t\t\t\tcreateSyntheticEvent(event, namespace, payload, true, true, null, EventConstructor, eventOptions)\n\t\t\t\t\t\t);\n\t\t\t\t\t\temitCount++;\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\ttarget.dispatchEvent(\n\t\t\t\t\t\tcreateSyntheticEvent(event, namespace, payload, true, true, null, EventConstructor, eventOptions)\n\t\t\t\t\t);\n\t\t\t\t\temitCount++;\n\t\t\t\t}\n\t\t\t});\n\n\t\t}\n\t});\n\n\treturn emitCount;\n}\n"]}
{"version":3,"file":"events.js","names":["MODULE_NAME","assert","isA","isEventTarget","isPlainObject","orDefault","hasValue","isEmpty","isSelector","slugify","removeFrom","isInDom","EVENT_MAP","Map","DEFAULT_NAMESPACE","EVENT_OPTION_SUPPORT","capture","once","passive","signal","options","window","addEventListener","removeEventListener","err","prepareEventMethodBaseParams","methodName","targets","events","handler","handlerIsOptional","length","targetsAreEventTargets","delegatedTargetsAreSelectorsAndHaveAncestor","forEach","target","targetIndex","ancestor","map","event","replace","replaceAll","prepareEventMethodAdditionalTargetInfo","prevTarget","nextTarget","hasDelegation","isDelegation","prepareEventMethodEventInfo","eventName","defaultNamespace","defaultEvent","eventParts","split","namespace","gatherTargetEvents","delegation","targetEvents","get","gatheredTargetEvents","nameSpaceScope","delegations","Set","add","Object","keys","ns","ev","cleanUpEventMap","concat","desertedTargets","has","targetNamespace","targetEvent","targetScope","handlerCount","handlers","delegationHandlerCount","push","desertedTarget","delete","createDelegatedHandler","e","delegationSelector","matches","syntheticTarget","createHandlerRemover","__methodName__","handlerScope","removedHandlers","filter","existingHandler","removedHandler","action","createSelfRemovingHandler","removeLocatedHandler","delegationScope","removeHandlers","removedCount","Array","from","removeDelegatedHandlers","pauseLocatedHandlers","paused","pausedHandlers","pausedHandler","pauseHandlers","pausedCount","pauseDelegatedHandlers","createPauseAwareAction","managedHandler","nonPauseAwareAction","compileEventListenerOptions","supportedOptions","option","createSyntheticEvent","payload","bubbles","cancelable","EventConstructor","eventOptions","console","warn","name","CustomEvent","detail","syntheticTargetElements","defineProperty","querySelectorAll","on","removers","set","__default","remover","eventListenerOptions","off","pause","resume","fire","fireCount","syntheticEvent","emit","emitCount","element","dispatchEvent","offDetachedElements","offCount"],"sources":["events.js"],"mappings":"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","sourcesContent":["/*!\n * Module Events\n */\n\n/**\n * @namespace Events\n */\n\nconst MODULE_NAME = 'Events';\n\n\n\n//###[ IMPORTS ]########################################################################################################\n\nimport {assert, isA, isEventTarget, isPlainObject, orDefault, hasValue, isEmpty, isSelector} from './basic.js';\nimport {slugify} from './strings.js';\nimport {removeFrom} from './arrays.js';\nimport {isInDom} from './elements.js';\n\n\n\n//###[ DATA ]###########################################################################################################\n\nexport const EVENT_MAP = new Map();\n\nconst\n\tDEFAULT_NAMESPACE = '__default',\n\tEVENT_OPTION_SUPPORT = {\n\t\tcapture : false,\n\t\tonce : false,\n\t\tpassive : false,\n\t\tsignal : false\n\t}\n;\n\ntry {\n\tconst options = {\n\t\tget capture(){\n\t\t\tEVENT_OPTION_SUPPORT.capture = true;\n\t\t\treturn false;\n\t\t},\n\t\tget once(){\n\t\t\tEVENT_OPTION_SUPPORT.once = true;\n\t\t\treturn false;\n\t\t},\n\t\tget passive(){\n\t\t\tEVENT_OPTION_SUPPORT.passive = true;\n\t\t\treturn false;\n\t\t},\n\t\tget signal(){\n\t\t\tEVENT_OPTION_SUPPORT.signal = true;\n\t\t\treturn false;\n\t\t},\n\t};\n\n\twindow.addEventListener('test', null, options);\n\twindow.removeEventListener('test', null, options);\n} catch (err){}\n\n\n\n//###[ HELPERS ]########################################################################################################\n\n/*\n * Takes the standard set of event function parameters, sanitizes the values and asserts basic compatability.\n * Returns the transformed parameters as an object, with keys of the same name as the relevant parameters.\n *\n * @private\n */\nfunction prepareEventMethodBaseParams(methodName, targets, events, handler, handlerIsOptional=false){\n\ttargets = orDefault(targets, [], 'arr');\n\tassert(targets.length > 0, `${MODULE_NAME}:${methodName} | no targets provided`);\n\tevents = orDefault(events, [], 'arr');\n\tassert(events.length > 0, `${MODULE_NAME}:${methodName} | no events provided`);\n\tif( !handlerIsOptional || hasValue(handler) ){\n\t\tassert(isA(handler, 'function'), `${MODULE_NAME}:${methodName} | handler is not a function`);\n\t}\n\n\tlet\n\t\ttargetsAreEventTargets = true,\n\t\tdelegatedTargetsAreSelectorsAndHaveAncestor = true\n\t;\n\n\ttargets.forEach((target, targetIndex) => {\n\t\tif( isA(target, 'string') ){\n\t\t\tconst ancestor = (targetIndex > 0) ? targets[targetIndex - 1] : null;\n\t\t\tdelegatedTargetsAreSelectorsAndHaveAncestor &&= isSelector(target) && isEventTarget(ancestor);\n\t\t} else {\n\t\t\ttargetsAreEventTargets &&= isEventTarget(target);\n\t\t}\n\t});\n\n\tassert(targetsAreEventTargets, `${MODULE_NAME}:${methodName} | not all targets are event targets`);\n\tassert(\n\t\tdelegatedTargetsAreSelectorsAndHaveAncestor,\n\t\t`${MODULE_NAME}:${methodName} | not all delegated targets are a selector or have an ancestor`\n\t);\n\n\tevents = events\n\t\t.map(event => event.replace(`.${DEFAULT_NAMESPACE}`, '.-default-ns'))\n\t\t.map(event => slugify(event, {\n\t\t\t'.' : '___dot___',\n\t\t\t'*' : '___star___'\n\t\t}))\n\t\t.map(event => event.replaceAll('___dot___', '.'))\n\t\t.map(event => event.replaceAll('___star___', '*'))\n\t\t.map(event => event.replace('.-default-ns', `.${DEFAULT_NAMESPACE}`))\n\t;\n\n\treturn {targets, events, handler};\n}\n\n\n\n/*\n * Prepares basic information about the current target in a list of targets.\n * The current target is identified by index, since the same target may appear multiple times in a list,\n * for example as a target and a delegation ancestor.\n *\n * @private\n */\nfunction prepareEventMethodAdditionalTargetInfo(methodName, targets, targetIndex){\n\tconst\n\t\tprevTarget =  ((targetIndex - 1) >= 0) ? targets[targetIndex - 1] : null,\n\t\tnextTarget =  (targetIndex < (targets.length - 1)) ? targets[targetIndex + 1] : null,\n\t\thasDelegation = isSelector(nextTarget),\n\t\tisDelegation = isSelector(targets[targetIndex])\n\t;\n\n\tassert(\n\t\t!isDelegation || (isDelegation && isEventTarget(prevTarget)),\n\t\t`${MODULE_NAME}:${methodName} | delegation has no ancestor`\n\t);\n\n\treturn {prevTarget, nextTarget, hasDelegation, isDelegation};\n}\n\n\n\n/*\n * Prepares basic information about the current event in a list of events.\n * The current event is identified by a complete eventName string containing the event itself,\n * as well as the complete dot-separated namespace.\n *\n * @private\n */\nfunction prepareEventMethodEventInfo(eventName, defaultNamespace=null, defaultEvent=null){\n\tconst\n\t\teventParts = eventName.replace('.', '/////').split('/////'),\n\t\tevent = (isEmpty(eventParts[0]) || (eventParts[0] === '*')) ? defaultEvent : eventParts[0],\n\t\tnamespace = (isEmpty(eventParts[1]) || (eventParts[1] === '*')) ? defaultNamespace : eventParts[1]\n\t;\n\n\treturn {event, namespace};\n}\n\n\n\n/*\n * Gathers matching events with namespaces for a given target (with or without a delegation).\n * Returns the found namespaces and events as a dictionary of namespaces with values of sets containing\n * the corresponding event names.\n *\n * @private\n */\nfunction gatherTargetEvents(target, namespace=null, event=null, delegation=null){\n\tconst __methodName__ = 'gatherTargetEvents';\n\n\tconst targetEvents = EVENT_MAP.get(target);\n\tassert(isPlainObject(targetEvents), `${MODULE_NAME}:${__methodName__} | invalid target \"${target}\"`);\n\n\tconst gatheredTargetEvents = {};\n\n\tif( !hasValue(namespace) && !hasValue(event) ){\n\t\tObject.keys(targetEvents).forEach(ns => {\n\t\t\tgatheredTargetEvents[ns] = new Set([]);\n\t\t\tObject.keys(targetEvents[ns]).forEach(ev => {\n\t\t\t\tif( !hasValue(delegation) || hasValue(targetEvents[ns][ev].delegations[delegation]) ){\n\t\t\t\t\tgatheredTargetEvents[ns].add(ev);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t} else if( !hasValue(event) ){\n\t\tconst nameSpaceScope = targetEvents[namespace];\n\t\tif( hasValue(nameSpaceScope) ){\n\t\t\tgatheredTargetEvents[namespace] = new Set([]);\n\t\t\tObject.keys(targetEvents[namespace]).forEach(ev => {\n\t\t\t\tif( !hasValue(delegation) || hasValue(nameSpaceScope[ev].delegations[delegation]) ){\n\t\t\t\t\tgatheredTargetEvents[namespace].add(ev);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t} else if( !hasValue(namespace) ){\n\t\tObject.keys(targetEvents).forEach(ns => {\n\t\t\tconst nameSpaceScope = targetEvents[ns];\n\t\t\tif(\n\t\t\t\thasValue(nameSpaceScope[event])\n\t\t\t\t&& (!hasValue(delegation) || hasValue(nameSpaceScope[event].delegations[delegation]))\n\t\t\t){\n\t\t\t\tif( !hasValue(gatheredTargetEvents[ns]) ){\n\t\t\t\t\tgatheredTargetEvents[ns] = new Set([]);\n\t\t\t\t}\n\t\t\t\tgatheredTargetEvents[ns].add(event);\n\t\t\t}\n\t\t});\n\t} else {\n\t\tconst nameSpaceScope = targetEvents[namespace];\n\t\tif(\n\t\t\thasValue(nameSpaceScope)\n\t\t\t&& hasValue(nameSpaceScope[event])\n\t\t\t&& (!hasValue(delegation) || hasValue(nameSpaceScope[event].delegations[delegation]))\n\t\t){\n\t\t\tif( !hasValue(gatheredTargetEvents[namespace]) ){\n\t\t\t\tgatheredTargetEvents[namespace] = new Set([]);\n\t\t\t}\n\t\t\tgatheredTargetEvents[namespace].add(event);\n\t\t}\n\t}\n\n\treturn gatheredTargetEvents;\n}\n\n\n\n/*\n * Iterates through the event map (starting with a specific target or using all targets) and searches for\n * deserted handler definitions. Deletes definitions that do not contain any handlers anymore and recursively\n * removes the path back to the starting point(s) if it turns out to be empty afterwards.\n *\n * @private\n */\nfunction cleanUpEventMap(targets){\n\ttargets = hasValue(targets) ? new Set([].concat(targets)) : null;\n\n\tconst desertedTargets = [];\n\n\tEVENT_MAP.forEach((targetEvents, target) => {\n\t\tif( !hasValue(targets) || targets.has(target) ){\n\t\t\tObject.keys(targetEvents).forEach(targetNamespace => {\n\t\t\t\tObject.keys(targetEvents[targetNamespace]).forEach(targetEvent => {\n\t\t\t\t\tconst targetScope = targetEvents[targetNamespace][targetEvent];\n\t\t\t\t\tlet handlerCount = targetScope.handlers.length;\n\n\t\t\t\t\tObject.keys(targetScope.delegations).forEach(delegation => {\n\t\t\t\t\t\tconst delegationHandlerCount = targetScope.delegations[delegation].handlers.length;\n\t\t\t\t\t\thandlerCount += delegationHandlerCount;\n\n\t\t\t\t\t\tif( delegationHandlerCount === 0 ){\n\t\t\t\t\t\t\tdelete targetScope.delegations[delegation];\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\tif( handlerCount === 0){\n\t\t\t\t\t\tdelete targetEvents[targetNamespace][targetEvent];\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tif( Object.keys(targetEvents[targetNamespace]).length === 0 ){\n\t\t\t\t\tdelete targetEvents[targetNamespace];\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif( Object.keys(targetEvents).length === 0 ){\n\t\t\t\tdesertedTargets.push(target);\n\t\t\t}\n\t\t}\n\t});\n\n\tdesertedTargets.forEach(desertedTarget => {\n\t\tEVENT_MAP.delete(desertedTarget);\n\t});\n}\n\n\n\n/*\n * Takes a handler function and returns a new function wrapping the handler, making sure, that the handler only\n * executes, if the event target matches the given delegation selector. So, the returned function automatically\n * checks if the delegation is actually met.\n *\n * @private\n */\nfunction createDelegatedHandler(delegation, handler){\n\treturn function delegatedHandler(e){\n\t\tconst\n\t\t\tdelegationSelector = `${delegation}`,\n\t\t\tdelegationFulfilled = hasValue(e.target?.matches)\n\t\t\t\t? e.target.matches(delegationSelector)\n\t\t\t\t: (\n\t\t\t\t\tisEventTarget(e.syntheticTarget)\n\t\t\t\t\t|| (\n\t\t\t\t\t\tisA(e.syntheticTarget, 'array')\n\t\t\t\t\t\t&& isSelector(e.syntheticTarget[1])\n\t\t\t\t\t)\n\t\t\t\t\t? (\n\t\t\t\t\t\tisEventTarget(e.syntheticTarget)\n\t\t\t\t\t\t? e.syntheticTarget.matches(delegationSelector)\n\t\t\t\t\t\t: (e.syntheticTarget[1] === delegationSelector))\n\t\t\t\t\t: null\n\t\t\t\t)\n\t\t;\n\n\t\tif( delegationFulfilled ){\n\t\t\thandler(e);\n\t\t}\n\t};\n}\n\n\n\n/*\n * Takes a handler function and returns a new function, which, when executed, removes the handler from the exact\n * path in the EVENT_MAP, defined by the given target, namespace and event (and, optionally, a delegation selector).\n * Using this function, one can undo the setting of a handler, using \"on\" or \"once\".\n *\n * @private\n */\nfunction createHandlerRemover(target, namespace, event, handler, delegation=null){\n\tconst\n\t\t__methodName__ = 'createHandlerRemover',\n\t\ttargetEvents = EVENT_MAP.get(target)\n\t;\n\tlet handlerScope = targetEvents?.[namespace]?.[event];\n\n\tif( hasValue(delegation) ){\n\t\tassert(isSelector(delegation), `${MODULE_NAME}:${__methodName__} | invalid delegation \"${delegation}\"`);\n\t\thandlerScope = handlerScope.delegations[`${delegation}`];\n\t}\n\n\tassert(isPlainObject(handlerScope), `${MODULE_NAME}:${__methodName__} | invalid handlerScope`);\n\n\treturn function handlerRemover(){\n\t\tconst removedHandlers = handlerScope.handlers.filter(existingHandler => existingHandler.handler === handler);\n\t\thandlerScope.handlers = removeFrom(handlerScope.handlers, removedHandlers);\n\n\t\tremovedHandlers.forEach(removedHandler => {\n\t\t\ttarget.removeEventListener(event, removedHandler.action);\n\t\t});\n\n\t\tcleanUpEventMap(target);\n\t};\n}\n\n\n\n/*\n * Takes a handler function and returns a new function, which, when executed, calls the handler and, afterwards,\n * automatically removes the handler from the path in the EVENT_MAP, defined by the given target, namespace and event\n * (and, optionally, a delegation selector). So, the returned function is essentially a self-destructing handler.\n *\n * @private\n */\nfunction createSelfRemovingHandler(target, namespace, event, handler, delegation=null){\n\treturn function selfRemovingHandler(e){\n\t\thandler(e);\n\t\tcreateHandlerRemover(target, namespace, event, handler, delegation)();\n\t};\n}\n\n\n\n/*\n * Removes (a) handler(s) from a path in the EVENT_MAP, defined by the given target, namespace, event and handler\n * (and, optionally, a delegation selector).\n *\n * @private\n */\nfunction removeLocatedHandler(target, namespace, event, handler, delegation=null){\n\tconst\n\t\t__methodName__ = 'removeLocatedHandler',\n\t\ttargetEvents = EVENT_MAP.get(target),\n\t\ttargetScope = targetEvents?.[namespace]?.[event]\n\t;\n\n\tassert(isPlainObject(targetScope), `${MODULE_NAME}:${__methodName__} | invalid targetScope`);\n\n\tlet handlerScope;\n\tif( hasValue(delegation) ){\n\t\tconst delegationScope = targetScope.delegations[`${delegation}`];\n\t\tassert(isPlainObject(delegationScope), `${MODULE_NAME}:${__methodName__} | invalid delegation \"${delegation}\"`);\n\t\thandlerScope = delegationScope;\n\t} else {\n\t\thandlerScope = targetScope;\n\t}\n\tconst removedHandlers = handlerScope.handlers.filter(existingHandler => {\n\t\treturn hasValue(handler)\n\t\t\t? (handler === existingHandler.handler)\n\t\t\t: true\n\t\t;\n\t});\n\n\thandlerScope.handlers = removeFrom(handlerScope.handlers, removedHandlers);\n\n\tremovedHandlers.forEach(removedHandler => {\n\t\ttarget.removeEventListener(event, removedHandler.action);\n\t});\n\n\treturn removedHandlers.length;\n}\n\n\n\n/*\n * Removes all handlers matching the given definition provided by target, namespace, event and handler\n * (and, optionally, a delegation selector). Leaving out namespace, event or handler works as a wildcard.\n *\n * @private\n */\nfunction removeHandlers(target, namespace=null, event=null, handler=null, delegation=null){\n\tconst targetEvents = gatherTargetEvents(target, namespace, event, delegation);\n\n\tlet removedCount = 0;\n\n\tObject.keys(targetEvents).forEach(ns => {\n\t\tArray.from(targetEvents[ns]).forEach(ev => {\n\t\t\tremovedCount += removeLocatedHandler(target, ns, ev, handler, delegation);\n\t\t});\n\t});\n\n\treturn removedCount;\n}\n\n\n\n/*\n * Shorthand-function for \"removeHandlers\" with more sane parameter order for delegations.\n *\n * @private\n */\nfunction removeDelegatedHandlers(ancestor, delegation, namespace=null, event=null, handler=null){\n\treturn removeHandlers(ancestor, namespace, event, handler, delegation);\n}\n\n\n\n/*\n * Pauses (a) handler(s) from a path in the EVENT_MAP, defined by the given target, namespace, event and handler\n * (and, optionally, a delegation selector). If paused is false, the function instead resumes the handlers.\n *\n * @private\n */\nfunction pauseLocatedHandlers(target, namespace, event, handler, delegation=null, paused=true){\n\tconst\n\t\t__methodName__ = 'pauseLocatedHandlers',\n\t\ttargetEvents = EVENT_MAP.get(target),\n\t\ttargetScope = targetEvents?.[namespace]?.[event]\n\t;\n\n\tassert(isPlainObject(targetScope), `${MODULE_NAME}:${__methodName__} | invalid targetScope`);\n\n\tlet handlerScope;\n\tif( hasValue(delegation) ){\n\t\tconst delegationScope = targetScope.delegations[`${delegation}`];\n\t\tassert(isPlainObject(delegationScope), `${MODULE_NAME}:${__methodName__} | invalid delegation \"${delegation}\"`);\n\t\thandlerScope = delegationScope;\n\t} else {\n\t\thandlerScope = targetScope;\n\t}\n\n\tconst pausedHandlers = handlerScope.handlers.filter(existingHandler => {\n\t\treturn hasValue(handler)\n\t\t\t? (handler === existingHandler.handler)\n\t\t\t: true\n\t\t;\n\t});\n\n\tpausedHandlers.forEach(pausedHandler => {\n\t\tpausedHandler.paused = !!paused;\n\t});\n\n\treturn pausedHandlers.length;\n}\n\n\n\n/*\n * Pauses all handlers matching the given definition provided by target, namespace, event and handler\n * (and, optionally, a delegation selector). Leaving out namespace, event or handler works as a wildcard.\n * If paused is false, the function instead resumes the handlers.\n *\n * @private\n */\nfunction pauseHandlers(target, namespace=null, event=null, handler=null, delegation=null, paused=true){\n\tconst targetEvents = gatherTargetEvents(target, namespace, event, delegation);\n\n\tlet pausedCount = 0;\n\n\tObject.keys(targetEvents).forEach(ns => {\n\t\tArray.from(targetEvents[ns]).forEach(ev => {\n\t\t\tpausedCount += pauseLocatedHandlers(target, ns, ev, handler, delegation, paused);\n\t\t});\n\t});\n\n\treturn pausedCount;\n}\n\n\n\n/*\n * Shorthand-function for \"pauseHandlers\" with more sane parameter order for delegations.\n *\n * @private\n */\nfunction pauseDelegatedHandlers(ancestor, delegation, namespace=null, event=null, handler=null, paused=true){\n\treturn pauseHandlers(ancestor, namespace, event, handler, delegation, paused);\n}\n\n\n\n/*\n * Takes a handler object and a corresponding action, which is not yet aware of its pause state and\n * returns an action function, which checks if the handler is paused, before executing the original action.\n * Using this, we can wrap handler actions to automatically react to the handler's pause state, preventing any\n * handler execution if the handler is currently paused.\n *\n * @private\n */\nfunction createPauseAwareAction(managedHandler, nonPauseAwareAction){\n\treturn function pauseAwareHandler(e){\n\t\tif( !managedHandler.paused ){\n\t\t\tnonPauseAwareAction(e);\n\t\t}\n\t};\n}\n\n\n\n/*\n * Takes an event listener options object as provided by the user, to be used as the third parameter of\n * addEventListener, and returns a sanitized version, taking into regard what options the browser actually supports\n * and falling back to boolean capture values, if the browser does not know about listener options at all.\n *\n * @private\n */\nfunction compileEventListenerOptions(options){\n\tif( isA(options, 'boolean') ) return options;\n\tif( !isA(options, 'object') ) return null;\n\n\tconst supportedOptions = {};\n\n\tObject.keys(EVENT_OPTION_SUPPORT).forEach(option => {\n\t\tif( !!EVENT_OPTION_SUPPORT[option] && hasValue(options[option]) ){\n\t\t\tsupportedOptions[option] = options[option];\n\t\t}\n\t});\n\n\tif( (Object.keys(supportedOptions).length === 0) && !!options.capture ){\n\t\treturn true;\n\t}\n\n\treturn supportedOptions;\n}\n\n\n\n/*\n * Creates a synthetic event to dispatch on an event target.\n *\n * @private\n */\nfunction createSyntheticEvent(\n\tevent,\n\tnamespace=null,\n\tpayload=null,\n\tbubbles=null,\n\tcancelable=null,\n\tsyntheticTarget=null,\n\tEventConstructor=null,\n\teventOptions=null\n){\n\tconst __methodName__ = 'createSyntheticEvent';\n\n\tevent = `${event}`;\n\tbubbles = orDefault(bubbles, false, 'bool');\n\tcancelable = orDefault(cancelable, bubbles, 'bool');\n\teventOptions = isPlainObject(eventOptions) ? eventOptions : {};\n\n\tlet e;\n\tif( isA(EventConstructor, 'function') ){\n\t\tif( isPlainObject(payload) ){\n\t\t\tconsole.warn(`${MODULE_NAME}:${__methodName__} | can't add payload to event \"${EventConstructor.name}\", skipping`);\n\t\t}\n\t\te = new EventConstructor(event, {bubbles, cancelable, ...eventOptions});\n\t} else {\n\t\te = isPlainObject(payload)\n\t\t\t? new CustomEvent(event, {detail : payload, bubbles, cancelable, ...eventOptions})\n\t\t\t// we could use new Event() here, but jsdom and ava cannot use that constructor for dispatchEvent :(\n\t\t\t: new CustomEvent(event, {bubbles, cancelable, ...eventOptions})\n\t\t;\n\t}\n\n\tif( hasValue(namespace) ){\n\t\te.namespace = `${namespace}`;\n\t}\n\n\tif( isEventTarget(syntheticTarget) ){\n\t\te.syntheticTarget = syntheticTarget;\n\t\te.syntheticTargetElements = [syntheticTarget]\n\t} else if(\n\t\tisA(syntheticTarget, 'array')\n\t\t&& isEventTarget(syntheticTarget[0])\n\t\t&& isSelector(syntheticTarget[1])\n\t){\n\t\te.syntheticTarget = syntheticTarget;\n\t\tObject.defineProperty(e, 'syntheticTargetElements', {\n\t\t\tget(){\n\t\t\t\treturn Array.from(syntheticTarget[0].querySelectorAll(`${syntheticTarget[1]}`));\n\t\t\t}\n\t\t});\n\t}\n\n\treturn e;\n}\n\n\n\n//###[ EXPORTS ]########################################################################################################\n\n/**\n * @namespace Events:on\n */\n\n/**\n * Registers (an) event listener(s) to (a) valid EventTarget(s) (most likely (a) DOM-element(s)).\n *\n * This method is inspired by jQuery and cash, though not identical.\n * You may define one or more targets as well as one or more events to register a handler to, by either providing single\n * arguments or arrays. You may also, additionally, namespace events, like in jQuery/cash, by adding it after the event\n * name, separated by a dot ('click.namespace').\n *\n * This method returns a remover function, which removes all event registrations done by this method call.\n * So, in essence, calling that function, removes exactly, what was added, in a single call.\n *\n * @param {EventTarget|Array<EventTarget>} targets - the target(s) to register event handlers on\n * @param {String|Array<String>} events - the event name(s) to listen to, can be either a single name or a list of names, each name may also have a namespace, separated by a dot, to target all events/namespaces, you may use \"*\"/\"*.*\"\n * @param {Function} handler - the callback to execute if the event(s) defined in events are being received on target\n * @param {?Object|Boolean} [options=null] - event listener options according to \"addEventListener\"-syntax, will be ignored, if browser does not support this, if boolean, will be used as \"useCapture\", the same will happen if options are not supported, but you defined \"{capture : true}\", \"{once : true}\" will not be applied directly to the listener, but will, instead, set the \"once\"-parameter to true (otherwise delegated listeners would self-destroy immediately on any check)\n * @param {?Boolean} [once=false] - defines if the handler should only execute once, after which it self-destroys automatically, this will automatically be enabled, if you set options.once to true\n * @throws error in case no targets are defined\n * @throws error in case no events are defined\n * @throws error in case no handler is not a function\n * @throws error in case targets are not all usable event targets\n * @throws error in case delegations are missing viable ancestor targets\n * @returns {Function} remover function, which removes all handlers again, added by the current execution\n *\n * @memberof Events:on\n * @alias on\n * @see off\n * @see once\n * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget\n * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener?retiredLocale=de#syntax\n * @example\n * on(linkElement, 'click', e => {\te.stopPropagation(); });\n * on(someElementWithCustomEvents, 'crash.test', () => { alert('crashed!'); });\n * on([ancestorElement, 'a'], 'click', e => { e.target.classList.add('clicked'); });\n * on(buttonElement, 'click', () => { console.log('click twice, but I'll just print once); }, {passive : true, once : true});\n * on([ancestorElement, '.btn[data-foobar=\"test\"]'], 'click', () => { console.log('I'll just fire once); }, null, true);\n * on(document.body, 'click', e => { console.log(`oh, a bubbled event, let's see what has been clicked: \"${e.target}\"`); });\n * on([foo, foo, 'button', bar], ['mousedown', 'touchstart'], e => { e.target.classList.add('interaction-start'); });\n */\nexport function on(targets, events, handler, options=null, once=false){\n\tconst __methodName__ = 'on';\n\n\t({targets, events, handler} = prepareEventMethodBaseParams(__methodName__, targets, events, handler));\n\tonce = !!once || !!options?.once;\n\tdelete options?.once;\n\n\tconst removers = [];\n\n\ttargets.forEach((target, targetIndex) => {\n\t\tconst {\n\t\t\tprevTarget,\n\t\t\thasDelegation,\n\t\t\tisDelegation\n\t\t} = prepareEventMethodAdditionalTargetInfo(__methodName__, targets, targetIndex);\n\n\t\tlet targetEvents = EVENT_MAP.get(target);\n\t\tif( isDelegation ){\n\t\t\ttargetEvents = EVENT_MAP.get(prevTarget);\n\t\t} else if( !hasValue(targetEvents) ){\n\t\t\tEVENT_MAP.set(target, {[DEFAULT_NAMESPACE] : {}});\n\t\t\ttargetEvents = EVENT_MAP.get(target);\n\t\t}\n\n\t\tif( !hasDelegation ){\n\t\t\tevents.forEach(eventName => {\n\t\t\t\tconst {event, namespace} = prepareEventMethodEventInfo(eventName, DEFAULT_NAMESPACE);\n\n\t\t\t\tif( !hasValue(targetEvents[namespace]) ){\n\t\t\t\t\ttargetEvents[namespace] = {};\n\t\t\t\t}\n\n\t\t\t\tif( !hasValue(targetEvents[namespace][event]) ){\n\t\t\t\t\ttargetEvents[namespace][event] = {\n\t\t\t\t\t\ttarget : isDelegation ? prevTarget : target,\n\t\t\t\t\t\thandlers : [],\n\t\t\t\t\t\tdelegations : {}\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tconst targetScope = targetEvents[namespace][event];\n\t\t\t\tlet handlerScope, action, remover;\n\n\t\t\t\tif( isDelegation ){\n\t\t\t\t\tif( !hasValue(targetScope.delegations[target]) ){\n\t\t\t\t\t\ttargetScope.delegations[target] = {handlers : []};\n\t\t\t\t\t}\n\t\t\t\t\thandlerScope = targetScope.delegations[target];\n\n\t\t\t\t\taction = !!once\n\t\t\t\t\t\t? createDelegatedHandler(\n\t\t\t\t\t\t\ttarget,\n\t\t\t\t\t\t\tcreateSelfRemovingHandler(targetScope.target, namespace, event, handler, target)\n\t\t\t\t\t\t)\n\t\t\t\t\t\t: createDelegatedHandler(target, handler)\n\t\t\t\t\t;\n\t\t\t\t\tremover = createHandlerRemover(targetScope.target, namespace, event, handler, target);\n\t\t\t\t} else {\n\t\t\t\t\thandlerScope = targetScope;\n\t\t\t\t\taction = !!once\n\t\t\t\t\t\t? createSelfRemovingHandler(targetScope.target, namespace, event, handler)\n\t\t\t\t\t\t: handler\n\t\t\t\t\t;\n\t\t\t\t\tremover = createHandlerRemover(targetScope.target, namespace, event, handler);\n\t\t\t\t}\n\n\t\t\t\tconst managedHandler = {\n\t\t\t\t\thandler,\n\t\t\t\t\tremover,\n\t\t\t\t\tpaused : false,\n\t\t\t\t};\n\t\t\t\tmanagedHandler.action = createPauseAwareAction(managedHandler, action);\n\t\t\t\thandlerScope.handlers = handlerScope.handlers.concat(managedHandler);\n\n\t\t\t\tconst eventListenerOptions = compileEventListenerOptions(options);\n\t\t\t\tif( hasValue(eventListenerOptions) ){\n\t\t\t\t\ttargetScope.target.addEventListener(event, managedHandler.action, eventListenerOptions);\n\t\t\t\t} else {\n\t\t\t\t\ttargetScope.target.addEventListener(event, managedHandler.action);\n\t\t\t\t}\n\n\t\t\t\tremovers.push(remover);\n\t\t\t});\n\t\t}\n\t});\n\n\treturn (removers.length > 1)\n\t\t? function(){\n\t\t\tremovers.forEach(remover => remover());\n\t\t}\n\t\t: (\n\t\t\t(removers.length > 0)\n\t\t\t? removers[0]\n\t\t\t: null\n\t\t)\n\t;\n}\n\n\n\n/**\n * @namespace Events:once\n */\n\n/**\n * Registers (an) event listener(s) to (a) valid EventTarget(s) (most likely (a) DOM-element(s)).\n *\n * This version automatically removes the handler, after it has fired once.\n *\n * This method is inspired by jQuery and cash, though not identical.\n * You may define one or more targets as well as one or more events to register a handler to, by either providing single\n * arguments or arrays. You may also, additionally, namespace events, like in jQuery/cash, by adding it after the event\n * name, separated by a dot ('click.namespace').\n *\n * This method returns a remover function, which removes all event registrations done by this method call.\n * So, in essence, calling that function, removes exactly, what was added, in a single call.\n *\n * @param {EventTarget|Array<EventTarget>} targets - the target(s) to register event handlers on\n * @param {String|Array<String>} events - the event name(s) to listen to, can be either a single name or a list of names, each name may also have a namespace, separated by a dot, to target all events/namespaces, you may use \"*\"/\"*.*\"\n * @param {Function} handler - the callback to execute if the event(s) defined in events are being received on target\n * @param {?Object|Boolean} [options=null] - event listener options according to \"addEventListener\"-syntax, will be ignored, if browser does not support this, if boolean, will be used as \"useCapture\", the same will happen if options are not supported, but you defined \"{capture : true}\", \"{once : true}\" makes no sense in this case, because the behaviour will automatically be applied anyway\n * @throws error in case no targets are defined\n * @throws error in case no events are defined\n * @throws error in case no handler is not a function\n * @throws error in case targets are not all usable event targets\n * @throws error in case delegations are missing viable ancestor targets\n * @returns {Function} remover function, which removes all handlers again, added by the current execution\n *\n * @memberof Events:once\n * @alias once\n * @see on\n * @see off\n * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget\n * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener?retiredLocale=de#syntax\n * @example\n * once(linkElement, 'click', e => {\te.stopPropagation(); });\n * once(someElementWithCustomEvents, 'crash.test', () => { alert('crashed!'); });\n * once([ancestorElement, 'a'], 'click', e => { e.target.classList.add('clicked'); });\n * once(buttonElement, 'click', () => { console.log('click twice, but I'll just print once); }, {passive : true});\n * once([ancestorElement, '.btn[data-foobar=\"test\"]'], 'click', () => { console.log('I'll just fire once); });\n * once(document.body, 'click', e => { console.log(`oh, a bubbled event, let's see what has been clicked: \"${e.target}\"`); });\n * once([foo, foo, 'button', bar], ['mousedown', 'touchstart'], e => { e.target.classList.add('interaction-start'); });\n */\nexport function once(targets, events, handler, options=null){\n\treturn on(targets, events, handler, options, true);\n}\n\n\n\n/**\n * @namespace Events:off\n */\n\n/**\n * Removes (a), previously defined, event listener(s) on (a) valid EventTarget(s) (most likely (a) DOM-element(s)).\n *\n * The definition of targets and events works exactly as in \"on\" and \"once\", the only difference being, that the handler\n * is optional in this case, which results in the removal of all handlers, without targeting a specific one.\n *\n * To specifically target handlers without a namespace, please use the namespace-string \"__default\".\n *\n * @param {EventTarget|Array<EventTarget>} targets - the target(s) to remove event handlers from\n * @param {String|Array<String>} events - the event name(s) to remove, can be either a single name or a list of names, each name may also have a namespace, separated by a dot, to target all events/namespaces, you may use \"*\"/\"*.*\"\n * @param {?Function} [handler=null] - a specific callback function to remove\n * @throws error in case no targets are defined\n * @throws error in case no events are defined\n * @throws error in case no handler is not a function\n * @throws error in case targets are not all usable event targets\n * @throws error in case delegations are missing viable ancestor targets\n * @returns {Number} the number of handlers actually removed by the function call, may also be 0 if nothing matched\n *\n * @memberof Events:off\n * @alias off\n * @see on\n * @see once\n * @example\n * off(buttonElement, 'click');\n * off(bar, '*.__default');\n * off(customEventElement, 'crash');\n * off([ancestorElement, 'a'], 'click');\n * off([ancestorElement, '.btn[data-foobar=\"test\"]'], '*.delegated', fSpecificHandler);\n * off(linkElement, '*', fSpecificHandler);\n * off(customEventElement, ['*.test', '*.site']);\n * off([ancestorElement, 'a', ancestorElement, '.btn[data-foobar=\"test\"]'], '*.*', fSpecificHandler);\n * off(buttonElement, '*.*');\n */\nexport function off(targets, events, handler=null){\n\tconst __methodName__ = 'off';\n\n\t({targets, events, handler} = prepareEventMethodBaseParams(__methodName__, targets, events, handler, true));\n\n\tlet removedCount = 0;\n\n\ttargets.forEach((target, targetIndex) => {\n\t\tconst {\n\t\t\tprevTarget,\n\t\t\thasDelegation,\n\t\t\tisDelegation\n\t\t} = prepareEventMethodAdditionalTargetInfo(__methodName__, targets, targetIndex);\n\n\t\tif( !hasDelegation ){\n\t\t\tconst targetEvents = isDelegation ? EVENT_MAP.get(prevTarget) : EVENT_MAP.get(target);\n\n\t\t\tif( hasValue(targetEvents) ){\n\t\t\t\tevents.forEach(eventName => {\n\t\t\t\t\tconst {event, namespace} = prepareEventMethodEventInfo(eventName);\n\n\t\t\t\t\tif( isDelegation ){\n\t\t\t\t\t\tremovedCount += removeDelegatedHandlers(prevTarget, target, namespace, event, handler);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tremovedCount += removeHandlers(target, namespace, event, handler);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tcleanUpEventMap(isDelegation ? prevTarget : target);\n\t\t\t}\n\t\t}\n\t});\n\n\treturn removedCount;\n}\n\n\n\n/**\n * @namespace Events:pause\n */\n\n/**\n * Pauses (a), previously defined, event listener(s), without actually removing anything. Subsequent executions\n * of the handler will not fire, while the handler is paused, which also means, that paused handlers, set up to only\n * fire once, will not self-destroy while being paused.\n *\n * The definition of targets and events works exactly as in \"on\" and \"once\", the only difference being, that the handler\n * is optional in this case, which results in the pausing of all handlers, without targeting a specific one.\n *\n * To specifically target handlers without a namespace, please use the namespace-string \"__default\".\n *\n * @param {EventTarget|Array<EventTarget>} targets - the target(s) to pause event handlers on\n * @param {String|Array<String>} events - the event name(s) to pause, can be either a single name or a list of names, each name may also have a namespace, separated by a dot, to target all events/namespaces, you may use \"*\"/\"*.*\"\n * @param {?Function} [handler=null] - a specific callback function to pause\n * @param {?Boolean} [paused=true] - defines if the matched handlers are being paused or resumed\n * @throws error in case no targets are defined\n * @throws error in case no events are defined\n * @throws error in case no handler is not a function\n * @throws error in case targets are not all usable event targets\n * @throws error in case delegations are missing viable ancestor targets\n * @returns {Number} the number of handlers actually paused by the function call, may also be 0 if nothing matched\n *\n * @memberof Events:pause\n * @alias pause\n * @see on\n * @see resume\n * @example\n * pause(buttonElement, 'click');\n * pause(linkElement, '*.__default');\n * pause(customEventElement, 'crash');\n * pause([ancestorElement, 'a'], 'click');\n * pause([ancestorElement, '.btn[data-foobar=\"test\"]'], '*.delegated', fSpecificHandler);\n */\nexport function pause(targets, events, handler=null, paused=true){\n\tconst __methodName__ = 'pause';\n\n\t({targets, events, handler} = prepareEventMethodBaseParams(__methodName__, targets, events, handler, true));\n\n\tlet pausedCount = 0;\n\n\ttargets.forEach((target, targetIndex) => {\n\t\tconst {\n\t\t\tprevTarget,\n\t\t\thasDelegation,\n\t\t\tisDelegation\n\t\t} = prepareEventMethodAdditionalTargetInfo(__methodName__, targets, targetIndex);\n\n\t\tif( !hasDelegation ){\n\t\t\tconst targetEvents = isDelegation ? EVENT_MAP.get(prevTarget) : EVENT_MAP.get(target);\n\n\t\t\tif( hasValue(targetEvents) ){\n\t\t\t\tevents.forEach(eventName => {\n\t\t\t\t\tconst {event, namespace} = prepareEventMethodEventInfo(eventName);\n\n\t\t\t\t\tif( isDelegation ){\n\t\t\t\t\t\tpausedCount += pauseDelegatedHandlers(prevTarget, target, namespace, event, handler, paused);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpausedCount += pauseHandlers(target, namespace, event, handler, null, paused);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t});\n\n\treturn pausedCount;\n}\n\n\n\n/**\n * @namespace Events:resume\n */\n\n/**\n * Resumes (a), previously paused, event listener(s). Subsequent executions of the handler will fire again.\n *\n * The definition of targets and events works exactly as in \"on\" and \"once\", the only difference being, that the handler\n * is optional in this case, which results in the un-pausing of all handlers, without targeting a specific one.\n *\n * To specifically target handlers without a namespace, please use the namespace-string \"__default\".\n *\n * @param {EventTarget|Array<EventTarget>} targets - the target(s) to resume event handlers on\n * @param {String|Array<String>} events - the event name(s) to resume, can be either a single name or a list of names, each name may also have a namespace, separated by a dot, to target all events/namespaces, you may use \"*\"/\"*.*\"\n * @param {?Function} [handler=null] - a specific callback function to resume\n * @throws error in case no targets are defined\n * @throws error in case no events are defined\n * @throws error in case no handler is not a function\n * @throws error in case targets are not all usable event targets\n * @throws error in case delegations are missing viable ancestor targets\n * @returns {Number} the number of handlers actually resumed by the function call, may also be 0 if nothing matched\n *\n * @memberof Events:resume\n * @alias resume\n * @see on\n * @see pause\n * @example\n * resume(linkElement, '*', fSpecificHandler);\n * resume(customEventElement, ['*.test', '*.site']);\n * resume([ancestorElement, 'a', ancestorElement, '.btn[data-foobar=\"test\"]'], '*.*', fSpecificHandler);\n * resume(buttonElement, '*.*');\n */\nexport function resume(targets, events, handler=null){\n\treturn pause(targets, events, handler, false);\n}\n\n\n\n/**\n * @namespace Events:fire\n */\n\n/**\n * Fires event handlers of all matched targets for given events.\n *\n * This function does not actually dispatch events, but identifies matches in the internal event map, based on\n * previously registered handlers using \"on\" and \"once\" and executes the attached handlers, providing them a synthetic\n * CustomEvent as first parameter, carrying the event name as well as a potential payload. So this, function is\n * using the event map as an event bus, instead of the DOM, so these events also will never bubble, but just hit the\n * currently present handlers identified exactly by the provided parameters.\n *\n * The definition of targets and events works exactly as in \"on\" and \"once\", the only difference being, that we have no\n * handler, since if we'd have the handler already, we could just call it.\n *\n * Since we do not use the DOM in this function, we also do not have native events, and therefore we do not have normal\n * event targets we can work with. Instead, this implementation adds the \"syntheticTarget\" and the\n * \"syntheticTargetElements\" event properties to the event that is given to the handler. \"syntheticTarget\" contains\n * the defined event map target, either as a EventTarget or an array of an EventTarget and a corresponding delegation\n * selector (just as you defined them before), while \"syntheticTargetElements\" returns the actual elements as an\n * iterable array. So, in case of a delegation, this gives you the power to actually work with the current delegation\n * targets, without having to write own logic for this.\n *\n * @param {EventTarget|Array<EventTarget>} targets - the target(s) to execute event handlers on\n * @param {String|Array<String>} events - the event name(s) to fire, can be either a single name or a list of names, each name may also have a namespace, separated by a dot, to target all events/namespaces, you may use \"*\"/\"*.*\"\n * @param {?Object} [payload=null] - a plain object payload to relay to the event handlers via the detail of the CustomEvent given to the handler as first parameter\n * @throws error in case no targets are defined\n * @throws error in case no events are defined\n * @throws error in case targets are not all usable event targets\n * @throws error in case delegations are missing viable ancestor targets\n * @returns {Number} the number of handlers actually executed by the function call, may also be 0 if nothing matched\n *\n * @memberof Events:fire\n * @alias fire\n * @see on\n * @see once\n * @see emit\n * @example\n * fire(buttonElement, 'click');\n * fire(linkElement, '*.__default', {importantFlag : true});\n * fire(divElement, 'crash');\n * fire([ancestorElement, 'a'], 'click', {linkWasClicked : true});\n * fire([ancestorElement, '.btn[data-foobar=\"test\"]'], '*.delegated');\n * fire(linkElement, '*');\n * fire([ancestorElement, 'a', ancestorElement, '.btn[data-foobar=\"test\"]'], '*.*');\n * fire(buttonElement, 'click.*', {price : 666});\n */\nexport function fire(targets, events, payload=null){\n\tconst __methodName__ = 'fire';\n\n\t({targets, events} = prepareEventMethodBaseParams(__methodName__, targets, events, null, true));\n\n\tlet fireCount = 0;\n\n\ttargets.forEach((target, targetIndex) => {\n\t\tconst {\n\t\t\tprevTarget,\n\t\t\thasDelegation,\n\t\t\tisDelegation\n\t\t} = prepareEventMethodAdditionalTargetInfo(__methodName__, targets, targetIndex);\n\n\t\tif( !hasDelegation ){\n\t\t\tconst targetEvents = isDelegation ? EVENT_MAP.get(prevTarget) : EVENT_MAP.get(target);\n\n\t\t\tif( hasValue(targetEvents) ){\n\t\t\t\tevents.forEach(eventName => {\n\t\t\t\t\tconst {event, namespace} = prepareEventMethodEventInfo(eventName);\n\n\t\t\t\t\tlet gatheredTargetEvents;\n\t\t\t\t\tif( isDelegation ){\n\t\t\t\t\t\tgatheredTargetEvents = gatherTargetEvents(prevTarget, namespace, event, target);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgatheredTargetEvents = gatherTargetEvents(target, namespace, event);\n\t\t\t\t\t}\n\n\t\t\t\t\tObject.keys(gatheredTargetEvents).forEach(ns => {\n\t\t\t\t\t\tArray.from(gatheredTargetEvents[ns]).forEach(ev => {\n\t\t\t\t\t\t\tconst\n\t\t\t\t\t\t\t\thandlerScope = isDelegation\n\t\t\t\t\t\t\t\t\t? targetEvents[ns][ev].delegations[target]\n\t\t\t\t\t\t\t\t\t: targetEvents[ns][ev]\n\t\t\t\t\t\t\t\t,\n\t\t\t\t\t\t\t\tsyntheticEvent = isDelegation\n\t\t\t\t\t\t\t\t\t? createSyntheticEvent(ev, ns, payload, false, false, [prevTarget, target])\n\t\t\t\t\t\t\t\t\t: createSyntheticEvent(ev, ns, payload, false, false, target)\n\t\t\t\t\t\t\t;\n\n\t\t\t\t\t\t\thandlerScope.handlers.forEach(handler => {\n\t\t\t\t\t\t\t\thandler.action(syntheticEvent);\n\t\t\t\t\t\t\t\tfireCount++;\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t});\n\n\treturn fireCount;\n}\n\n\n\n/**\n * @namespace Events:emit\n */\n\n/**\n * Dispatches synthetic events on all given targets.\n *\n * In contrast to \"fire\", this function actually dispatches bubbling events on the provided EventTargets. Delegations\n * are resolved using \"querySelectorAll\". This function does not check actual handler presence using the event map, but\n * blindly emits what has been given, purely using the DOM as the event bus. Handlers defined with \"on\" and \"once\" will\n * of course still be triggered if hit, since they always also register a native event listener. The events emitted\n * are purely synthetic basic Events and CustomEvents, lacking special properties, which, for example, MouseEvents\n * provide. So, using \"screenX\" in the handler will not work. If you need a certain base class for the created events,\n * use the \"EventConstructor\" to provide the base class and add special options via \"eventOptions\".\n *\n * The definition of targets and events works almost as in \"on\" and \"once\", the only differences being, that we have no\n * handler, and we cannot leave out the event name. Using a wildcard for the namespace will leave out the namespace in\n * the created events.\n *\n * @param {EventTarget|Array<EventTarget>} targets - the target(s) to dispatch events on\n * @param {String|Array<String>} events - the event name(s) to emit, can be either a single name or a list of names, each name may also have a namespace, separated by a dot, to target all events/namespaces, you may use \"*\"/\"*.*\"\n * @param {?Object} [payload=null] - a plain object payload to relay to the event handlers via the detail of the CustomEvent given to the handler as first parameter\n * @param {?Function} [EventConstructor=null] - the default constructor is Event/CustomEvent, if you need another specific synthetic event, provide a constructor such as MouseEvent here\n * @param {?Object} [eventOptions=null] - use this plain object to provide constructor specific options to use in event construction, this should especially come in handy in case you provide a custom EventConstructor\n * @throws error in case no targets are defined\n * @throws error in case no events are defined\n * @throws error in case targets are not all usable event targets\n * @throws error in case delegations are missing viable ancestor targets\n * @returns {Number} the number of events actually dispatched by the function call, may also be 0 if nothing matched\n *\n * @memberof Events:emit\n * @alias emit\n * @see on\n * @see once\n * @see fire\n * @example\n * emit([buttonElement, ancestorElement, 'a'], 'click');\n * emit(linkElement, 'click.__default', {defaultClick: true});\n * emit([divElement, document.body], 'crash');\n * emit([ancestorElement, 'a'], 'click', {trackingId : 'abc123'});\n * emit([ancestorElement, '.btn[data-foobar=\"test\"]'], 'click.delegated');\n * emit(ancestorElement, ['crash.test', 'crash.site'], {damage : 1000});\n * emit([ancestorElement, 'a', ancestorElement, '.btn[data-foobar=\"test\"]'], 'click.delegated', null, null, {bubbles : false});\n * emit(buttonElement, 'click.*', {price : 666}, MouseEvent, {bubbles : false});\n */\nexport function emit(targets, events, payload=null, EventConstructor=null, eventOptions=null){\n\tconst __methodName__ = 'emit';\n\n\t({targets, events} = prepareEventMethodBaseParams(__methodName__, targets, events, null, true));\n\n\tlet emitCount = 0;\n\n\ttargets.forEach((target, targetIndex) => {\n\t\tconst {\n\t\t\tprevTarget,\n\t\t\thasDelegation,\n\t\t\tisDelegation\n\t\t} = prepareEventMethodAdditionalTargetInfo(__methodName__, targets, targetIndex);\n\n\t\tif( !hasDelegation ){\n\t\t\tevents.forEach(eventName => {\n\t\t\t\tconst {event, namespace} = prepareEventMethodEventInfo(eventName);\n\n\t\t\t\tassert(hasValue(event), `${MODULE_NAME}:${__methodName__} | missing event name`);\n\n\t\t\t\tif( isDelegation ){\n\t\t\t\t\tArray.from(prevTarget.querySelectorAll(target)).forEach(element => {\n\t\t\t\t\t\telement.dispatchEvent(\n\t\t\t\t\t\t\tcreateSyntheticEvent(event, namespace, payload, true, true, null, EventConstructor, eventOptions)\n\t\t\t\t\t\t);\n\t\t\t\t\t\temitCount++;\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\ttarget.dispatchEvent(\n\t\t\t\t\t\tcreateSyntheticEvent(event, namespace, payload, true, true, null, EventConstructor, eventOptions)\n\t\t\t\t\t);\n\t\t\t\t\temitCount++;\n\t\t\t\t}\n\t\t\t});\n\n\t\t}\n\t});\n\n\treturn emitCount;\n}\n\n\n\n/**\n * @namespace Events:offDetachedElements\n */\n\n/**\n * This method completely removes all handlers and listeners for provided targets in case that they\n * are actually an element and not part of the DOM (anymore).\n *\n * The most common use-case for this is to clean the event map after dynamically removing an element from the interface\n * during runtime, maybe as a reaction to a user interaction.\n *\n * Since we are overlaying the DOM event system with a separate (non-weak) event map, handlers in the map do not\n * automatically disappear if the event targets, being elements, are removed from the DOM. In that case, we have to\n * actually unregister events again, for which this is a handy little helper method.\n *\n * There are two common ways to use this:\n * 1. Just call it with the removed element, after removal of the element. This will only remove all data for that\n *    element, if it actually is an element and is not currently in the DOM.\n * 2. Call it without parameters, to iterate all current targets, check if they are elements and currently not in the\n *    DOM and remove all handlers and listeners in that case.\n *\n * So, you can either directly clean-up anything you remove or remove everything, that needs removing and do a general\n * clean-up after everything has been done.\n *\n * Be aware, that the definition of what an element is and if that element is part of the dom is defined by the actual\n * event target. So delegations are not automatically covered by this, since they rely on the ancestor element for\n * event handling.\n *\n * @param {?EventTarget|Array<EventTarget>} [targets=null] - the target(s) to remove from the event map, if not set, all event targets in the current event map are used\n * @returns {Number} the number of targets for which registered handlers and listeners have been removed\n *\n * @memberof Events:offDetachedElements\n * @alias offDetachedElements\n * @example\n * button.remove();\n * offDetachedElements(button);\n * => 1\n * link.innerText = 'test';\n * button.remove();\n * offDetachedElements([link, button]);\n * => 1\n * offDetachedElements()\n * => number of all currently registered targets, being elements and not in the dom\n */\n\nexport function offDetachedElements(targets){\n\ttargets = orDefault(targets, [], 'arr');\n\n\tif( targets.length === 0 ){\n\t\ttargets = Array.from(EVENT_MAP.keys());\n\t}\n\n\tlet offCount = 0;\n\n\ttargets.forEach(target => {\n\t\tif( isA(target, 'htmlelement') && !isInDom(target) && EVENT_MAP.has(target) ){\n\t\t\toffCount++;\n\t\t\toff(target, '*');\n\t\t}\n\t});\n\n\treturn offCount;\n}\n"]}
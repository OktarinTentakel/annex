{"version":3,"file":"elements.js","names":["MODULE_NAME","orDefault","isA","isPlainObject","isSelector","isElement","hasValue","assert","size","Deferred","randomUuid","clone","onDomReady","applyStyles","NOT_AN_HTMLELEMENT_ERROR","BROWSER_HAS_CSS_SCOPE_SUPPORT","document","querySelector","ex","createNode","tag","attributes","content","trim","outerNode","createElement","test","innerHTML","appendChild","node","firstChild","removeChild","attribute","setAttribute","textContent","insertNode","target","position","insertAdjacentElement","replaceNode","__methodName__","parentNode","defineNode","definition","boilerplateNode","inheritValue","Array","from","forEach","name","startsWith","value","Object","keys","sort","reverse","addValue","slice","endsWith","concat","split","classList","add","rules","valueObj","rule","key","prop","getAttribute","getTextContent","onlyFirstLevel","childNodes","nodeType","isInDom","contains","body","getData","properties","data","property","attributeValue","JSON","parse","replace","length","setData","dataSet","singleValue","singleKey","appliedValues","entries","undefined","stringifiedValue","getValue","stringify","hasAttribute","removeAttribute","removeData","reduce","removalDataSet","find","selector","onlyOne","scopeRex","querySelectorAll","fallbackScopeAttribute","found","findOne","findTextNodes","filter","isValidTextNode","extractTextNodes","textNodes","childNode","prime","init","classChanges","markerAttributesName","deferred","initResult","then","catch","resolution","resolve","error","reject","remove","removeClass","addClass","measureHiddenDimensions","method","context","methods","offset","width","height","outer","client","inner","scroll","sandbox","id","class","style","measureClone","dimensions","toString"],"sources":["elements.js"],"mappings":"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","sourcesContent":["/*!\n * Module Elements\n */\n\n/**\n * @namespace Elements\n */\n\nconst MODULE_NAME = 'Elements';\n\n\n\n//###[ IMPORTS ]########################################################################################################\n\nimport {orDefault, isA, isPlainObject, isSelector, isElement, hasValue, assert, size, Deferred} from './basic.js';\nimport {randomUuid} from './random.js';\nimport {clone} from './objects.js';\nimport {onDomReady} from './events.js';\nimport {applyStyles} from './css.js';\n\n\n\n//###[ DATA ]###########################################################################################################\n\nconst NOT_AN_HTMLELEMENT_ERROR = 'given node/target is not an HTMLElement';\nlet BROWSER_HAS_CSS_SCOPE_SUPPORT;\ntry {\n\tdocument.querySelector(':scope *');\n} catch(ex){\n\tBROWSER_HAS_CSS_SCOPE_SUPPORT = false;\n}\n\n\n\n//###[ EXPORTS ]########################################################################################################\n\n/**\n * @namespace Elements:createNode\n */\n\n/**\n * Creates an element on the fly programmatically, based on provided name, attributes and content or markup,\n * without inserting it into the DOM.\n *\n * If you provide markup as \"tag\", make sure that there is one single root element, this method returns exactly one\n * element, not a NodeList. Also be sure to _not_ just pass HTML source from an unsecure source, since this\n * method does not deal with potential security risks.\n *\n * One thing about dynamically creating script tags with this: if you want the script is javascript and you want to\n * actually execute the script upon adding it to the dom, you cannot provide the complete tag as a source string,\n * since scripts created with innerHTML will not execute.\n * (see: https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML#security_considerations)\n * Instead, just provide the tag name and define attributes and source via the parameters instead.\n *\n * @param {?String} [tag='span'] - tag of the element to create or markup for root element\n * @param {?Object} [attributes=null] - tag attributes as key/value-pairs, will also be added to provided markup\n * @param {?String} [content=null] - content to insert into the element as textContent, be aware, that this will replace other content in provided markup\n * @returns {HTMLElement} the created DOM-node\n *\n * @memberof Elements:createNode\n * @alias createNode\n * @example\n * document.body.appendChild(\n *   createNode('div', {id : 'content', style : 'display:none;'}, 'loading...')\n * );\n * document.body.appendChild(\n *   createNode('<div id=\"content\" style=\"display:none;\">loading...</div>')\n * );\n * document.body.appendChild(\n *   createNode('script', {type : 'text/javascript'}, 'alert(\"Hello World\");');\n * );\n */\nexport function createNode(tag, attributes=null, content=null){\n\ttag = orDefault(tag, 'span', 'str').trim();\n\tattributes = isPlainObject(attributes) ? attributes : null;\n\tcontent = orDefault(content, null, 'str');\n\n\t// using anything more generic like template results in non-standard nodes like\n\t// <script type=\"text/json\"> not being creatable\n\tconst outerNode = document.createElement('div');\n\n\tif(\n\t\t/^<[^\\/][^<>]*>/.test(tag)\n\t\t&& /<\\/[^<>\\/]+>$/.test(tag)\n\t){\n\t\t// using DOMParser results in non-standard nodes like\n\t\t// <script type=\"text/json\"> not being creatable\n\t\touterNode.innerHTML = tag;\n\t} else {\n\t\touterNode.appendChild(document.createElement(tag));\n\t}\n\n\tconst node = outerNode.firstChild;\n\touterNode.removeChild(node);\n\n\tif( hasValue(attributes) ){\n\t\tfor( let attribute in attributes ){\n\t\t\tnode.setAttribute(attribute, `${attributes[attribute]}`);\n\t\t}\n\t}\n\n\tif( hasValue(content) ){\n\t\tnode.textContent = content;\n\t}\n\n\treturn node;\n}\n\n\n\n/**\n * @namespace Elements:insertNode\n */\n\n/**\n * Inserts a node into the DOM in relation to a target element.\n *\n * If the node is not an element, the parameter is treated as source and a node is created\n * automatically based on that.\n *\n * The position can be determined with the same values as in \"insertAdjacentElement\"\n * (see: https://developer.mozilla.org/en-US/docs/Web/API/Element/insertAdjacentElement),\n * but we also added the more intuitive jQuery aliases for positions:\n *\n * - \"beforebegin\" can also be described as \"before\"\n * - \"afterbegin\" can also be described as \"prepend\"\n * - \"beforeend\" can also be described as \"append\"\n * - \"afterend\" can also be descrived as \"after\"\n *\n * @param {HTMLElement} target - the element to which the node will be inserted in relation to\n * @param {HTMLElement|String} node - the node to insert, either as element or source string\n * @param {?String} [position='beforeend'] - the position to insert the node in relation to target, the default value appends the node as the last child in target\n * @throws error if target is not an HTMLElement\n * @returns {HTMLElement} the inserted DOM-node\n *\n * @memberof Elements:insertNode\n * @alias insertNode\n * @example\n * insertNode(document.querySelector('.list-container'), listItemElement);\n * insertNode(document.querySelector('.list-container'), '<li>Item 42</li>', 'prepend');\n */\nexport function insertNode(target, node, position='beforeend'){\n\tconst __methodName__ = 'insertNode';\n\n\tassert(isElement(target), `${MODULE_NAME}.${__methodName__} | ${NOT_AN_HTMLELEMENT_ERROR}`);\n\n\tif( !isElement(node) ){\n\t\tnode = createNode(`${node}`);\n\t}\n\n\tswitch( position ){\n\t\tcase 'beforebegin':\n\t\tcase 'before':\n\t\t\tposition = 'beforebegin';\n\t\tbreak;\n\t\tcase 'afterend':\n\t\tcase 'after':\n\t\t\tposition = 'afterend';\n\t\tbreak;\n\t\tcase 'afterbegin':\n\t\tcase 'prepend':\n\t\t\tposition = 'afterbegin';\n\t\tbreak;\n\t\tcase 'beforeend':\n\t\tcase 'append':\n\t\t\tposition = 'beforeend';\n\t\tbreak;\n\t\tdefault:\n\t\t\tposition = 'beforeend';\n\t\tbreak;\n\t}\n\n\ttarget.insertAdjacentElement(position, node);\n\n\treturn node;\n}\n\n\n\n/**\n * @namespace Elements:replaceNode\n */\n\n/**\n * Replaces a node with another one.\n *\n * If the node is not an element, the parameter is treated as source and a node is created\n * automatically based on that.\n *\n * The target node needs a parent node for this function to work.\n *\n * @param {HTMLElement} target - the element to replace\n * @param {HTMLElement|String} node - the node to replace the target with\n * @throws error if target is not an HTMLElement or does not have a parent\n * @returns {HTMLElement} the replacement node\n *\n * @memberof Elements:replaceNode\n * @alias replaceNode\n * @example\n * replaceNode(document.querySelector('.hint'), newHintElement);\n * replaceNode(document.querySelector('.hint'), '<p class=\"hint\">Sale tomorrow!</p>');\n */\nexport function replaceNode(target, node){\n\tconst __methodName__ = 'replaceNode';\n\n\tassert(isElement(target), `${MODULE_NAME}.${__methodName__} | ${NOT_AN_HTMLELEMENT_ERROR}`);\n\n\tif( !isElement(node) ){\n\t\tnode = createNode(`${node}`);\n\t}\n\n\tassert(isElement(target.parentNode), `${MODULE_NAME}.${__methodName__} | given target does not have a parent)`);\n\n\tinsertNode(target, node, 'after');\n\ttarget.parentNode.removeChild(target);\n\n\treturn node;\n}\n\n\n\n/**\n * @namespace Elements:defineNode\n */\n\n/**\n * Creates element attributes for an (existing) element, providing the possibility to declare another\n * element as a boilerplate element to inherit attributes from.\n *\n * The basic premise is this: Define all attributes in a plain object, where the key is the attribute name and the\n * value is the attribute value. `class` may be provided as an array of class definitions and `style` may be provided\n * as a plain object (defining styles as key/value pairs, just as is `applyStyles`). You may even define `style` as an\n * array of plain objects. In both arrays, the last entries have precedence. Everything else has to be a string.\n *\n * You can declare a `boilerplateNode` to use another element as source to inherit attributes from. To inherit an\n * attribute (if it exists), declare the attribute with a value of \"<-\".\n *\n * Normally all attributes of the target element will be overwritten with provided/inherited values, but you may declare\n * attributes with a preceding \"+\" to just add to anything already there. `class` as `+class` and `style` as `+style`\n * for example. In these cases, classes and styles would be added to anything already declared. Normal string values\n * would simply be concatenated.\n *\n * If you want to inherit all data-attributes or on-handlers from an element you may declare the fields `data*` and\n * `on*` as \"<-\" to inherit all attributes starting with data- or on. This would even work as `+data*` and `+on*`.\n *\n * Keep in mind that explicit definitions always have precedence over inherited values, so `data*` being \"<-\" and an\n * additionally declared data value will result in the element getting the declared value on the field and not having\n * the inherited value.\n *\n * @param {HTMLElement} node - the pre-existing node to (re)define\n * @param {Object} definition - a plain object declaring attributes to set or inherit from another object of the form {attributeName : attributeValue|true}\n * @param {?HTMLElement} [boilerplateNode=null] - a node to take the definition from, all values set to true in definition are inherited from here\n * @throws error if target is not an HTMLElement\n * @throws error if definition is not a plain object\n * @returns {HTMLElement} the (re)defined node\n *\n * @memberof Elements:defineNode\n * @alias defineNode\n * @see applyStyles\n * @example\n * defineNode(existingElement, {'id' : 'kitten', '+class' : ['cute', 'fluffy'], '+style' : ['display:none;', {position : 'absolute'}]});\n * defineNode(existingElement, {'+class' : '<-', 'data*' : '<-', 'data-foo' : 'this will have precedence over data*'}, anotherElement);\n */\nexport function defineNode(node, definition, boilerplateNode=null){\n\tconst __methodName__ = 'defineNode';\n\n\tassert(isElement(node), `${MODULE_NAME}:${__methodName__} | ${NOT_AN_HTMLELEMENT_ERROR}`);\n\tassert(isPlainObject(definition), `${MODULE_NAME}:${__methodName__} | definitions is not a plain object`);\n\n\tconst inheritValue = '<-';\n\n\tif( isElement(boilerplateNode) ){\n\t\tArray.from(boilerplateNode.attributes).forEach(attribute => {\n\t\t\tif(\n\t\t\t\t(definition[attribute.name] === inheritValue)\n\t\t\t\t|| (\n\t\t\t\t\t!hasValue(definition[attribute.name])\n\t\t\t\t\t&& (\n\t\t\t\t\t\t((definition['data*'] === inheritValue) && attribute.name.startsWith('data-'))\n\t\t\t\t\t\t|| ((definition['on*'] === inheritValue) && attribute.name.startsWith('on'))\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t){\n\t\t\t\tdefinition[attribute.name] = attribute.value;\n\t\t\t}\n\n\t\t\tif(\n\t\t\t\t(definition[`+${attribute.name}`] === inheritValue)\n\t\t\t\t|| (\n\t\t\t\t\t!hasValue(definition[`+${attribute.name}`])\n\t\t\t\t\t&& (\n\t\t\t\t\t\t((definition['+data*'] === inheritValue) && attribute.name.startsWith('data-'))\n\t\t\t\t\t\t|| ((definition['+on*'] === inheritValue) && attribute.name.startsWith('on'))\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t){\n\t\t\t\tif(\n\t\t\t\t\t!hasValue(definition[`+${attribute.name}`])\n\t\t\t\t\t|| (definition[`+${attribute.name}`] === inheritValue)\n\t\t\t\t){\n\t\t\t\t\tdefinition[`+${attribute.name}`] = '';\n\t\t\t\t}\n\n\t\t\t\tdefinition[`+${attribute.name}`] += attribute.value;\n\t\t\t}\n\t\t});\n\t}\n\n\tdelete definition['data*'];\n\tdelete definition['+data*'];\n\tdelete definition['on*'];\n\tdelete definition['+on*'];\n\tObject.keys(definition).forEach(name => {\n\t\tif( definition[name] === inheritValue ){\n\t\t\tdelete definition[name];\n\t\t}\n\t});\n\n\tObject.keys(definition).sort().reverse().forEach(name => {\n\t\tconst\n\t\t\tvalue = definition[name],\n\t\t\taddValue = name.startsWith('+')\n\t\t;\n\n\t\tif( addValue ){\n\t\t\tname = name.slice(1);\n\t\t}\n\n\t\tif( name.endsWith('*') ){\n\t\t\tname = name.slice(0, -1);\n\t\t}\n\n\t\tif( (name === 'class') ){\n\t\t\tif( !addValue ){\n\t\t\t\tnode.setAttribute('class', '');\n\t\t\t}\n\n\t\t\t[].concat(value).forEach(value => {\n\t\t\t\t`${value}`.split(' ').forEach(value => {\n\t\t\t\t\tnode.classList.add(`${value.trim()}`);\n\t\t\t\t});\n\t\t\t});\n\t\t} else if( (name === 'style') ){\n\t\t\tif( !addValue ){\n\t\t\t\tnode.setAttribute('style', '');\n\t\t\t}\n\n\t\t\t[].concat(value).forEach(value => {\n\t\t\t\tif( !isPlainObject(value) ){\n\t\t\t\t\tconst\n\t\t\t\t\t\trules = `${value}`.split(';'),\n\t\t\t\t\t\tvalueObj = {}\n\t\t\t\t\t;\n\n\t\t\t\t\trules.forEach(rule => {\n\t\t\t\t\t\tlet [key, prop] = rule.split(':');\n\t\t\t\t\t\tkey = key.trim();\n\n\t\t\t\t\t\tif( hasValue(prop) ){\n\t\t\t\t\t\t\tprop = prop.trim();\n\t\t\t\t\t\t\tprop = prop.endsWith(';') ? prop.slice(0, -1) : prop;\n\t\t\t\t\t\t\tvalueObj[key] = prop;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\tvalue = valueObj;\n\t\t\t\t}\n\n\t\t\t\tif( hasValue(value) ){\n\t\t\t\t\tapplyStyles(node, value);\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\tif( !addValue ){\n\t\t\t\tnode.setAttribute(name, `${value}`);\n\t\t\t} else {\n\t\t\t\tnode.setAttribute(name, `${node.getAttribute(name) ?? ''}${value}`);\n\t\t\t}\n\t\t}\n\t});\n\n\treturn node;\n}\n\n\n\n/**\n * @namespace Elements:getTextContent\n */\n\n/**\n * Return the de-nodified text content of a node-ridden string or a DOM-node.\n * Returns the raw text content, with all markup cleanly removed.\n * Can also be used to return only the concatenated child text nodes.\n *\n * @param {(String|Node)} target - the node-ridden string or DOM-node to \"clean\"\n * @param {?Boolean} [onlyFirstLevel=false] - true if only the text of direct child text nodes is to be returned\n * @throws error if target is neither markup nor node\n * @returns {String} the text content of the provided markup or node\n *\n * @memberof Elements:getTextContent\n * @alias getTextContent\n * @example\n * someElement.textContent = getTextContent('<p onlick=\"destroyWorld();\">red button <a>meow<span>woof</span></a></p>');\n */\nexport function getTextContent(target, onlyFirstLevel=false){\n\tconst __methodName__ = 'getTextContent';\n\n\tonlyFirstLevel = orDefault(onlyFirstLevel, false, 'bool');\n\n\tif( isA(target, 'string') ){\n\t\ttarget = createNode(target);\n\t}\n\n\tassert(isElement(target), `${MODULE_NAME}:${__methodName__} | target is neither node nor markup`);\n\n\tif( onlyFirstLevel ){\n\t\tlet textContent = '';\n\n\t\ttarget.childNodes.forEach(node => {\n\t\t\tif( node.nodeType === 3 ){\n\t\t\t\ttextContent += node.textContent;\n\t\t\t}\n\t\t});\n\n\t\treturn textContent;\n\t} else {\n\t\treturn target.textContent;\n\t}\n}\n\n\n\n/**\n * @namespace Elements:isInDom\n */\n\n/**\n * Returns if an element is currently part of the DOM or in a detached state.\n *\n * @param {HTMLElement} node - the element to check, whether it is currently in the dom or detached\n * @throws error if node is not a usable HTML element\n * @returns {Boolean} true if the element is part of the DOM at the moment\n *\n * @memberof Elements:isInDom\n * @alias isInDom\n * @example\n * if( !isInDom(el) ){\n *     elementMetaInformation.delete(el);\n * }\n */\nexport function isInDom(node){\n\tconst __methodName__ = 'isInDom';\n\n\tassert(isElement(node), `${MODULE_NAME}:${__methodName__} | ${NOT_AN_HTMLELEMENT_ERROR}`);\n\n\treturn isA(document.contains, 'function') ? document.contains(node) : document.body.contains(node);\n}\n\n\n\n/**\n * @namespace Elements:getData\n */\n\n/**\n * Returns the element's currently set data attribute value(s).\n *\n * This method has two major differences from the standard browser dataset-implementations:\n * 1. Property names are _not_ handled camel-cased in any way.\n *    The data attribute `data-my-naughty-dog` property does _not_ magically become `myNaughtyDog` on access,\n *    but keeps the original notation, just losing the prefix, so access it, by using `my-naughty-dog`\n * 2. All property values are treated as JSON first and foremost, falling back to string values, if the\n *    value is not parsable. This means, that `{\"foo\" : \"bar\"}` becomes an object, `[1, 2, 3]` becomes an array,\n *    `42` becomes a number, `true` becomes a boolean and `null` becomes a null-value. But `foobar` actually becomes\n *    the string \"foobar\". JSON-style double quotes are removed, when handling a single string.\n *\n * Keep in mind that things like `new Date()` will not work out of the box, since this is not included in the JSON\n * standard, but has to be serialized/deserialized.\n *\n * @param {HTMLElement} node - the element to read data from\n * @param {?String|Array<String>} [properties=null] - if set, returns value(s) of that specific property/properties (single value for exactly one property, dictionary for multiple), if left out, all properties are returned as a dictionary object\n * @throws error if node is not a usable HTML element\n * @returns {*|Object|null} JSON-parsed attribute value(s) with string fallback; either a single value for exactly one property, a dictionary of values for multiple or a call without properties (meaning all) or null, in case no data was found\n *\n * @memberof Elements:getData\n * @alias getData\n * @see setData\n * @see removeData\n * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/dataset\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse\n * @example\n * getData(createNode('<div data-my-naughty-dog=\"42\"></div>'), 'my-naughty-dog')\n * => 42\n * getData(createNode('<div data-my-naughty-dog='{\"foo\" : [1, \"two\", true]}'></div>'), 'my-naughty-dog')\n * => {\"foo\" : [1, \"two\", true]}\n * getData(createNode('<div data-my-naughty-dog='1, \"two\", true'></div>'), 'my-naughty-dog')\n * => '1, \"two\", true'\n * getData(createNode('<div data-my-naughty-dog=\"42\" data-foo=\"true\" data-bar=\"test\"></div>'), ['foo', 'bar'])\n * => {\"foo\" : true, \"bar\" : \"test\"}\n * getData(createNode('<div data-my-naughty-dog=\"42\" data-foo=\"true\" data-bar=\"test\"></div>'))\n * => {\"my-naughty-dog\" : 42,\"foo\" : true, \"bar\" : \"test\"}\n */\nexport function getData(node, properties=null){\n\tconst __methodName__ = 'getData';\n\n\tproperties = orDefault(properties, null, 'arr');\n\n\tassert(isElement(node), `${MODULE_NAME}:${__methodName__} | ${NOT_AN_HTMLELEMENT_ERROR}`);\n\n\tlet data = {};\n\n\tif( hasValue(properties) ){\n\t\tproperties.forEach(property => {\n\t\t\tlet attributeValue = node.getAttribute(`data-${property}`);\n\t\t\tif( hasValue(attributeValue) ){\n\t\t\t\ttry {\n\t\t\t\t\tdata[property] = JSON.parse(attributeValue);\n\t\t\t\t} catch(ex){\n\t\t\t\t\tdata[property] = attributeValue;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t} else {\n\t\tArray.from(node.attributes).forEach(attribute => {\n\t\t\tif( attribute.name.startsWith('data-') ){\n\t\t\t\tconst property = attribute.name.replace(/^data-/, '');\n\t\t\t\ttry {\n\t\t\t\t\tdata[property] = JSON.parse(attribute.value);\n\t\t\t\t} catch(ex){\n\t\t\t\t\tdata[property] = attribute.value;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tif( size(data) === 0 ){\n\t\tdata = null;\n\t} else if( (properties?.length === 1) ){\n\t\tdata = data[properties[0]] ?? null;\n\t}\n\n\treturn data;\n}\n\n\n\n/**\n * @namespace Elements:setData\n */\n\n/**\n * Writes data to an element, by setting data-attributes.\n *\n * Setting a value of `undefined` or an empty string removes the attribute.\n *\n * This method has two major differences from the standard browser dataset-implementations:\n * 1. Property names are _not_ handled camel-cased in any way.\n *    The data attribute `my-naughty-dog` property is _not_ magically created from `myNaughtyDog`,\n *    but the original notation will be kept, just adding the prefix, so set `data-my-naughty-dog`\n *    by using `my-naughty-dog`\n * 2. All property values are treated as JSON first and foremost, falling back to basic string values, if the\n *    value is not stringifiable as JSON. If the top-level value ends up to be a simple JSON string like '\"foo\"'\n *    or \"'foo'\", the double quotes are removed before writing the value.\n *\n * Keep in mind that things like `new Date()` will not work out of the box, since this is not included in the JSON\n * standard, but has to be serialized/deserialized.\n *\n * @param {HTMLElement} node - the element to write data to\n * @param {Object<String,*>|String} dataSet - the data to write to the element, properties have to be exact data-attribute names without the data-prefix, values are stringified (first with JSON.stringify and then as-is as a fallback), if value is a function it gets executed and the return value will be used from there on; if this is a string, this defines a single property to set, with the singleValue being the value to set\n * @param {?*} [singleValue=null] - if you only want to set exactly one property, you may set dataSet to the property name as a string and provide the value via this parameter instead\n * @throws error if node is not a usable HTML element or if dataSet is not a plain object if no single value has been given\n * @returns {Object<String,*>|*|null} the value(s) actually written to the element's data-attributes as they would be returned by getData (removed attributes are marked with `undefined`); null will be returned if nothing was changed; if only a single value was set, only that value will be returned\n *\n * @memberof Elements:setData\n * @alias setData\n * @see getData\n * @see removeData\n * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/dataset\n * @example\n * setData(element, {foobar : 'hello kittens!'});\n * => {foobar : 'hello kittens!'}\n * setData(element, 'foobar', 'hello kittens!');\n * => 'hello kittens!'\n * setData(element, {foobar : {a : 'foo', b : [1, 2, 3], c : {d : true}}});\n * => {foobar : {a : 'foo', b : [1, 2, 3], c : {d : true}}}\n * setData(element, 'foobar', {a : 'foo', b : [1, 2, 3], c : {d : true}});\n * => {a : 'foo', b : [1, 2, 3], c : {d : true}}\n * setData(element, {foobar : () => { return 'hello kittens!'; }});\n * => {foobar : 'hello kittens!'}\n * setData(element, {foobar : undefined});\n * => {foobar : undefined}\n * setData(element, boofar, '');\n * => undefined\n */\nexport function setData(node, dataSet, singleValue=null){\n\tconst __methodName__ = 'setData';\n\n\tassert(isElement(node), `${MODULE_NAME}:${__methodName__} | ${NOT_AN_HTMLELEMENT_ERROR}`);\n\n\tlet singleKey = null;\n\tif( hasValue(singleValue) ){\n\t\tsingleKey = `${dataSet}`;\n\t\tdataSet = {\n\t\t\t[singleKey] : singleValue\n\t\t};\n\t}\n\n\tassert(isPlainObject(dataSet), `${MODULE_NAME}:${__methodName__} | dataSet is not a plain object`);\n\n\tconst appliedValues = {};\n\n\tObject.entries(dataSet).forEach(([property, value]) => {\n\t\tif( isA(value, 'function') ){\n\t\t\tvalue = value();\n\t\t}\n\n\t\tif( value !== undefined ){\n\t\t\tlet stringifiedValue, getValue;\n\t\t\ttry {\n\t\t\t\tstringifiedValue = JSON.stringify(value);\n\t\t\t\tgetValue = JSON.parse(stringifiedValue);\n\t\t\t} catch(ex){\n\t\t\t\tstringifiedValue = `${value}`;\n\t\t\t\tgetValue = stringifiedValue;\n\t\t\t}\n\t\t\tstringifiedValue = stringifiedValue.replace(/^['\"]/, '').replace(/['\"]$/, '').trim();\n\n\t\t\tif( stringifiedValue !== '' ){\n\t\t\t\tappliedValues[property] = getValue;\n\t\t\t\tnode.setAttribute(`data-${property}`, stringifiedValue);\n\t\t\t} else if( node.hasAttribute(`data-${property}`) ){\n\t\t\t\tappliedValues[property] = undefined;\n\t\t\t\tnode.removeAttribute(`data-${property}`);\n\t\t\t}\n\t\t} else if( node.hasAttribute(`data-${property}`) ){\n\t\t\tappliedValues[property] = undefined;\n\t\t\tnode.removeAttribute(`data-${property}`);\n\t\t}\n\t});\n\n\tif( hasValue(singleKey) ){\n\t\treturn (singleKey in appliedValues) ?  appliedValues[singleKey] : null;\n\t} else {\n\t\treturn (size(appliedValues) > 0) ? appliedValues : null;\n\t}\n}\n\n\n\n/**\n * @namespace Elements:removeData\n */\n\n/**\n * Removes data from an element, by removing corresponding data-attributes.\n *\n * This method has a major difference from the standard browser dataset-implementations:\n * Property names are _not_ handled camel-cased in any way.\n * The data attribute's `my-naughty-dog` property is _not_ magically created from `myNaughtyDog`,\n * but the original notation will be kept, just adding the prefix,\n * so use `my-naughty-dog` to remove `data-my-naughty-dog`\n *\n * @param {HTMLElement} node - the element to remove data from\n * @param {?String|Array<String>} [properties=null] - if set, removes specified property/properties, if left out, all data properties are removed\n * @throws error if node is not a usable HTML element\n * @returns {*|Object<String,*>|null} the removed data values as they would be returned from getData (single value for one property, dictionaries for multiple or all) or null if nothing was removed\n *\n * @memberof Elements:removeData\n * @alias removeData\n * @see getData\n * @see setData\n * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/dataset\n * @example\n * const testNode = createNode(`<span data-foobar=\"test\" data-boofar=\"null\" data-baz='{\"a\" : [\"1\", 2, 3.3], \"b\" : true}'></span>`)\n * removeData(testNode, 'foobar')\n * => 'test' (testNode.outerHTML === `<span data-boofar=\"null\" data-baz='{\"a\" : [\"1\", 2, 3.3], \"b\" : true}'></span>`)\n * removeData(testNode, ['foobar', 'baz', 'test'])\n * => {foobar : 'test', baz : {\"a\" : [\"1\", 2, 3.3], \"b\" : true}} (testNode.outerHTML === `<span data-boofar=\"null\"></span>`)\n * removeData(testNode)\n * => {foobar : 'test', boofar : null, baz : {\"a\" : [\"1\", 2, 3.3], \"b\" : true}} (testNode.outerHTML === `<span></span>`)\n * removeData(testNode, 'test')\n * => null\n */\nexport function removeData(node, properties=null){\n\tconst __methodName__ = 'removeData';\n\n\tproperties = orDefault(properties, null, 'arr');\n\n\tassert(isElement(node), `${MODULE_NAME}:${__methodName__} | ${NOT_AN_HTMLELEMENT_ERROR}`);\n\n\tlet data = getData(node, properties);\n\tif( hasValue(data) ){\n\t\tif( properties?.length === 1 ){\n\t\t\tsetData(node, {[properties[0]] : undefined});\n\t\t} else {\n\t\t\tsetData(node, Object.keys(data).reduce((removalDataSet, property) => {\n\t\t\t\tremovalDataSet[property] = undefined;\n\t\t\t\treturn removalDataSet;\n\t\t\t}, {}));\n\t\t}\n\t} else {\n\t\tdata = null;\n\t}\n\n\treturn data;\n}\n\n\n\n/**\n * @namespace Elements:find\n */\n\n/**\n * Searches for and returns descendant nodes of a given node matching a CSS selector, just as querySelector(All).\n *\n * The main difference to querySelector(All) is, that this method automatically scopes the query, making sure, that the\n * given selector is actually fulfilled _inside_ the scope of the base element and not always regarding the whole\n * document. So, basically this implementation always automatically adds `:scope` to the beginning of the selector\n * if no scope has been defined (as soon as a scope is defined anywhere in the selector, no auto-handling will be done).\n * The function always takes care of handling browsers, that do no support `:scope` yet, by using a randomized query\n * attribute approach.\n *\n * The second (minor) difference is, that this function actually returns an array and does not return a NodeList. The\n * reason being quite simple: Arrays have far better support for basic list operations than NodeList. An example:\n * Getting the first found node is straightforward in both cases (item(0) vs. at(0)), but getting the last node becomes\n * hairy pretty quickly since, item() does not accept negative indices, whereas at() does. So, with an array, we can get\n * the last node simple by using at(-1). Arrays simply have the better API nowadays and since the NodeList would be\n * static here anyway ...\n *\n * The last little difference is, that the base node for this function may not be the document itself, since\n * attribute-based scoping fallback does not work on the document, since we cannot define attributes on the document\n * itself. Just use document.body instead.\n *\n * @param {HTMLElement} node - the element to search in\n * @param {?String} [selector='*'] - the element query selector to apply to node, to find fitting elements\n * @param {?Boolean} [onlyOne=false] - if true, uses querySelector instead of querySelectorAll and therefore returns a single node or null instead of an array\n * @throws error if node is not a usable HTML element\n * @return {Array<Node>|Node|null} descendant nodes matching the selector, a single node or null if onlyOne is true\n *\n * @memberof Elements:find\n * @alias find\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/querySelectorAll#user_notes\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array\n * @example\n * find(document.body, 'section ul > li a[href*=\"#\"]');\n * find(element, '> aside img[src]');\n * find(element, '> aside img[src]', true);\n * find(element, 'aside > :scope figcaption');\n * find(element, '*');\n * find(element, '[data-test=\"foobar\"] ~ li a[href]'));\n * find(element, 'a[href]').at(-1);\n */\nexport function find(node, selector='*', onlyOne=false){\n\tconst\n\t\t__methodName__ = 'find',\n\t\tscopeRex = /:scope(?![\\w-])/gi\n\t;\n\n\tassert(isElement(node), `${MODULE_NAME}:${__methodName__} | ${NOT_AN_HTMLELEMENT_ERROR}`);\n\n\tselector = orDefault(selector, '*', 'str').trim();\n\tif( !(scopeRex.test(selector)) ){\n\t\tselector = `:scope ${selector}`;\n\t}\n\tonlyOne = orDefault(onlyOne, false, 'bool');\n\n\tif( BROWSER_HAS_CSS_SCOPE_SUPPORT ){\n\t\treturn onlyOne ? node.querySelector(selector) : Array.from(node.querySelectorAll(selector));\n\t} else {\n\t\tconst fallbackScopeAttribute = `find-scope-${randomUuid()}`;\n\t\tselector = selector.replace(scopeRex, `[${fallbackScopeAttribute}]`);\n\n\t\tnode.setAttribute(fallbackScopeAttribute, '');\n\t\tconst found = onlyOne ? node.querySelector(selector) : Array.from(node.querySelectorAll(selector));\n\t\tnode.removeAttribute(fallbackScopeAttribute);\n\n\t\treturn found;\n\t}\n}\n\n\n\n/**\n * @namespace Elements:findOne\n */\n\n/**\n * Searches for and returns one descendant node of a given node matching a CSS selector, just as querySelector.\n *\n * The main difference to querySelector is, that this method automatically scopes the query, making sure, that the\n * given selector is actually fulfilled _inside_ the scope of the base element and not always regarding the whole\n * document. So, basically this implementation always automatically adds `:scope` to the beginning of the selector\n * if no scope has been defined (as soon as a scope is defined anywhere in the selector, no auto-handling will be done).\n * The function always takes care of handling browsers, that do no support `:scope` yet, by using a randomized query\n * attribute approach.\n *\n * The function is a shorthand for `find()` with `onlyOne` being true. The main reason this method existing, is, that\n * querySelector has a 2:1 performance advantage over querySelectorAll and nullish coalescing is easier using a\n * possible null result.\n *\n * @param {HTMLElement} node - the element to search in\n * @param {?String} [selector='*'] - the element query selector to apply to node, to find fitting element\n * @throws error if node is not a usable HTML element\n * @return {Node|null} descendant nodes matching the selector\n *\n * @memberof Elements:findOne\n * @alias findOne\n * @see find\n * @example\n * findOne(document.body, 'section ul > li a[href*=\"#\"]');\n * findOne(element, '> aside img[src]');\n * findOne(element, 'aside > :scope figcaption');\n * findOne(element, '*');\n * findOne(element, '[data-test=\"foobar\"] ~ li a[href]'));\n */\nexport function findOne(node, selector='*'){\n\treturn find(node, selector, true);\n}\n\n\n\n/**\n * @namespace Elements:findTextNodes\n */\n\n/**\n * Extracts all pure text nodes from an Element, starting in the element itself.\n *\n * Think of this function as a sort of find() where the result are not nodes, that query selectors can find, but pure\n * text nodes. So you'll get a set of recursively discovered text nodes without tags, representing the pure text content\n * of an element.\n *\n * If you define to set onlyFirstLevel, you'll be able to retrieve all text on the first level of an element _not_\n * included in any tag (paragraph contents without special formats as b/i/em/strong for example).\n *\n * @param {HTMLElement} node - the element to search for text nodes inside\n * @param {?Function} [filter=null] - a filter function to restrict the returned set, gets called with the textNode (you can access the parent via .parentNode)\n * @param {?Boolean} [onlyFirstLevel=false] - defines if the function should only return text nodes from the very first level of children\n * @throws error if node is not a usable HTML element\n * @return {Array<Node>} a list of text nodes\n *\n * @memberof Elements:findTextNodes\n * @alias findTextNodes\n * @example\n * const styledSentence = createElement('<div>arigatou <p>gozaimasu <span>deshita</span></p> mr. roboto<p>!<span>!!</span></p></div>');\n * findTextNodes(styledSentence).length;\n * => 6\n * findTextNodes(styledSentence, null, true).length;\n * => 2\n * findTextNodes(styledSentence, textNode => textNode.textContent.length < 9).length;\n * => 3\n * findTextNodes(styledSentence).map(node => node.textContent).join('');\n * \t=> 'arigatou gozaimasu deshita mr. roboto!!!';\n */\nexport function findTextNodes(node, filter=null, onlyFirstLevel=false){\n\tconst __methodName__ = 'findTextNodes';\n\n\tfilter = isA(filter, 'function') ? filter : () => true;\n\tonlyFirstLevel = orDefault(onlyFirstLevel, false, 'bool');\n\n\tassert(isElement(node), `${MODULE_NAME}:${__methodName__} | ${NOT_AN_HTMLELEMENT_ERROR}`);\n\n\tconst\n\t\ttextNodeType = 3,\n\t\tisValidTextNode = node => {\n\t\t\treturn (node.nodeType === textNodeType)\n\t\t\t\t&& (node.textContent.trim() !== '')\n\t\t\t\t&& !!filter(node)\n\t\t\t;\n\t\t},\n\t\textractTextNodes = node => {\n\t\t\tif( isValidTextNode(node) ){\n\t\t\t\treturn [].concat(node);\n\t\t\t} else {\n\t\t\t\treturn Array.from(node.childNodes).reduce((textNodes, childNode) => {\n\t\t\t\t\treturn isValidTextNode(childNode)\n\t\t\t\t\t\t? textNodes.concat(childNode)\n\t\t\t\t\t\t: (\n\t\t\t\t\t\t\t!!onlyFirstLevel\n\t\t\t\t\t\t\t? textNodes\n\t\t\t\t\t\t\t: textNodes.concat(extractTextNodes(childNode))\n\t\t\t\t\t\t)\n\t\t\t\t\t;\n\t\t\t\t}, []);\n\t\t\t}\n\t\t}\n\t;\n\n\treturn extractTextNodes(node);\n}\n\n\n\n/**\n * @namespace Elements:prime\n */\n\n/**\n * Offers an execution frame for element preparation like setting handlers and transforming dom.\n * Takes a function including the initialization code of an element and wraps it with\n * a check if this initialization was already executed (via data-attribute) as well\n * as a document ready handler to make sure no initializations are executed with a half-ready dom.\n *\n * If the initialization function returns a Promise or Deferred, the returned Deferred will resolve or reject\n * accordingly with the same result value or rejection. If `init` does not return a Promise or Deferred, the returned\n * Deferred will resolve as soon as document ready was reached. So, to be able to work with applied changes\n * on the element after calling `prime` you have three options:\n * 1. Either make sure document ready occurred before prime(), so `init` gets called synchronously right away.\n * 2. Wrap the code after prime a DOM-ready-check as well, to establish a synchronous event order.\n * 3. Use the returned Deferred's `.then()`.\n *\n * During priming, the node receives three data-attributes, stating the current step. The attribute name is built\n * according to the value of `markerAttributeNames` like this:\n * 1. data-${markerAttributeNames}=\"true\" => as soon as prime is executed on the node\n * 2. data-${markerAttributeNames}-ready=\"true\" => as soon as the init function has been executed and the dom is ready\n * 2. data-${markerAttributeNames}-resolved=\"true\" => as soon as the returned Deferred has resolved\n *\n * @param {HTMLElement} node - the element to prime\n * @param {Function} init - the function containing all initialization code for the node, the return value may either also be a Promise or Deferred (probably resolving to a value), the return value will be used to resolve the returned Deferred of the function; if you need to detect repeated prime calls on the same element, it is a good idea to let init return something other than \"undefined\", since that value also signifies a repeated call\n * @param {?Object<String,String|Array<String>>} [classChanges=null] - if set, may contain the keys \"add\" and/or \"remove\" holding standard class strings or arrays of standard class strings, defining which classes to add and/or remove once priming is done, helpful to automatically remove visual cloaking or set ready markers; adding has precedence over removing\n * @param {?String} [markerAttributesName='primed'] - this function uses data-attributes to mark priming status, this is the name used to construct these attributes (default: data-primed*=\"...\")\n * @throws error if node is not a usable HTML element\n * @throws error if init is not a function\n * @returns {Deferred} resolves to the return value of init function or to `undefined` if element was already primed\n *\n * @memberof Elements:prime\n * @alias prime\n * @example\n * prime(widget, () => { return Promise.resolve(); });\n * prime(anotherWidget, () => { return somethingLongRunningAsync(); })).then(function(){ ... })\n * prime(yetAnotherWidget, node => { magicallyTransform(node); }, {remove : 'cloaked'});\n */\nexport function prime(node, init, classChanges=null, markerAttributesName='primed'){\n\tconst __methodName__ = 'prime';\n\n\tclassChanges = orDefault(classChanges, {});\n\tmarkerAttributesName = orDefault(markerAttributesName, 'primed', 'str');\n\n\tassert(isElement(node), `${MODULE_NAME}:${__methodName__} | ${NOT_AN_HTMLELEMENT_ERROR}`);\n\tassert(isA(init, 'function'), `${MODULE_NAME}:${__methodName__} | init is not a function`);\n\n\tconst deferred = new Deferred();\n\n\tif( getData(node, markerAttributesName) !== true ){\n\t\tsetData(node, markerAttributesName, true);\n\n\t\tonDomReady(() => {\n\t\t\tconst initResult = init(node);\n\n\t\t\tif(\n\t\t\t\thasValue(initResult)\n\t\t\t\t&& isA(initResult.then, 'function')\n\t\t\t\t&& isA(initResult.catch, 'function')\n\t\t\t){\n\t\t\t\tinitResult\n\t\t\t\t\t.then(resolution => { deferred.resolve(resolution); })\n\t\t\t\t\t.catch(error => { deferred.reject(error); })\n\t\t\t\t;\n\t\t\t} else {\n\t\t\t\tdeferred.resolve(initResult);\n\t\t\t}\n\n\t\t\tsetData(node, `${markerAttributesName}-ready`, true);\n\t\t});\n\t} else {\n\t\tdeferred.resolve(undefined);\n\t}\n\n\tdeferred.then(() => {\n\t\tif( hasValue(classChanges.remove) ){\n\t\t\t[].concat(classChanges.remove).forEach(removeClass => {\n\t\t\t\t`${removeClass}`.split(' ').forEach(removeClass => {\n\t\t\t\t\tnode.classList.remove(removeClass.trim());\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\tif( hasValue(classChanges.add) ){\n\t\t\t[].concat(classChanges.add).forEach(addClass => {\n\t\t\t\t`${addClass}`.split(' ').forEach(addClass => {\n\t\t\t\t\tnode.classList.add(addClass.trim());\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\tsetData(node, `${markerAttributesName}-resolved`, true);\n\t});\n\n\treturn deferred;\n}\n\n\n\n/**\n * @namespace Elements:measureHiddenDimensions\n */\n\n/**\n * Measures hidden elements by using a sandbox div. In some layout situations you may not be able to measure hidden\n * or especially detached elements correctly, sometimes simply because they are not rendered, other times because\n * they are rendered in a context where the browser does not keep correct styling information due to optimizations\n * considering visibility of the element.\n *\n * This method works by cloning a node and inserting it in a well hidden sandbox element for the time of the measurement,\n * after which the sandbox is immediately removed again. This method allows you to measure \"hidden\" elements inside the\n * DOM without the need to actually move elements around or show them visibly.\n *\n * Keep in mind, that only measurements inherent to the element itself are measurable if sandbox is inserted into the\n * body. Layout information from surrounding containers is, of course, not available. You can remedy this by setting the\n * context correctly. Keep in mind, that direct child selectors may not work in the context since the sandbox itself\n * constitutes a new level between context and element. In these cases you might have to adapt you selectors.\n *\n * @param {HTMLElement} node - the element to measure\n * @param {?String} [method='outer'] - the kind of measurement to take, allowed values are \"outer\"/\"offset\", \"inner\"/\"client\" or \"scroll\"\n * @param {?String} [selector=null] - selector to apply to element to find target\n * @param {?HTMLElement} [context=document.body] - context to use as container for measurement\n * @throws error if node is not a usable HTML element\n * @returns {Object<String,Number>} a plain object holding width and height measured according to the defined method\n *\n * @memberof Elements:measureHiddenDimensions\n * @alias measureHiddenDimensions\n * @see https://developer.mozilla.org/en-US/docs/Web/API/CSS_Object_Model/Determining_the_dimensions_of_elements#how_big_is_the_content\n * @example\n * measureHiddenDimensions(document.body.querySelector('div.hidden:first'), 'inner');\n * measureHiddenDimensions(document.body, 'outer, 'div.hidden:first', document.body.querySelector('main'));\n */\nexport function measureHiddenDimensions(node, method='outer', selector=null, context=null){\n\tconst __methodName__ = 'measureHidden';\n\n\tconst methods = {\n\t\toffset : {width : 'offsetWidth', height : 'offsetHeight'},\n\t\touter : {width : 'offsetWidth', height : 'offsetHeight'},\n\t\tclient : {width : 'clientWidth', height : 'clientHeight'},\n\t\tinner : {width : 'clientWidth', height : 'clientHeight'},\n\t\tscroll : {width : 'scrollWidth', height : 'scrollHeight'}\n\t};\n\tmethod = methods[orDefault(method, 'outer', 'str')] ?? methods.outer;\n\t// document.body not in function default to prevent errors on import in document-less contexts\n\tcontext = orDefault(context, document.body);\n\n\tassert(isElement(node), `${MODULE_NAME}:${__methodName__} | ${NOT_AN_HTMLELEMENT_ERROR}`);\n\tassert(isElement(context), `${MODULE_NAME}:${__methodName__} | context is no an htmlelement`);\n\n\tconst\n\t\tsandbox = createNode('div', {\n\t\t\t'id' : `sandbox-${randomUuid()}`,\n\t\t\t'class' : 'sandbox',\n\t\t\t'style' : 'display:block; opacity:0; visibility:hidden; pointer-events:none; position:absolute; top:-10000px; left:-10000px;'\n\t\t}),\n\t\tmeasureClone = clone(node)\n\t;\n\n\tcontext.appendChild(sandbox);\n\tsandbox.appendChild(measureClone);\n\n\tconst\n\t\ttarget = isSelector(selector) ? measureClone.querySelector(selector) : measureClone,\n\t\twidth = target?.[method.width] ?? 0,\n\t\theight = target?.[method.height] ?? 0,\n\t\tdimensions = {\n\t\t\twidth,\n\t\t\theight,\n\t\t\ttoString(){ return `${width}x${height}`; }\n\t\t}\n\t;\n\n\tcontext.removeChild(sandbox);\n\n\treturn dimensions;\n}\n"]}
{"version":3,"file":"functions.js","names":["MODULE_NAME","orDefault","isFunction","isPlainObject","assert","hasValue","schedule","reschedule","throttle","ms","func","hasLeadingExecution","hasTrailingExecution","frameHasStarted","callsInFrame","args","Array","from","arguments","apply","this","debounce","debounceTimer","defer","delay","id","kwargs","defaults","argNamesString","toString","match","argNames","split","map","argName","trim","length","applicableArgs","forEach","arg","argIndex","argNameIndex"],"sources":["functions.js"],"mappings":";;;AAQA,MAAMA,YAAc,mBAMZC,UAAWC,WAAYC,cAAeC,OAAQC,aAAe,oBAC7DC,SAAUC,eAAiB,qBAqC5B,SAASC,SAASC,EAAIC,EAAMC,GAAoB,EAAOC,GAAqB,GAClFH,EAAKR,UAAUQ,EAAI,EAAG,OACtBE,EAAsBV,UAAUU,GAAqB,EAAO,QAC5DC,EAAuBX,UAAUW,GAAsB,EAAO,QAE9DR,OAAOK,EAAK,EAAG,uCACfL,OAAOF,WAAWQ,GAAO,0CAEzB,IACCG,GAAkB,EAClBC,EAAe,EAGhB,OAAO,WACN,MAAMC,EAAOC,MAAMC,KAAKC,WAEnBL,EAgBuB,IAAjBC,GACVA,IACAJ,EAAKS,MAAMC,KAAML,IAEjBD,KAnBAD,GAAkB,EACbF,GACJG,IAGDJ,EAAKS,MAAMC,KAAML,GAEhBT,SAASG,GAAI,KACTG,GAAyBE,EAAe,GAC3CJ,EAAKS,MAAMC,KAAML,GAGlBF,GAAkB,EAClBC,EAAe,CAAC,IAQnB,CACD,QAyBO,SAASO,SAASZ,EAAIC,GAM5B,IAAIY,EAEJ,OAPAb,EAAKR,UAAUQ,EAAI,EAAG,OAEtBL,OAAOK,EAAK,EAAG,uCACfL,OAAOF,WAAWQ,GAAO,0CAIlB,WACNY,EAAgBf,WAAWe,EAAeb,GAAI,KAAQC,EAAKS,MAAMC,KAAMJ,MAAMC,KAAKC,WAAW,GAC9F,CACD,QAuBO,SAASK,MAAMb,EAAMc,EAAM,GAMjC,OALAA,EAAQvB,UAAUuB,EAAO,EAAG,OAE5BpB,OAAOF,WAAWQ,GAAO,uCACzBN,OAAOoB,EAAQ,EAAG,uCAEX,WACN,OAAOlB,SAASkB,GAAO,KAAQd,EAAKS,MAAMC,KAAMJ,MAAMC,KAAKC,WAAW,IAAKO,EAC5E,CACD,QA4CO,SAASC,OAAOhB,EAAMiB,EAAS,MACrCA,EAAWxB,cAAcwB,GAAYA,EAAW,CAAC,EAEjDvB,OAAOF,WAAWQ,GAAO,wCAEzB,MACCkB,EAAiBlB,EAAKmB,WAAWC,MAAM,aAAa,GACpDC,EAAWH,EAAiBA,EAAeI,MAAM,KAAKC,KAAIC,GAAW,GAAGA,IAAUC,SAAU,GAK7F,OAFA/B,OAAO2B,EAASK,OAAS,EAAG,6DAAkE1B,EAAKmB,uCAAuCD,MAEnI,WACN,MAAMS,EAAiB,GA2BvB,OAzBArB,MAAMC,KAAKC,WAAWoB,SAAQ,CAACC,EAAKC,MAElCrC,cAAcoC,IAETlC,SAASkC,EAAIb,UAAaa,EAAIb,OAQnCW,EAAeG,GAAYD,EAN3BR,EAASO,SAAQ,CAACJ,EAASO,KACtBpC,SAASkC,EAAIL,MAChBG,EAAeI,GAAgBF,EAAIL,GACpC,GAIF,IAGDH,EAASO,SAAQ,CAACJ,EAASO,MAExBpC,SAASgC,EAAeI,KACtBpC,SAASsB,EAASO,MAErBG,EAAeI,GAAgBd,EAASO,GACzC,IAGMxB,EAAKS,MAAMC,KAAMiB,EACzB,CACD","sourcesContent":["/*!\n * Module Functions\n */\n\n/**\n * @namespace Functions\n */\n\nconst MODULE_NAME = 'Functions';\n\n\n\n//###[ IMPORTS ]########################################################################################################\n\nimport {orDefault, isFunction, isPlainObject, assert, hasValue} from './basic.js';\nimport {schedule, reschedule} from './timers.js';\n\n\n\n//###[ EXPORTS ]########################################################################################################\n\n/**\n * @namespace Functions:throttle\n */\n\n/**\n * Returns a throttled function (based on an unthrottled one), which executes only once in a timeframe at most.\n * This is especially helpful to react to events, that might come in avalanches in an orderly and performant way,\n * let's say changing layout due to a resizing or scrolling event.\n *\n * If you are trying to react to events, that occur a lot, in a synchronous fashion, meaning, that you rely on values\n * and data having been updated after the event, so there is a clear time arrow of things happening in order, you might\n * need to set hasLeadingExecution and/or hasTrailingExecution to true to better cover those cases.\n *\n * Be aware that the precision of this method relies in part on the client's cpu, so this is implementation might\n * not be right if you need a razor sharp exact amount of calls in a given time every time, this is a more simple\n * and fuzzy implementation for basic purposes, which should cover 90% of your needs.\n * For a more precise and battle-tested version, see lodash's complex implementation:\n * https://www.npmjs.com/package/lodash.throttle\n *\n * @param {Number} ms - the timeframe for one execution at most in milliseconds\n * @param {Function} func - the function to throttle\n * @param {?Boolean} [hasLeadingExecution=false] - defines that the function call that starts a timeframe, does not count, so that during the following frame another call is possible\n * @param {?Boolean} [hasTrailingExecution=false] - defines if the function is executed at the end of the timeframe (will only happen, if there were more than one calls to the function in the time frame)\n * @throws error if ms is no number > 0 or func is not a function\n * @returns {Function} the throttling function (parameters will be handed as is to the throttled function)\n *\n * @memberof Functions:throttle\n * @alias throttle\n * @example\n * window.addEventListener('resize', throttle(400, function(){ console.log(`the viewport is now ${window.innerWidth}px wide`); }));\n */\nexport function throttle(ms, func, hasLeadingExecution=false, hasTrailingExecution=false){\n\tms = orDefault(ms, 0, 'int');\n\thasLeadingExecution = orDefault(hasLeadingExecution, false, 'bool');\n\thasTrailingExecution = orDefault(hasTrailingExecution, false, 'bool');\n\n\tassert(ms > 0, `${MODULE_NAME}:throttle | ms must be > 0`);\n\tassert(isFunction(func), `${MODULE_NAME}:throttle | no function given`);\n\n\tlet\n\t\tframeHasStarted = false,\n\t\tcallsInFrame = 0\n\t;\n\n\treturn function(){\n\t\tconst args = Array.from(arguments);\n\n\t\tif( !frameHasStarted ){\n\t\t\tframeHasStarted = true;\n\t\t\tif( !hasLeadingExecution ){\n\t\t\t\tcallsInFrame++;\n\t\t\t}\n\n\t\t\tfunc.apply(this, args);\n\n\t\t\t schedule(ms, () => {\n\t\t\t\tif( hasTrailingExecution && (callsInFrame > 1) ){\n\t\t\t\t\tfunc.apply(this, args);\n\t\t\t\t}\n\n\t\t\t\tframeHasStarted = false;\n\t\t\t\tcallsInFrame = 0;\n\t\t\t});\n\t\t} else if( callsInFrame === 0 ){\n\t\t\tcallsInFrame++;\n\t\t\tfunc.apply(this, args);\n\t\t} else {\n\t\t\tcallsInFrame++;\n\t\t}\n\t};\n}\n\n\n\n/**\n * @namespace Functions:debounce\n */\n\n/**\n * Hold the execution of a function until it has not been called for a specific timeframe.\n *\n * This is a basic implementation for 90% of all cases, if you need more options and more control\n * over details, have a look at lodash's implementation:\n * https://www.npmjs.com/package/lodash.debounce\n *\n * @param {Number} ms - timeframe in milliseconds without call before execution\n * @param {Function} func - the function to delay the execution of\n * @throws error if ms is no number > 0 or func is not a function\n * @returns {Function} the debounced function (parameters will be handed as is to the provided function)\n *\n * @memberof Functions:debounce\n * @alias debounce\n * @example\n * document.querySelector('input[name=search]').addEventListener('change', debounce(1000, function(){ refreshSearch(); }));\n */\nexport function debounce(ms, func){\n\tms = orDefault(ms, 0, 'int');\n\n\tassert(ms > 0, `${MODULE_NAME}:debounce | ms must be > 0`);\n\tassert(isFunction(func), `${MODULE_NAME}:debounce | no function given`);\n\n\tlet\tdebounceTimer;\n\n\treturn function(){\n\t\tdebounceTimer = reschedule(debounceTimer, ms, () => { func.apply(this, Array.from(arguments)); });\n\t};\n}\n\n\n\n/**\n * @namespace Functions:defer\n */\n\n/**\n * Defer the execution of a function until the callstack is empty.\n * This works identical to setTimeout(function(){}, 1);\n *\n * @param {Function} func - the function to defer\n * @param {?Number} [delay=1] - the delay to apply in milliseconds, 1 is a non-minifiable value to target the next tick, but you may define any millisecond value you want, to manually delay the function execution\n * @throws error if func is not a function or delay is no number > 0\n * @returns {Function} the deferred function; the deferred function returns the timer id, in case you want to cancel execution\n *\n * @memberof Functions:defer\n * @alias defer\n * @example\n * defer(function(){ doOnNextTick(); })();\n * defer(function(){ doInTwoSeconds(); }, 2000)();\n */\nexport function defer(func, delay=1){\n\tdelay = orDefault(delay, 1, 'int');\n\n\tassert(isFunction(func), `${MODULE_NAME}:defer | no function given`);\n\tassert(delay > 0, `${MODULE_NAME}:defer | delay must be > 0`);\n\n\treturn function(){\n\t\treturn schedule(delay, () => { func.apply(this, Array.from(arguments)); }).id;\n\t};\n}\n\n\n\n/**\n * @namespace Functions:kwargs\n */\n\n/**\n * This function creates a function where we can set all parameters as a config object by name for each\n * call, while also allowing to set default values for parameters on function creation.\n *\n * This is heavily inspired by Python's way of handling parameters, therefore the name.\n *\n * This enables you to overload complex function signatures with tailor-fit version for your use cases and\n * to call functions with specific parameter sets in a very readable way, without adding empty values to the\n * list of parameters. So you just define what you want to set and those parts are clearly named.\n *\n * Each parameter you pass to the created kwargs function may be one of two variants:\n * - either it is not a plain object; in that case the parameter is passed to the original function as is at the\n *   position the parameter is declared in the call\n * - or the parameter is a plain object, in which case we treat the parameter as kwargs and try to match keys\n *   to parameters; in case you ever have to pass a plain object as-is: setting \"kwargs: false\" in the object\n *   tells the parser to skip matching props to parameters\n *\n * You can even mix these types. If two parameters describe the same value in the call, the last declaration wins.\n *\n * @param {Function} func - the function to provide kwargs to\n * @param {?Object} [defaults=null] - the default kwargs to apply to func, essentially setting default values for all given keys fitting parameters of the function\n * @throws error if func is not a function or parameter names of func could not be identified\n * @returns {Function} new function accepting mixed args, also being possible kwarg dicts\n *\n * @memberof Functions:kwargs\n * @alias kwargs\n * @example\n * const fTest = function(tick, trick, track){ console.log(tick, trick, track); };\n * const fKwargsTest = kwargs(fTest, {track : 'defaultTrack'});\n * fKwargsTest({tick : 'tiick', trick : 'trick'});\n * => \"tiick, trick, defaultTrack\"\n * kwargs(fTest, {track : 'defaultTrack'})('argumentTick', {trick : 'triick', track : 'trACK'});\n * => \"argumentTick, triick, trACK\"\n * kwargs(fTest, {track : 'defaultTrack'})('argumentTick', {trick : 'triick', track : 'track'}, 'trackkkk');\n * => \"argumentTick, triick, trackkkk\"\n */\nexport function kwargs(func, defaults=null){\n\tdefaults = isPlainObject(defaults) ? defaults : {};\n\n\tassert(isFunction(func), `${MODULE_NAME}:kwargs | no function given`);\n\n\tconst\n\t\targNamesString = func.toString().match(/\\(([^)]+)/)[1],\n\t\targNames = argNamesString ? argNamesString.split(',').map(argName => `${argName}`.trim()) : []\n\t;\n\n\tassert(argNames.length > 0, `${MODULE_NAME}:kwargs | could not identify parameter names in \"${func.toString()}\" using parameter string \"${argNamesString}\"`);\n\n\treturn function(){\n\t\tconst applicableArgs = [];\n\n\t\tArray.from(arguments).forEach((arg, argIndex) => {\n\t\t\tif(\n\t\t\t\tisPlainObject(arg)\n\t\t\t\t// if object contains falsy property \"kwargs\" leave it as is\n\t\t\t\t&& (!hasValue(arg.kwargs) || !!arg.kwargs)\n\t\t\t){\n\t\t\t\targNames.forEach((argName, argNameIndex) => {\n\t\t\t\t\tif( hasValue(arg[argName]) ){\n\t\t\t\t\t\tapplicableArgs[argNameIndex] = arg[argName];\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tapplicableArgs[argIndex] = arg;\n\t\t\t}\n\t\t});\n\n\t\targNames.forEach((argName, argNameIndex) => {\n\t\t\tif(\n\t\t\t\t!hasValue(applicableArgs[argNameIndex])\n\t\t\t\t&& hasValue(defaults[argName])\n\t\t\t){\n\t\t\t\tapplicableArgs[argNameIndex] = defaults[argName];\n\t\t\t}\n\t\t});\n\n\t\treturn func.apply(this, applicableArgs);\n\t};\n}\n"]}
{"version":3,"file":"dates.js","names":["MODULE_NAME","hasValue","assert","orDefault","isArray","isDate","isString","isNumber","isInt","isNaN","isObject","isPlainObject","isFunction","pad","DATE_PART_SETTERS_AND_GETTERS","local","year","setter","getter","month","date","hours","minutes","seconds","milliseconds","utc","format","definition","locale","type","options","timeZone","settersAndGetters","predefinedStyles","includes","timezone","offset","getTimezoneOffset","Math","floor","abs","tokenMap","Map","set","slice","replaceAll","formattedDate","forEach","value","token","formatterOptions","dateStyle","timeStyle","concat","Intl","DateTimeFormat","SaneDate","__className__","invalidDateMessage","paramInvalidOrOutOfRangeMessage","constructor","initialValueOrYear","definedIndividualDateParts","hasDefinedIndividualDateParts","Object","values","filter","part","length","this","getVanillaDate","parseIsoString","parseInt","Date","toISOString","toIsoString","getISOString","getIsoString","getTime","createDatePartGettersAndSetters","entries","_","propertyConfig","enumerable","defineProperty","get","tryDatePartChange","getWeekDay","startingWith","asName","weekdays","day","getUTCDay","getDay","indexOf","getTimezone","padWithZero","getIsoDateString","getIsoTimeString","withTimezone","withSeparator","compareTo","initialValueOrSaneDate","withMilliseconds","saneDate","dateCompareGetters","timeCompareGetters","millisecondsCompareGetter","ownValue","compareValue","comparator","compareGetters","compareGetter","isBefore","isAfter","isSame","move","amount","parts","partDict","keys","join","forward","__methodName__","amountMustBePositiveMessage","backward","getDelta","largestUnit","relative","delta","negativeDelta","days","partName","clone","clonedSaneDate","digitCount","isoString","timezoneOffset","isoStringParts","split","isoStringDateParts","isoStringTimezoneParts","offsetFactor","isoStringTimezoneTimeParts","isoStringTimeParts","isoStringSecondsParts","ex","Error","newDate","allDatePartGetters","map","methods","sideEffect","datePartGetter"],"sources":["dates.js"],"mappings":"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","ignoreList":[],"sourcesContent":["/*!\n * Module Dates\n */\n\n/**\n * @namespace Dates\n */\n\nconst MODULE_NAME = 'Dates';\n\n\n\n//###[ IMPORTS ]########################################################################################################\n\nimport {\n\thasValue,\n\tassert,\n\torDefault,\n\tisArray,\n\tisDate,\n\tisString,\n\tisNumber,\n\tisInt,\n\tisNaN,\n\tisObject,\n\tisPlainObject,\n\tisFunction\n} from './basic.js';\n\nimport {pad} from './strings.js';\n\n\n\n//###[ DATA ]###########################################################################################################\n\nconst DATE_PART_SETTERS_AND_GETTERS = {\n\tlocal : {\n\t\tyear : {\n\t\t\tsetter : 'setFullYear',\n\t\t\tgetter : 'getFullYear'\n\t\t},\n\t\tmonth : {\n\t\t\tsetter : 'setMonth',\n\t\t\tgetter : 'getMonth',\n\t\t},\n\t\tdate : {\n\t\t\tsetter : 'setDate',\n\t\t\tgetter : 'getDate',\n\t\t},\n\t\thours : {\n\t\t\tsetter : 'setHours',\n\t\t\tgetter : 'getHours',\n\t\t},\n\t\tminutes : {\n\t\t\tsetter : 'setMinutes',\n\t\t\tgetter : 'getMinutes',\n\t\t},\n\t\tseconds : {\n\t\t\tsetter : 'setSeconds',\n\t\t\tgetter : 'getSeconds',\n\t\t},\n\t\tmilliseconds : {\n\t\t\tsetter : 'setMilliseconds',\n\t\t\tgetter : 'getMilliseconds',\n\t\t},\n\t},\n\tutc : {\n\t\tyear : {\n\t\t\tsetter : 'setUTCFullYear',\n\t\t\tgetter : 'getUTCFullYear',\n\t\t},\n\t\tmonth : {\n\t\t\tsetter : 'setUTCMonth',\n\t\t\tgetter : 'getUTCMonth',\n\t\t},\n\t\tdate : {\n\t\t\tsetter : 'setUTCDate',\n\t\t\tgetter : 'getUTCDate',\n\t\t},\n\t\thours : {\n\t\t\tsetter : 'setUTCHours',\n\t\t\tgetter : 'getUTCHours',\n\t\t},\n\t\tminutes : {\n\t\t\tsetter : 'setUTCMinutes',\n\t\t\tgetter : 'getUTCMinutes',\n\t\t},\n\t\tseconds : {\n\t\t\tsetter : 'setUTCSeconds',\n\t\t\tgetter : 'getUTCSeconds',\n\t\t},\n\t\tmilliseconds : {\n\t\t\tsetter : 'setUTCMilliseconds',\n\t\t\tgetter : 'getUTCMilliseconds',\n\t\t},\n\t}\n};\n\n\n\n//###[ EXPORTS ]########################################################################################################\n\n/**\n * @namespace Dates:format\n */\n\n/**\n * Returns a formatted string, describing the date in a verbose, non-technical way.\n *\n * Under the hood, this uses Intl.DateTimeFormat, which is widely supported and conveniently to use\n * for most widely used locales.\n *\n * \"definition\" may be a format shortcut for \"dateStyle\" (and \"timeStyle\" if type is \"datetime\") or a format string,\n * for a custom format, using these tokens:\n *\n * YY      18         two-digit year;\n * YYYY    2018       four-digit year;\n * M       1-12       the month, beginning at 1;\n * MM      01-12      the month, 2-digits;\n * D       1-31       the day of the month;\n * DD      01-31      the day of the month, 2-digits;\n * H       0-23       the hour;\n * HH      00-23      the hour, 2-digits;\n * h       1-12       the hour, 12-hour clock;\n * hh      01-12      the hour, 12-hour clock, 2-digits;\n * m       0-59       the minute;\n * mm      00-59      the minute, 2-digits;\n * s       0-59       the second;\n * ss      00-59      the second, 2-digits;\n * SSS     000-999    the millisecond, 3-digits;\n * Z       +05:00     the offset from UTC, ±HH:mm;\n * ZZ      +0500      the offset from UTC, ±HHmm;\n * A       AM PM;\n * a       am pm;\n *\n * Using these, you could create your own ISO string like this:\n * \"YYYY-MM-DDTHH:mm:ss.SSSZ\"\n *\n * If you use \"full\", \"long\", \"medium\" or \"short\" instead, you'll use the DateTimeFormatters built-in, preset\n * format styles for localized dates, based on the given locale(s).\n *\n * @param {Date} date - the date to format\n * @param {?String} [definition='long'] - either a preset style to quickly define a format style, by setting shortcuts for dateStyle and timeStyle (if type is \"datetime\"), set to \"none\" or nullish value to skip quick format; alternatively, define this as a format string to use a custom format\n * @param {?String|Array<String>} [locale='en-US'] - locale to use for date format and text generation, use array to define fallback; always falls back to en-US if nothing else works\n * @param {?String} [type='datetime'] - set to 'datetime', 'date' or 'time' to define which parts should be rendered\n * @param {?Object} [options=null] - options to pass to the Intl.DateTimeFormat constructor, is applied last, so should override anything predefined, if key is reset\n * @returns {String} - the formatted date/time string\n *\n * @memberof Dates:format\n * @alias format\n * @variation Dates\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat/DateTimeFormat\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat/DateTimeFormat#style_shortcuts\n * @example\n * format(new Date(), 'de-DE', 'long', 'datetime', {timeZone : 'UTC'})\n * => '12. Dezember 2023 um 02:00:00 UTC'\n * format(new Date(), 'YYYY-MM-DDTHH:mm:ss.SSSZ')\n * => '2023-12-12T02:00:00'\n */\nexport function format(date, definition='long', locale='en-US', type='datetime', options=null){\n\tconst\n\t\tutc = (options?.timeZone === 'UTC'),\n\t\tsettersAndGetters = utc\n\t\t\t? DATE_PART_SETTERS_AND_GETTERS.utc\n\t\t\t: DATE_PART_SETTERS_AND_GETTERS.local\n\t\t,\n\t\tpredefinedStyles = ['full', 'long', 'medium', 'short', 'none']\n\t;\n\n\tif( hasValue(definition) && !predefinedStyles.includes(definition) ){\n\t\tlet timezone = '';\n\t\tconst offset = date.getTimezoneOffset();\n\t\tif( !utc && (offset !== 0) ){\n\t\t\tconst\n\t\t\t\thours = pad(Math.floor(Math.abs(offset) / 60), '0', 2),\n\t\t\t\tminutes = pad(Math.abs(offset) - (hours * 60), '0', 2)\n\t\t\t;\n\t\t\ttimezone = `${(offset < 0) ? '+' : '-'}${hours}:${minutes}`;\n\t\t}\n\n\t\tconst tokenMap = new Map();\n\t\ttokenMap.set('YYYY', `${date[settersAndGetters.year.getter]()}`);\n\t\ttokenMap.set('YY', `${date[settersAndGetters.year.getter]()}`.slice(-2));\n\t\ttokenMap.set('MM', pad(`${date[settersAndGetters.month.getter]() + 1}`, '0', 2));\n\t\ttokenMap.set('M', `${date[settersAndGetters.month.getter]() + 1}`);\n\t\ttokenMap.set('DD', pad(`${date[settersAndGetters.date.getter]()}`, '0', 2));\n\t\ttokenMap.set('D', `${date[settersAndGetters.date.getter]()}`);\n\t\ttokenMap.set('HH', pad(`${date[settersAndGetters.hours.getter]()}`, '0', 2));\n\t\ttokenMap.set('H', `${date[settersAndGetters.hours.getter]()}`);\n\t\ttokenMap.set('hh', pad(`${\n\t\t\t(date[settersAndGetters.hours.getter]() === 0)\n\t\t\t? 12\n\t\t\t: (\n\t\t\t\t(date[settersAndGetters.hours.getter]() > 12)\n\t\t\t\t? date[settersAndGetters.hours.getter]() - 12\n\t\t\t\t: date[settersAndGetters.hours.getter]()\n\t\t\t)\n\t\t}`, '0', 2));\n\t\ttokenMap.set('h', `${\n\t\t\t(date[settersAndGetters.hours.getter]() === 0)\n\t\t\t? 12\n\t\t\t: (\n\t\t\t\t(date[settersAndGetters.hours.getter]() > 12)\n\t\t\t\t? date[settersAndGetters.hours.getter]() - 12\n\t\t\t\t: date[settersAndGetters.hours.getter]()\n\t\t\t)\n\t\t}`);\n\t\ttokenMap.set('mm', pad(`${date[settersAndGetters.minutes.getter]()}`, '0', 2));\n\t\ttokenMap.set('m', `${date[settersAndGetters.minutes.getter]()}`);\n\t\ttokenMap.set('ss', pad(`${date[settersAndGetters.seconds.getter]()}`, '0', 2));\n\t\ttokenMap.set('s', `${date[settersAndGetters.seconds.getter]()}`);\n\t\ttokenMap.set('SSS', pad(`${date[settersAndGetters.milliseconds.getter]()}`, '0', 3));\n\t\ttokenMap.set('ZZ', timezone.replaceAll(':', ''));\n\t\ttokenMap.set('Z', timezone);\n\t\ttokenMap.set('A', `${(date[settersAndGetters.hours.getter]() >= 12) ? 'PM' : 'AM'}`);\n\t\ttokenMap.set('a', `${(date[settersAndGetters.hours.getter]() >= 12) ? 'pm' : 'am'}`);\n\n\t\tlet formattedDate = definition;\n\t\ttokenMap.forEach((value, token) => {\n\t\t\tformattedDate = formattedDate.replaceAll(token, value);\n\t\t});\n\n\t\treturn formattedDate;\n\t} else {\n\t\tlet formatterOptions = {};\n\n\t\tif( predefinedStyles.includes(definition) ){\n\t\t\tif( ['datetime', 'date'].includes(type) ){\n\t\t\t\tformatterOptions.dateStyle = definition;\n\t\t\t}\n\t\t\tif( ['datetime', 'time'].includes(type) ){\n\t\t\t\tformatterOptions.timeStyle = definition;\n\t\t\t}\n\t\t}\n\n\t\tlocale = orDefault(locale, 'en-US');\n\t\tif(\n\t\t\t(!isArray(locale) && (locale !== 'en-US'))\n\t\t\t|| (isArray(locale) && !locale.includes('en-US'))\n\t\t){\n\t\t\tlocale = [].concat(locale).concat('en-US');\n\t\t}\n\n\t\tformatterOptions = {\n\t\t\t...formatterOptions,\n\t\t\t...(options ?? {})\n\t\t};\n\n\t\treturn Intl.DateTimeFormat(locale, formatterOptions).format(date);\n\t}\n\n}\n\n\n\n/**\n * @namespace Dates:SaneDate\n **/\n\n/**\n * SaneDate is a reimplementation of JavaScript date objects, trying to iron out all the small fails\n * which make you want to pull your hair while keeping the cool stuff in a streamlined manner.\n *\n * SaneDates operate between the years 0 and 9999.\n * If you create a new SaneDate, it starts off in local mode, always working and returning local information, but\n * you may activate UTC mode by defining `.utc = true;`.\n *\n * Parsing an ISO string creates a local SaneDate if no timezone is defined, if you define \"Z\" or an offset, the\n * given string is interpreted as UTC info, so \"2012-12-12T12:00:00\" will set all parts as local information,\n * meaning, that the UTC representation may differ according to your timezone, while \"2012-12-12T12:00:00Z\" will\n * set all parts as UTC information, meaning that this is exactly what you get as the UTC representation, but your local\n * info will differ according to your timezone. \"2012-12-12T12:00:00+02:00\" on the other hand, will create UTC\n * information, with a negative offset of two hours, since this says: this datetime is two hours in the UTC future,\n * so the resulting UTC info will be at 10 o'clock, while your local info will behave according to your timezone in\n * regard to that info.\n *\n * The relevant date parts of a SaneDate, which are also available as attributes to get and set are:\n * \"year\", \"month\", \"date\" (not day!), \"hours\", \"minutes\", \"seconds\" and \"milliseconds\".\n *\n * Additionally, set UTC mode, using the \"utc\" property.\n *\n * SaneDates are very exception-happy and won't allow anything, that changes or produces a date in an unexpected\n * manner. All automagic behaviour of JS dates is an error here, so setting a month to 13 and expecting a year jump\n * will not work. Dates are very sensitive information and often used for contractual stuff, so anything coming out\n * differently than you defined it in the first place is very problematic. Every change to any single property triggers\n * a check, if any side effects occurred at all and if the change exactly results in the exact info being represented.\n * Any side effect or misrepresentation results in an exception, since something happened we did not expect or define.\n *\n * Months and week days are not zero based in SaneDates but begin with 1. Week days are not an attribute\n * (and not settable), but accessible via .getWeekDay().\n *\n * This whole implementation is heavily built around iso strings, so building a date with one and getting one\n * to transfer should be forgiving, easy and robust. Something like '1-2-3 4:5:6.7' is a usable iso string\n * for SaneDate, but getIsoString() will return correctly formatted '0001-02-03T04:05:06.700'.\n *\n * See class documentation below for details.\n *\n * @memberof Dates:SaneDate\n * @name SaneDate\n *\n * @see SaneDate\n * @example\n * let date = new SaneDate('1-2-3 4:5:6.7');\n * date = new SaneDate('2016-4-7');\n * date = new SaneDate('2016-04-07 13:37:00');\n * date = new SaneDate(2016, 4, 7);\n * date = new SaneDate(2016, 4, 7, 13, 37, 0, 999);\n * date.year = 2000;\n * date.forward('hours', 42);\n */\nclass SaneDate {\n\n\t#__className__ = 'SaneDate';\n\t#invalidDateMessage = 'invalid date, please check parameters - SaneDate only accepts values that result in a valid date, where the given value is reflected exactly (e.g.: setting hours to 25 will not work)';\n\t#paramInvalidOrOutOfRangeMessage = 'invalid or out of range';\n\t#date = null;\n\t#utc = false;\n\n\t/**\n\t * Creates a new SaneDate, either based on Date.now(), a given initial value or given date parts.\n\t *\n\t * @param {?Date|SaneDate|String|Number|Object} [initialValueOrYear=null] - something, that can be used to construct an initial value, this may be a vanilla Date, a SaneDate, a parsable string, a unix timestamp or an object implementing a method toISOString/toIsoString/getISOString/getIsoString; if this is a number, it will be treated as the year, if any other parameter is set as well; if nullish and all other parameters are not set either, the initial value is Date.now()\n\t * @param {?Number} [month=null] - month between 1 and 12, to set in initial value\n\t * @param {?Number} [date=null] - date between 1 and 31, to set in initial value\n\t * @param {?Number} [hours=null] - hours between 0 and 23, to set in initial value\n\t * @param {?Number} [minutes=null] - minutes between 0 and 59, to set in initial value\n\t * @param {?Number} [seconds=null] - seconds between 0 and 59, to set in initial value\n\t * @param {?Number} [milliseconds=null] - milliseconds between 0 and 999, to set in initial value\n\t * @throws error if created date is invalid\n\t */\n\tconstructor(initialValueOrYear=null, month=null, date=null, hours=null, minutes=null, seconds=null, milliseconds=null){\n\t\tconst __methodName__ = 'constructor';\n\n\t\tlet year = null;\n\t\tconst definedIndividualDateParts = {year, month, date, hours, minutes, seconds, milliseconds};\n\t\tlet hasDefinedIndividualDateParts = Object.values(definedIndividualDateParts).filter(part => isNumber(part)).length >= 1;\n\n\t\tif( initialValueOrYear instanceof SaneDate ){\n\t\t\tthis.#date = initialValueOrYear.getVanillaDate();\n\t\t} else if( isDate(initialValueOrYear) ){\n\t\t\tthis.#date = initialValueOrYear;\n\t\t} else if( isString(initialValueOrYear) ){\n\t\t\tthis.#date = this.#parseIsoString(initialValueOrYear);\n\t\t} else if( isNumber(initialValueOrYear) ){\n\t\t\tif( hasDefinedIndividualDateParts ){\n\t\t\t\tyear = parseInt(initialValueOrYear, 10);\n\t\t\t\tdefinedIndividualDateParts.year = year;\n\t\t\t} else {\n\t\t\t\tthis.#date = new Date(initialValueOrYear);\n\t\t\t}\n\t\t} else if(\n\t\t\tisObject(initialValueOrYear)\n\t\t\t&& (\n\t\t\t\tisFunction(initialValueOrYear.toISOString)\n\t\t\t\t|| isFunction(initialValueOrYear.toIsoString)\n\t\t\t\t|| isFunction(initialValueOrYear.getISOString)\n\t\t\t\t|| isFunction(initialValueOrYear.getIsoString)\n\t\t\t)\n\t\t){\n\t\t\tthis.#date = this.#parseIsoString(\n\t\t\t\tinitialValueOrYear.toISOString?.()\n\t\t\t\t?? initialValueOrYear.toIsoString?.()\n\t\t\t\t?? initialValueOrYear.getISOString?.()\n\t\t\t\t?? initialValueOrYear.getIsoString?.()\n\t\t\t);\n\t\t}\n\n\t\tif( !isDate(this.#date) ){\n\t\t\tthis.#date = hasDefinedIndividualDateParts ? new Date('1970-01-01T00:00:00.0') : new Date();\n\t\t}\n\n\t\tassert(\n\t\t\t!isNaN(this.#date.getTime()),\n\t\t\t`${MODULE_NAME}:${this.#__className__}.${__methodName__} | ${this.#invalidDateMessage}`\n\t\t);\n\n\t\tthis.#createDatePartGettersAndSetters();\n\n\t\tif( hasDefinedIndividualDateParts ){\n\t\t\tObject.entries(definedIndividualDateParts)\n\t\t\t\t.filter(([_, value]) => isNumber(value))\n\t\t\t\t.forEach(([part, value]) => {\n\t\t\t\t\tthis[part] = value;\n\t\t\t\t})\n\t\t\t;\n\t\t}\n\t}\n\n\n\n\t/**\n\t * Creates getters and setters to leisurely access and change date properties by using property assignments\n\t * instead of method calls. This method provides most of the public interface of every SaneDate object.\n\t *\n\t * @private\n\t */\n\t#createDatePartGettersAndSetters(){\n\t\tconst propertyConfig = {\n\t\t\tenumerable : true\n\t\t};\n\n\t\t/**\n\t\t * @name SaneDate#utc\n\t\t * @property {Boolean} - defines if the date should behave as a UTC date instead of a local date (which is the default)\n\t\t */\n\t\tObject.defineProperty(this, 'utc', {\n\t\t\t...propertyConfig,\n\t\t\tset(utc){\n\t\t\t\tthis.#utc = !!utc;\n\t\t\t},\n\t\t\tget(){\n\t\t\t\treturn this.#utc;\n\t\t\t}\n\t\t});\n\n\t\t/**\n\t\t * @name SaneDate#year\n\t\t * @property {Number} - the date's year in the range of 0 to 9999\n\t\t */\n\t\tObject.defineProperty(this, 'year', {\n\t\t\t...propertyConfig,\n\t\t\tset(year){\n\t\t\t\tconst __methodName__ = 'set year';\n\n\t\t\t\tyear = parseInt(year, 10);\n\t\t\t\tassert(\n\t\t\t\t\tisInt(year)\n\t\t\t\t\t&& (year >= 0 && year <= 9999),\n\t\t\t\t\t`${MODULE_NAME}:${this.#__className__}.${__methodName__} | year ${this.#paramInvalidOrOutOfRangeMessage} (0...9999)`\n\t\t\t\t);\n\n\t\t\t\tthis.#tryDatePartChange('year', year);\n\t\t\t},\n\t\t\tget(){\n\t\t\t\tconst settersAndGetters = this.#utc\n\t\t\t\t\t? DATE_PART_SETTERS_AND_GETTERS.utc\n\t\t\t\t\t: DATE_PART_SETTERS_AND_GETTERS.local\n\t\t\t\t;\n\t\t\t\treturn this.#date[settersAndGetters.year.getter]();\n\t\t\t}\n\t\t});\n\n\t\t/**\n\t\t * @name SaneDate#month\n\t\t * @property {Number} - the date's month in the range of 1 to 12\n\t\t */\n\t\tObject.defineProperty(this, 'month', {\n\t\t\t...propertyConfig,\n\t\t\tset(month){\n\t\t\t\tconst __methodName__ = 'set month';\n\n\t\t\t\tmonth = parseInt(month, 10);\n\t\t\t\tassert(\n\t\t\t\t\tisInt(month)\n\t\t\t\t\t&& (month >= 1 && month <= 12),\n\t\t\t\t\t`${MODULE_NAME}:${this.#__className__}.${__methodName__} | month ${this.#paramInvalidOrOutOfRangeMessage} (1...12)`\n\t\t\t\t);\n\n\t\t\t\tthis.#tryDatePartChange('month', month - 1);\n\t\t\t},\n\t\t\tget(){\n\t\t\t\tconst settersAndGetters = this.#utc\n\t\t\t\t\t? DATE_PART_SETTERS_AND_GETTERS.utc\n\t\t\t\t\t: DATE_PART_SETTERS_AND_GETTERS.local\n\t\t\t\t;\n\t\t\t\treturn this.#date[settersAndGetters.month.getter]() + 1;\n\t\t\t}\n\t\t});\n\n\t\t/**\n\t\t * @name SaneDate#date\n\t\t * @property {Number} - the date's day of the month in the range of 1 to 31\n\t\t */\n\t\tObject.defineProperty(this, 'date', {\n\t\t\t...propertyConfig,\n\t\t\tset(date){\n\t\t\t\tconst __methodName__ = 'set date';\n\n\t\t\t\tdate = parseInt(date, 10);\n\t\t\t\tassert(\n\t\t\t\t\tisInt(date)\n\t\t\t\t\t&& (date >= 1 && date <= 31),\n\t\t\t\t\t`${MODULE_NAME}:${this.#__className__}.${__methodName__} | date ${this.#paramInvalidOrOutOfRangeMessage} (1...31)`\n\t\t\t\t);\n\n\t\t\t\tthis.#tryDatePartChange('date', date);\n\t\t\t},\n\t\t\tget(){\n\t\t\t\tconst settersAndGetters = this.#utc\n\t\t\t\t\t? DATE_PART_SETTERS_AND_GETTERS.utc\n\t\t\t\t\t: DATE_PART_SETTERS_AND_GETTERS.local\n\t\t\t\t;\n\t\t\t\treturn this.#date[settersAndGetters.date.getter]();\n\t\t\t}\n\t\t});\n\n\t\t/**\n\t\t * @name SaneDate#hours\n\t\t * @property {Number} - the date's hours in the range of 0 to 23\n\t\t */\n\t\tObject.defineProperty(this, 'hours',{\n\t\t\tset(hours){\n\t\t\t\tconst __methodName__ = 'set hours';\n\n\t\t\t\thours = parseInt(hours, 10);\n\t\t\t\tassert(\n\t\t\t\t\tisInt(hours)\n\t\t\t\t\t&& (hours >= 0 && hours <= 23),\n\t\t\t\t\t`${MODULE_NAME}:${this.#__className__}.${__methodName__} | hours ${this.#paramInvalidOrOutOfRangeMessage} (0...23)`\n\t\t\t\t);\n\n\t\t\t\tthis.#tryDatePartChange('hours', hours);\n\t\t\t},\n\t\t\tget(){\n\t\t\t\tconst settersAndGetters = this.#utc\n\t\t\t\t\t? DATE_PART_SETTERS_AND_GETTERS.utc\n\t\t\t\t\t: DATE_PART_SETTERS_AND_GETTERS.local\n\t\t\t\t;\n\t\t\t\treturn this.#date[settersAndGetters.hours.getter]();\n\t\t\t}\n\t\t});\n\n\t\t/**\n\t\t * @name SaneDate#minutes\n\t\t * @property {Number} - the date's minutes in the range of 0 to 59\n\t\t */\n\t\tObject.defineProperty(this, 'minutes', {\n\t\t\tset(minutes){\n\t\t\t\tconst __methodName__ = 'set hours';\n\n\t\t\t\tminutes = parseInt(minutes, 10);\n\t\t\t\tassert(\n\t\t\t\t\tisInt(minutes)\n\t\t\t\t\t&& (minutes >= 0 && minutes <= 59),\n\t\t\t\t\t`${MODULE_NAME}:${this.#__className__}.${__methodName__} | minutes ${this.#paramInvalidOrOutOfRangeMessage} (0...59)`\n\t\t\t\t);\n\n\t\t\t\tthis.#tryDatePartChange('minutes', minutes);\n\t\t\t},\n\t\t\tget(){\n\t\t\t\tconst settersAndGetters = this.#utc\n\t\t\t\t\t? DATE_PART_SETTERS_AND_GETTERS.utc\n\t\t\t\t\t: DATE_PART_SETTERS_AND_GETTERS.local\n\t\t\t\t;\n\t\t\t\treturn this.#date[settersAndGetters.minutes.getter]();\n\t\t\t}\n\t\t});\n\n\t\t/**\n\t\t * @name SaneDate#seconds\n\t\t * @property {Number} - the date's seconds in the range of 0 to 59\n\t\t */\n\t\tObject.defineProperty(this, 'seconds', {\n\t\t\tset(seconds){\n\t\t\t\tconst __methodName__ = 'set seconds';\n\n\t\t\t\tseconds = parseInt(seconds, 10);\n\t\t\t\tassert(\n\t\t\t\t\tisInt(seconds)\n\t\t\t\t\t&& (seconds >= 0 && seconds <= 59),\n\t\t\t\t\t`${MODULE_NAME}:${this.#__className__}.${__methodName__} | seconds ${this.#paramInvalidOrOutOfRangeMessage} (0...59)`\n\t\t\t\t);\n\n\t\t\t\tthis.#tryDatePartChange('seconds', seconds);\n\t\t\t},\n\t\t\tget(){\n\t\t\t\tconst settersAndGetters = this.#utc\n\t\t\t\t\t? DATE_PART_SETTERS_AND_GETTERS.utc\n\t\t\t\t\t: DATE_PART_SETTERS_AND_GETTERS.local\n\t\t\t\t;\n\t\t\t\treturn this.#date[settersAndGetters.seconds.getter]();\n\t\t\t}\n\t\t});\n\n\t\t/**\n\t\t * @name SaneDate#milliseconds\n\t\t * @property {Number} - the date's milliseconds in the range of 0 to 999\n\t\t */\n\t\tObject.defineProperty(this, 'milliseconds', {\n\t\t\tset(milliseconds){\n\t\t\t\tconst __methodName__ = 'set milliseconds';\n\n\t\t\t\tmilliseconds = parseInt(milliseconds, 10);\n\t\t\t\tassert(\n\t\t\t\t\tisInt(milliseconds)\n\t\t\t\t\t&& (milliseconds >= 0 && milliseconds <= 999),\n\t\t\t\t\t`${MODULE_NAME}:${this.#__className__}.${__methodName__} | milliseconds ${this.#paramInvalidOrOutOfRangeMessage} (0...999)`\n\t\t\t\t);\n\n\t\t\t\tthis.#tryDatePartChange('milliseconds', milliseconds);\n\t\t\t},\n\t\t\tget(){\n\t\t\t\tconst settersAndGetters = this.#utc\n\t\t\t\t\t? DATE_PART_SETTERS_AND_GETTERS.utc\n\t\t\t\t\t: DATE_PART_SETTERS_AND_GETTERS.local\n\t\t\t\t;\n\t\t\t\treturn this.#date[settersAndGetters.milliseconds.getter]();\n\t\t\t}\n\t\t});\n\t}\n\n\n\n\t/**\n\t * Returns the current day of the week as a number between 1 and 7 or an english day name.\n\t * This method counts days the European way, starting with monday, but you can change this\n\t * behaviour using the first parameter (if your week starts with sunday or friday for example).\n\t *\n\t * @param {?String} [startingWith='monday'] - set to the english day, which is the first day of the week (monday, tuesday, wednesday, thursday, friday, saturday, sunday)\n\t * @param {?Boolean} [asName=false] - set to true, if you'd like the method to return english day names instead of an index\n\t * @returns {Number|String} weekday index between 1 and 7 or english name of the day\n\t *\n\t * @example\n\t * const d = new SaneDate();\n\t * if( d.getWeekDay() == 5 ){\n\t *   alert(`Thank god it's ${d.getWeekday(null, true)}!`);\n\t * }\n\t */\n\tgetWeekDay(startingWith='monday', asName=false){\n\t\tconst __methodName__ = 'getWeekDay';\n\n\t\tconst weekdays = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];\n\t\tstartingWith = orDefault(startingWith, weekdays[1], 'str');\n\t\tassert(\n\t\t\tweekdays.includes(startingWith),\n\t\t\t`${MODULE_NAME}:${this.#__className__}.${__methodName__} | unknown weekday \"${startingWith}\"`\n\t\t);\n\n\t\tlet day = this.#utc ? this.#date.getUTCDay() : this.#date.getDay();\n\t\tif( asName ) return weekdays[day];\n\n\t\tconst offset = day - weekdays.indexOf(startingWith);\n\t\tif( offset < 0 ){\n\t\t\tday = 7 + offset;\n\t\t} else {\n\t\t\tday = offset;\n\t\t}\n\n\t\treturn day + 1;\n\t}\n\n\n\n\t/**\n\t * Returns the date's current timezone, like it would occur in an ISO-string (\"Z\", \"+06:00\", \"-02:30\").\n\t *\n\t * If you need the raw offset, use the vanilla date's getTimezoneOffset() method.\n\t *\n\t * @returns {String} - the timezone string\n\t *\n\t * @example\n\t * const d = new SaneDate()\n\t * d.getTimezone()\n\t * => \"+09:30\"\n\t */\n\tgetTimezone(){\n\t\tif( this.#utc ) return 'Z';\n\n\t\tconst offset = this.#date.getTimezoneOffset();\n\n\t\tif( offset === 0 ){\n\t\t\treturn 'Z';\n\t\t} else {\n\t\t\tconst\n\t\t\t\thours = this.#padWithZero(Math.floor(Math.abs(offset) / 60), 2),\n\t\t\t\tminutes = this.#padWithZero(Math.abs(offset) - (hours * 60), 2)\n\t\t\t;\n\t\t\treturn `${(offset < 0) ? '+' : '-'}${hours}:${minutes}`;\n\t\t}\n\t}\n\n\n\n\t/**\n\t * Returns the representation of the date's current date parts (year, month, day) as an ISO-string.\n\t *\n\t * A difference to the vanilla implementation is, that this method respects UTC mode and does not always\n\t * coerce the date to UTC automatically. So, this will return a local ISO representation if not in UTC mode\n\t * and the UTC representation in UTC mode.\n\t *\n\t * @returns {String} date ISO-string of the format \"2016-04-07\"\n\t *\n\t * @example\n\t * const d = new SaneDate();\n\t * thatDatePicker.setValue(d.getIsoDateString());\n\t */\n\tgetIsoDateString(){\n\t\tconst\n\t\t\tyear = this.#padWithZero(this.year, 4),\n\t\t\tmonth = this.#padWithZero(this.month, 2),\n\t\t\tdate = this.#padWithZero(this.date, 2)\n\t\t;\n\n\t\treturn `${year}-${month}-${date}`;\n\t}\n\n\n\n\t/**\n\t * Returns the representation of the date's current time parts (hours, minutes, seconds, milliseconds) as an\n\t * ISO-string.\n\t *\n\t * A difference to the vanilla implementation is, that this method respects UTC mode and does not always\n\t * coerce the date to UTC automatically. So, this will return a local ISO representation (optionally with\n\t * timezone information in relation to UTC) if not in UTC mode and the UTC representation in UTC mode.\n\t *\n\t * @param {?Boolean} [withTimezone=true] - defines if the ISO string should end with timezone information, such as \"Z\" or \"+02:00\"\n\t * @returns {String} time ISO-string of the format \"12:59:00.123Z\"\n\t *\n\t * @example\n\t * const d = new SaneDate();\n\t * thatDatePicker.setValue(`2023-12-12T${d.getIsoTimeString()}`);\n\t */\n\tgetIsoTimeString(withTimezone=true){\n\t\twithTimezone = orDefault(withTimezone, true, 'bool');\n\n\t\tconst\n\t\t\thours = this.#padWithZero(this.hours, 2),\n\t\t\tminutes = this.#padWithZero(this.minutes, 2),\n\t\t\tseconds = this.#padWithZero(this.seconds, 2),\n\t\t\tmilliseconds = this.#padWithZero(this.milliseconds, 3),\n\t\t\ttimezone = this.getTimezone()\n\t\t;\n\n\t\treturn `${hours}:${minutes}:${seconds}${(milliseconds > 0) ? '.'+milliseconds : ''}${withTimezone ? timezone : ''}`;\n\t}\n\n\n\n\t/**\n\t * Returns the date as an ISO-string.\n\t *\n\t * A difference to the vanilla implementation is, that this method respects UTC mode and does not always\n\t * coerce the date to UTC automatically. So, this will return a local ISO representation (optionally with\n\t * timezone information in relation to UTC) if not in UTC mode and the UTC representation in UTC mode.\n\t *\n\t * @param {?Boolean} [withSeparator=true] - defines if date and time should be separated with a \"T\"\n\t * @param {?Boolean} [withTimezone=true] - defines if the ISO string should end with timezone information, such as \"Z\" or \"+02:00\"\n\t * @returns {String} ISO-string of the format \"2016-04-07T13:37:00.222Z\"\n\t *\n\t * @example\n\t * const d = new SaneDate();\n\t * thatDateTimePicker.setValue(d.getIsoString());\n\t */\n\tgetIsoString(withSeparator=true, withTimezone=true){\n\t\twithSeparator = orDefault(withSeparator, true, 'bool');\n\n\t\treturn `${this.getIsoDateString()}${withSeparator ? 'T' : ' '}${this.getIsoTimeString(withTimezone)}`;\n\t}\n\n\n\n\t/**\n\t * Returns a formatted string, describing the current date in a verbose, human-readable, non-technical way.\n\t *\n\t * \"definition\" may be a format shortcut for \"dateStyle\" (and \"timeStyle\" if type is \"datetime\") or a format string,\n\t * for a custom format, using these tokens:\n\t *\n\t * YY      18         two-digit year;\n\t * YYYY    2018       four-digit year;\n\t * M       1-12       the month, beginning at 1;\n\t * MM      01-12      the month, 2-digits;\n\t * D       1-31       the day of the month;\n\t * DD      01-31      the day of the month, 2-digits;\n\t * H       0-23       the hour;\n\t * HH      00-23      the hour, 2-digits;\n\t * h       1-12       the hour, 12-hour clock;\n\t * hh      01-12      the hour, 12-hour clock, 2-digits;\n\t * m       0-59       the minute;\n\t * mm      00-59      the minute, 2-digits;\n\t * s       0-59       the second;\n\t * ss      00-59      the second, 2-digits;\n\t * SSS     000-999    the millisecond, 3-digits;\n\t * Z       +05:00     the offset from UTC, ±HH:mm;\n\t * ZZ      +0500      the offset from UTC, ±HHmm;\n\t * A       AM PM;\n\t * a       am pm;\n\t *\n\t * Using these, you could create your own ISO string like this:\n\t * \"YYYY-MM-DDTHH:mm:ss.SSSZ\"\n\t *\n\t * If you use \"full\", \"long\", \"medium\" or \"short\" instead, you'll use the DateTimeFormatters built-in, preset\n\t * format styles for localized dates, based on the given locale(s).\n\t *\n\t * @param {?String} [definition='long'] - either a preset style to quickly define a format style, by setting shortcuts for dateStyle and timeStyle (if type is \"datetime\"), set to \"none\" or nullish value to skip quick format; alternatively, define this as a format string to use a custom format\n\t * @param {?String|Array<String>} [locale='en-US'] - locale to use for date format and text generation, use array to define fallback; always falls back to en-US if nothing else works\n\t * @param {?String} [type='datetime'] - set to 'datetime', 'date' or 'time' to define which parts should be rendered\n\t * @param {?Object} [options=null] - options to pass to the Intl.DateTimeFormat constructor, is applied last, so should override anything predefined, if key is reset\n\t * @returns {String} - the formatted date/time string\n\t *\n\t * @see format(Dates)\n\t * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat/DateTimeFormat\n\t * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat/DateTimeFormat#style_shortcuts\n\t * @example\n\t * const d = new SaneDate();\n\t * d.format('de-DE', 'long', 'datetime', {timeZone : 'UTC'})\n\t * => '12. Dezember 2023 um 02:00:00 UTC'\n\t * d.format('YYYY-MM-DDTHH:mm:ss.SSSZ')\n\t * => '2023-12-12T02:00:00'\n\t */\n\tformat(definition='long', locale='en-US', type='datetime', options=null){\n\t\toptions = orDefault(options, {});\n\n\t\tif( !hasValue(options.timeZone) && this.#utc ){\n\t\t\toptions.timeZone = 'UTC';\n\t\t}\n\n\t\treturn format(this.#date, definition, locale, type, options);\n\t}\n\n\n\n\t/**\n\t * Return the current original JavaScript date object wrapped by SaneDate.\n\t * Use this to do special things.\n\t *\n\t * @returns {Date} the original JavaScript date object\n\t *\n\t * @example\n\t * const d = new SaneDate();\n\t * const timezoneOffset = d.getVanillaDate().getTimezoneOffset();\n\t */\n\tgetVanillaDate(){\n\t\treturn this.#date;\n\t}\n\n\n\n\t/**\n\t * Compares the date to another date in terms of placement on the time axis.\n\t *\n\t * Returns a classical comparator value (-1/0/1), being -1 if the date is earlier than the parameter.\n\t * Normally checks date and time. Set type to \"date\" to only check date.\n\t *\n\t * @param {?Date|SaneDate|String|Number|Object|SaneDate} initialValueOrSaneDate - anything compatible to the SaneDate constructor or a SaneDate instance\n\t * @param {?String} [type='datetime'] - either \"datetime\" or \"date\", telling the method if time should be considered\n\t * @param {?Boolean} [withMilliseconds=true] - tells the method if milliseconds should be considered if type is \"datetime\"\n\t * @throws error if compare date is not usable\n\t * @returns {Number} -1 if this date is smaller/earlier, 0 if identical, 1 if this date is bigger/later\n\t *\n\t * @example\n\t * const d = new SaneDate();\n\t * if( d.compareTo('2016-04-07', 'date') === 0 ){\n\t *   alert('congratulations, that\\'s the same date!');\n\t * }\n\t */\n\tcompareTo(initialValueOrSaneDate, type='datetime', withMilliseconds=true){\n\t\ttype = orDefault(type, 'datetime', 'string');\n\t\twithMilliseconds = orDefault(withMilliseconds, true, 'bool');\n\n\t\tconst\n\t\t\tsaneDate = new SaneDate(initialValueOrSaneDate),\n\t\t\tdateCompareGetters = [\n\t\t\t\tDATE_PART_SETTERS_AND_GETTERS.utc.year.getter,\n\t\t\t\tDATE_PART_SETTERS_AND_GETTERS.utc.month.getter,\n\t\t\t\tDATE_PART_SETTERS_AND_GETTERS.utc.date.getter,\n\t\t\t],\n\t\t\ttimeCompareGetters = [\n\t\t\t\tDATE_PART_SETTERS_AND_GETTERS.utc.hours.getter,\n\t\t\t\tDATE_PART_SETTERS_AND_GETTERS.utc.minutes.getter,\n\t\t\t\tDATE_PART_SETTERS_AND_GETTERS.utc.seconds.getter,\n\t\t\t],\n\t\t\tmillisecondsCompareGetter = DATE_PART_SETTERS_AND_GETTERS.utc.milliseconds.getter\n\t\t;\n\n\t\tlet compareGetters = [].concat(dateCompareGetters);\n\t\tif( type === 'datetime' ){\n\t\t\tcompareGetters = compareGetters.concat(timeCompareGetters);\n\t\t\tif( withMilliseconds ){\n\t\t\t\tcompareGetters = compareGetters.concat(millisecondsCompareGetter);\n\t\t\t}\n\t\t}\n\n\t\tlet ownValue, compareValue, comparator;\n\t\tfor( const compareGetter of compareGetters ){\n\t\t\townValue = this.#date[compareGetter]();\n\t\t\tcompareValue = saneDate.getVanillaDate()[compareGetter]();\n\t\t\tcomparator = (ownValue < compareValue)\n\t\t\t\t? -1\n\t\t\t\t: ((ownValue > compareValue) ? 1 : 0)\n\t\t\t;\n\n\t\t\tif( comparator !== 0 ){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn comparator;\n\t}\n\n\n\n\t/**\n\t * Returns if the SaneDate is earlier on the time axis than the comparison value.\n\t *\n\t * @param {?Date|SaneDate|String|Number|Object|SaneDate} initialValueOrSaneDate - anything compatible to the SaneDate constructor or a SaneDate instance\n\t * @param {?String} [type='datetime'] - either \"datetime\" or \"date\", telling the method if time should be considered\n\t * @param {?Boolean} [withMilliseconds=true] - tells the method if milliseconds should be considered if type is \"datetime\"\n\t * @throws error if compare date is not usable\n\t * @returns {Boolean} true if SaneDate is earlier than compare value\n\t *\n\t * @example\n\t * const now = new SaneDate();\n\t * const theFuture = now.clone().forward({days : 1, hours : 2, minutes : 3, seconds : 4, milliseconds : 5});\n\t * now.isBefore(theFuture)\n\t * => true\n\t * theFuture.isBefore(now)\n\t * => false\n\t */\n\tisBefore(initialValueOrSaneDate, type='datetime', withMilliseconds=true){\n\t\treturn this.compareTo(initialValueOrSaneDate, type, withMilliseconds) === -1;\n\t}\n\n\n\n\t/**\n\t * Returns if the SaneDate is later on the time axis than the comparison value.\n\t *\n\t * @param {?Date|SaneDate|String|Number|Object|SaneDate} initialValueOrSaneDate - anything compatible to the SaneDate constructor or a SaneDate instance\n\t * @param {?String} [type='datetime'] - either \"datetime\" or \"date\", telling the method if time should be considered\n\t * @param {?Boolean} [withMilliseconds=true] - tells the method if milliseconds should be considered if type is \"datetime\"\n\t * @throws error if compare date is not usable\n\t * @returns {Boolean} true if SaneDate is later than compare value\n\t *\n\t * @example\n\t * const now = new SaneDate();\n\t * const theFuture = now.clone().forward({days : 1, hours : 2, minutes : 3, seconds : 4, milliseconds : 5});\n\t * now.isAfter(theFuture)\n\t * => false\n\t * theFuture.isAfter(now)\n\t * => true\n\t */\n\tisAfter(initialValueOrSaneDate, type='datetime', withMilliseconds=true){\n\t\treturn this.compareTo(initialValueOrSaneDate, type, withMilliseconds) === 1;\n\t}\n\n\n\n\t/**\n\t * Returns if the SaneDate is at the same time as comparison value.\n\t *\n\t * @param {?Date|SaneDate|String|Number|Object|SaneDate} initialValueOrSaneDate - anything compatible to the SaneDate constructor or a SaneDate instance\n\t * @param {?String} [type='datetime'] - either \"datetime\" or \"date\", telling the method if time should be considered\n\t * @param {?Boolean} [withMilliseconds=true] - tells the method if milliseconds should be considered if type is \"datetime\"\n\t * @throws error if compare date is not usable\n\t * @returns {Boolean} true if SaneDate is at the same time as compare value\n\t *\n\t * @example\n\t * const now = new SaneDate();\n\t * const theFuture = now.clone();\n\t * now.isSame(theFuture)\n\t * => true\n\t * theFuture.forward({days : 1, hours : 2, minutes : 3, seconds : 4, milliseconds : 5});\n\t * theFuture.isSame(now)\n\t * => false\n\t */\n\tisSame(initialValueOrSaneDate, type='datetime', withMilliseconds=true){\n\t\treturn this.compareTo(initialValueOrSaneDate, type, withMilliseconds) === 0;\n\t}\n\n\n\n\t/**\n\t * Move the date a defined offset to the past or the future.\n\t *\n\t * @param {String|Object} part - the name of the date part to change, one of \"years\", \"months\", \"days\", \"hours\", \"minutes\", \"seconds\" and \"milliseconds\" or a dictionary of part/amount pairs ({hours : -1, seconds : 30})\n\t * @param {?Number} [amount=0] - negative or positive integer defining the offset from the current date\n\t * @throws error on invalid part name\n\t * @returns {SaneDate} the SaneDate instance\n\t *\n\t * @example\n\t * let d = new SaneDate();\n\t * d = d.move('years', 10).move('milliseconds', -1);\n\t */\n\tmove(part, amount=0){\n\t\tconst __methodName__ = 'move;'\n\n\t\tamount = orDefault(amount, 0, 'int');\n\n\t\tconst\n\t\t\tsettersAndGetters = DATE_PART_SETTERS_AND_GETTERS.utc,\n\t\t\tparts = ['years', 'months', 'days', 'hours', 'minutes', 'seconds', 'milliseconds']\n\t\t;\n\t\tlet partDict = {};\n\n\t\tif( !isPlainObject(part) ){\n\t\t\tpartDict[part] = amount;\n\t\t} else {\n\t\t\tpartDict = part;\n\t\t}\n\n\t\tObject.keys(partDict).forEach(part => {\n\t\t\tassert(\n\t\t\t\tparts.includes(part),\n\t\t\t\t`${MODULE_NAME}:${this.#__className__}.${__methodName__} | part must be one of ${parts.join(', ')}, is \"${part}\"`\n\t\t\t);\n\t\t});\n\n\t\tObject.entries(partDict).forEach(([part, amount]) => {\n\t\t\tswitch( part ){\n\t\t\t\tcase 'years':\n\t\t\t\t\tthis.#date[settersAndGetters.year.setter](this.#date[settersAndGetters.year.getter]() + amount);\n\t\t\t\tbreak;\n\n\t\t\t\tcase 'months':\n\t\t\t\t\tthis.#date[settersAndGetters.month.setter](this.#date[settersAndGetters.month.getter]() + amount);\n\t\t\t\tbreak;\n\n\t\t\t\tcase 'days':\n\t\t\t\t\tthis.#date[settersAndGetters.date.setter](this.#date[settersAndGetters.date.getter]() + amount);\n\t\t\t\tbreak;\n\n\t\t\t\tcase 'hours':\n\t\t\t\t\tthis.#date[settersAndGetters.hours.setter](this.#date[settersAndGetters.hours.getter]() + amount);\n\t\t\t\tbreak;\n\n\t\t\t\tcase 'minutes':\n\t\t\t\t\tthis.#date[settersAndGetters.minutes.setter](this.#date[settersAndGetters.minutes.getter]() + amount);\n\t\t\t\tbreak;\n\n\t\t\t\tcase 'seconds':\n\t\t\t\t\tthis.#date[settersAndGetters.seconds.setter](this.#date[settersAndGetters.seconds.getter]() + amount);\n\t\t\t\tbreak;\n\n\t\t\t\tcase 'milliseconds':\n\t\t\t\t\tthis.#date[settersAndGetters.milliseconds.setter](this.#date[settersAndGetters.milliseconds.getter]() + amount);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t});\n\n\t\treturn this;\n\t}\n\n\n\n\t/**\n\t * Moves the date's time forward a certain offset.\n\t *\n\t * @param {String|Object} part - the name of the date part to change, one of \"years\", \"months\", \"days\", \"hours\", \"minutes\", \"seconds\" and \"milliseconds\" or a dictionary of part/amount pairs ({hours : 1, seconds : 30})\n\t * @param {?Number} [amount=0] - integer defining the positive offset from the current date, negative value is treated as an error\n\t * @throws error on invalid part name or negative amount\n\t * @returns {SaneDate} the SaneDate instance\n\t *\n\t * @example\n\t * let d = new SaneDate();\n\t * d = d.forward('hours', 8);\n\t */\n\tforward(part, amount=0){\n\t\tconst\n\t\t\t__methodName__ = 'forward',\n\t\t\tamountMustBePositiveMessage = 'amount must be >= 0'\n\t\t;\n\n\t\tpart = `${part}`;\n\t\tamount = orDefault(amount, 0, 'int');\n\n\t\tlet partDict = {};\n\t\tif( !isPlainObject(part) ){\n\t\t\tassert(\n\t\t\t\tamount >= 0,\n\t\t\t\t`${MODULE_NAME}:${this.#__className__}.${__methodName__} | ${amountMustBePositiveMessage}`\n\t\t\t);\n\t\t\tpartDict[part] = amount;\n\t\t} else {\n\t\t\tpartDict = part;\n\t\t\tObject.entries(partDict).forEach(([part, amount]) => {\n\t\t\t\tamount = parseInt(amount, 10);\n\t\t\t\tassert(\n\t\t\t\t\tamount >= 0,\n\t\t\t\t\t`${MODULE_NAME}:${this.#__className__}.${__methodName__} | ${amountMustBePositiveMessage}`\n\t\t\t\t);\n\t\t\t\tpartDict[part] = amount;\n\t\t\t});\n\t\t}\n\n\t\treturn this.move(partDict);\n\t}\n\n\n\n\t/**\n\t * Moves the date's time backward a certain offset.\n\t *\n\t * @param {String|Object} part - the name of the date part to change, one of \"years\", \"months\", \"days\", \"hours\", \"minutes\", \"seconds\" and \"milliseconds\" or a dictionary of part/amount pairs ({hours : 1, seconds : 30})\n\t * @param {?Number} [amount=0] - integer defining the negative offset from the current date, negative value is treated as an error\n\t * @throws error on invalid part name or negative amount\n\t * @returns {SaneDate} the SaneDate instance\n\t *\n\t * @example\n\t * let d = new SaneDate();\n\t * d = d.backward('years', 1000);\n\t */\n\tbackward(part, amount=0){\n\t\tconst\n\t\t\t__methodName__ = 'backward',\n\t\t\tamountMustBePositiveMessage = 'amount must be >= 0'\n\t\t;\n\n\t\tpart = `${part}`;\n\t\tamount = orDefault(amount, 0, 'int');\n\n\t\tlet partDict = {};\n\t\tif( !isPlainObject(part) ){\n\t\t\tassert(\n\t\t\t\tamount >= 0,\n\t\t\t\t`${MODULE_NAME}:${this.#__className__}.${__methodName__} | ${amountMustBePositiveMessage}`\n\t\t\t);\n\t\t\tpartDict[part] = (amount === 0) ? 0 : -amount;\n\t\t} else {\n\t\t\tpartDict = part;\n\t\t\tObject.entries(partDict).forEach(([part, amount]) => {\n\t\t\t\tassert(\n\t\t\t\t\tamount >= 0,\n\t\t\t\t\t`${MODULE_NAME}:${this.#__className__}.${__methodName__} | ${amountMustBePositiveMessage}`\n\t\t\t\t);\n\t\t\t\tpartDict[part] = (amount === 0) ? 0 : -amount;\n\t\t\t});\n\t\t}\n\n\t\treturn this.move(partDict);\n\t}\n\n\n\n\t/**\n\t * Calculates a time delta between the SaneDate and a comparison value.\n\t *\n\t * The result is a plain object with the delta's units up to the defined \"largestUnit\". All values are integers.\n\t * The largest unit is days, since above neither months nor years are calculable via a fixed divisor and therefore\n\t * useless (since month vary from 28 to 31 days and years vary between 365 and 366 days, so both are not a fixed\n\t * unit).\n\t *\n\t * By default, the order does not matter and only the absolute value is used, but you can change this\n\t * through the parameter \"relative\", which by setting this to true, will include \"-\", if the comparison value\n\t * is in the future.\n\t *\n\t * @param {?Date|SaneDate|String|Number|Object|SaneDate} initialValueOrSaneDate - anything compatible to the SaneDate constructor or a SaneDate instance\n\t * @param {?String} [largestUnit='days'] - the largest time unit to differentiate in the result\n\t * @param {?Boolean} [relative=false] - if true, returns negative values if first parameter is later than this date (this adheres to the order defined by compareTo)\n\t * @throws error on unknown largestUnit or incompatible comparison value\n\t * @returns {Object} time delta object in the format {days : 1, hours : 2, minutes : 3, seconds : 4, milliseconds : 5} (keys depending on largestUnit)\n\t *\n\t * @example\n\t * const now = new SaneDate();\n\t * const theFuture = now.clone().forward({days : 1, hours : 2, minutes : 3, seconds : 4, milliseconds : 5});\n\t * now.getDelta(theFuture)\n\t * => {days : 1, hours : 2, minutes : 3, seconds : 4, milliseconds : 5}\n\t * now.getDelta(theFuture, 'hours', true)\n\t * => {hours : -26, minutes : -3, seconds : -4, milliseconds : -5}\n\t */\n\tgetDelta(initialValueOrSaneDate, largestUnit='days', relative=false){\n\t\tconst __methodName__ = 'getDelta';\n\n\t\tconst saneDate = new SaneDate(initialValueOrSaneDate);\n\t\tlargestUnit = orDefault(largestUnit, 'days', 'string');\n\t\tassert(\n\t\t\t['days', 'hours', 'minutes', 'seconds', 'milliseconds'].includes(largestUnit),\n\t\t\t`${MODULE_NAME}:${this.#__className__}.${__methodName__} | unknown largest unit`\n\t\t);\n\t\trelative = orDefault(relative, false, 'bool');\n\n\t\tconst parts = {};\n\t\tlet delta = relative\n\t\t\t? (this.#date.getTime() - saneDate.#date.getTime())\n\t\t\t: Math.abs(this.#date.getTime() - saneDate.#date.getTime())\n\t\t;\n\t\tconst negativeDelta = delta < 0;\n\t\tdelta = Math.abs(delta);\n\n\t\tif( largestUnit === 'days' ){\n\t\t\tparts.days = Math.floor(delta / 1000 / 60 / 60 / 24);\n\t\t\tdelta -= parts.days * 1000 * 60 * 60 * 24;\n\t\t\tlargestUnit = 'hours';\n\t\t}\n\n\t\tif( largestUnit === 'hours' ){\n\t\t\tparts.hours = Math.floor(delta / 1000 / 60 / 60);\n\t\t\tdelta -= parts.hours * 1000 * 60 * 60;\n\t\t\tlargestUnit = 'minutes';\n\t\t}\n\n\t\tif( largestUnit === 'minutes' ){\n\t\t\tparts.minutes = Math.floor(delta / 1000 / 60);\n\t\t\tdelta -= parts.minutes * 1000 * 60;\n\t\t\tlargestUnit = 'seconds';\n\t\t}\n\n\t\tif( largestUnit === 'seconds' ){\n\t\t\tparts.seconds = Math.floor(delta / 1000);\n\t\t\tdelta -= parts.seconds * 1000;\n\t\t\tlargestUnit = 'milliseconds';\n\t\t}\n\n\t\tif( largestUnit === 'milliseconds' ){\n\t\t\tparts.milliseconds = delta;\n\t\t}\n\n\t\tif( negativeDelta ){\n\t\t\tfor( const partName in parts ){\n\t\t\t\tparts[partName] = (parts[partName] === 0) ? 0 : -parts[partName];\n\t\t\t}\n\t\t}\n\n\t\treturn parts;\n\t}\n\n\n\n\t/**\n\t * Returns a copy of the current SaneDate.\n\t * Might be very handy for creating dates based on another with an offset for example.\n\t * Keeps UTC mode.\n\t *\n\t * @returns {SaneDate} copy of current SaneDate instance\n\t *\n\t * @example\n\t * const d = new SaneDate();\n\t * const theFuture = d.clone().forward('hours', 8);\n\t **/\n\tclone(){\n\t\tconst clonedSaneDate = new SaneDate(new Date(this.getVanillaDate().getTime()));\n\t\tclonedSaneDate.utc = this.#utc;\n\t\treturn clonedSaneDate;\n\t}\n\n\n\n\t/**\n\t * Adds leading zeroes to values, which are not yet of a defined expected length.\n\t *\n\t * @param {*} value - the value to pad\n\t * @param {?Number} [digitCount=2] - the number of digits, the result has to have at least\n\t * @returns {String} the padded value, will always be cast to a string\n\t *\n\t * @private\n\t * @example\n\t * this.#padWithZero(1, 4)\n\t * => '0001'\n\t */\n\t#padWithZero(value, digitCount=2){\n\t\treturn pad(value, '0', digitCount);\n\t}\n\n\n\n\t/**\n\t * Tries to parse an ISO string (or at least, something resembling an ISO string) into a date.\n\t *\n\t * The basic idea of this method is, that it is supposed to be fairly forgiving, as long as the info is there,\n\t * even in a little wonky notation, this should result in a successfully created SaneDate.\n\t *\n\t * @param {String} isoString - something resembling an ISO string, that we can create a date from\n\t * @throws error if isoString is not usable\n\t * @returns {Date} the date create from the given ISO string\n\t *\n\t * @private\n\t * @example\n\t * this.#parseIsoString('2018-02-28T13:37:00')\n\t * this.#parseIsoString('1-2-3 4:5:6.7')\n\t */\n\t#parseIsoString(isoString){\n\t\tconst\n\t\t\t__methodName__ = '#parseIsoString',\n\t\t\tunparsableIsoStringMessage = 'ISO string not parsable'\n\t\t;\n\n\t\tisoString = `${isoString}`;\n\n\t\tlet\n\t\t\tyear = 1970,\n\t\t\tmonth = 1,\n\t\t\tdate = 1,\n\t\t\thours = 0,\n\t\t\tminutes = 0,\n\t\t\tseconds = 0,\n\t\t\tmilliseconds = 0,\n\t\t\ttimezoneOffset = 0,\n\t\t\tutc = false\n\t\t;\n\n\t\tlet isoStringParts = isoString.split('T');\n\t\tif( isoStringParts.length === 1 ){\n\t\t\tisoStringParts = isoStringParts[0].split(' ');\n\t\t}\n\n\n\t\t// date parts\n\n\t\tconst isoStringDateParts = isoStringParts[0].split('-');\n\t\tyear = isoStringDateParts[0];\n\t\tif( isoStringDateParts.length >= 2 ){\n\t\t\tmonth = isoStringDateParts[1];\n\t\t}\n\t\tif( isoStringDateParts.length >= 3 ){\n\t\t\tdate = isoStringDateParts[2];\n\t\t}\n\n\n\t\t// time parts\n\n\t\tif( isoStringParts.length >= 2 ){\n\t\t\t// timezone\n\n\t\t\tlet\tisoStringTimezoneParts = isoStringParts[1].split('Z');\n\t\t\tif( isoStringTimezoneParts.length >= 2 ){\n\t\t\t\tutc = true;\n\t\t\t} else {\n\t\t\t\tlet offsetFactor = 0;\n\t\t\t\tif( isoStringTimezoneParts[0].includes('+') ){\n\t\t\t\t\toffsetFactor = -1;\n\t\t\t\t\tisoStringTimezoneParts = isoStringTimezoneParts[0].split('+');\n\t\t\t\t} else if( isoStringTimezoneParts[0].includes('-') ){\n\t\t\t\t\toffsetFactor = 1;\n\t\t\t\t\tisoStringTimezoneParts = isoStringTimezoneParts[0].split('-');\n\t\t\t\t}\n\n\t\t\t\tif( isoStringTimezoneParts.length >= 2 ){\n\t\t\t\t\tconst isoStringTimezoneTimeParts = isoStringTimezoneParts[1].split(':');\n\n\t\t\t\t\tif( isoStringTimezoneTimeParts.length >= 2 ){\n\t\t\t\t\t\ttimezoneOffset += parseInt(isoStringTimezoneTimeParts[0], 10) * 60;\n\t\t\t\t\t\ttimezoneOffset += parseInt(isoStringTimezoneTimeParts[1], 10);\n\t\t\t\t\t} else if( isoStringTimezoneTimeParts[0].length >= 3 ){\n\t\t\t\t\t\ttimezoneOffset += parseInt(isoStringTimezoneTimeParts[0].slice(0, 2), 10) * 60;\n\t\t\t\t\t\ttimezoneOffset += parseInt(isoStringTimezoneTimeParts[1].slice(2), 10);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttimezoneOffset += parseInt(isoStringTimezoneTimeParts[0], 10) * 60;\n\t\t\t\t\t}\n\t\t\t\t\ttimezoneOffset *= offsetFactor;\n\n\t\t\t\t\tassert(\n\t\t\t\t\t\t!isNaN(timezoneOffset),\n\t\t\t\t\t\t`${MODULE_NAME}:${this.#__className__}.${__methodName__} | invalid timezone \"${isoStringTimezoneParts[1]}\"`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\t// hours and minutes\n\t\t\tconst isoStringTimeParts = isoStringTimezoneParts[0].split(':');\n\t\t\thours = isoStringTimeParts[0];\n\t\t\tif( isoStringTimeParts.length >= 2 ){\n\t\t\t\tminutes = isoStringTimeParts[1];\n\t\t\t}\n\n\n\t\t\t// seconds and milliseconds\n\n\t\t\tif( isoStringTimeParts.length >= 3 ){\n\t\t\t\tconst isoStringSecondsParts = isoStringTimeParts[2].split('.');\n\n\t\t\t\tseconds = isoStringSecondsParts[0];\n\n\t\t\t\tif( isoStringSecondsParts.length >= 2 ){\n\t\t\t\t\tmilliseconds = isoStringSecondsParts[1];\n\n\t\t\t\t\tif( milliseconds.length > 3 ){\n\t\t\t\t\t\tmilliseconds = milliseconds.slice(0, 3);\n\t\t\t\t\t} else if( milliseconds.length === 2 ){\n\t\t\t\t\t\tmilliseconds = `${parseInt(milliseconds, 10) * 10}`;\n\t\t\t\t\t} else if( milliseconds.length === 1 ){\n\t\t\t\t\t\tmilliseconds = `${parseInt(milliseconds, 10) * 100}`;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\t// date construction\n\n\t\tconst saneDate = new SaneDate();\n\t\tsaneDate.utc = utc || (timezoneOffset !== 0);\n\t\ttry {\n\t\t\tsaneDate.year = year;\n\t\t\tsaneDate.month = month;\n\t\t\tsaneDate.date = date;\n\t\t\tsaneDate.hours = hours;\n\t\t\tsaneDate.minutes = minutes;\n\t\t\tsaneDate.seconds = seconds;\n\t\t\tsaneDate.milliseconds = milliseconds;\n\t\t} catch(ex){\n\t\t\tthrow Error(`${MODULE_NAME}:${this.#__className__}.${__methodName__} | ${unparsableIsoStringMessage} \"${isoString}\"`);\n\t\t}\n\t\tsaneDate.move('minutes', timezoneOffset);\n\n\t\treturn saneDate.getVanillaDate();\n\t}\n\n\n\n\t/**\n\t * Tries to change a part of the date and makes sure, that this change does not trigger automagic and only\n\t * leads to exactly the change, we wanted to do and nothing else.\n\t *\n\t * @param {String} part - the date part to change, one of: year, month, date, hours, minutes, seconds or milliseconds\n\t * @param {Number} value - the new value to set\n\t * @returns {SaneDate} the SaneDate instance\n\t *\n\t * @private\n\t */\n\t#tryDatePartChange(part, value){\n\t\tconst __methodName__ = '#tryDatePartChange';\n\n\t\tconst\n\t\t\tnewDate = this.clone().getVanillaDate(),\n\t\t\tsettersAndGetters = this.#utc\n\t\t\t\t? DATE_PART_SETTERS_AND_GETTERS.utc\n\t\t\t\t: DATE_PART_SETTERS_AND_GETTERS.local\n\t\t\t,\n\t\t\tallDatePartGetters = Object.values(settersAndGetters).map(methods => methods.getter)\n\t\t;\n\n\t\tnewDate[settersAndGetters[part].setter](value);\n\n\t\tlet sideEffect = false;\n\t\tfor( const datePartGetter of allDatePartGetters ){\n\t\t\tif( datePartGetter !== settersAndGetters[part].getter){\n\t\t\t\tsideEffect ||= this.#date[datePartGetter]() !== newDate[datePartGetter]();\n\t\t\t}\n\n\t\t\tif( sideEffect ){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tassert(\n\t\t\t(newDate[settersAndGetters[part].getter]() === value) && !sideEffect,\n\t\t\t`${MODULE_NAME}:${this.#__className__}.${__methodName__} | date part change \"${part} = ${value}\" is invalid or has side effects`\n\t\t);\n\n\t\tthis.#date = newDate;\n\n\t\treturn this;\n\t}\n\n}\n\nexport {SaneDate};\n"]}
{"version":3,"file":"elements.js","names":["MODULE_NAME","orDefault","isA","isPlainObject","hasValue","assert","size","randomUuid","clone","NOT_AN_HTMLELEMENT_ERROR","BROWSER_HAS_CSS_SCOPE_SUPPORT","document","querySelector","ex","createNode","tag","attributes","content","trim","outerNode","createElement","test","innerHTML","appendChild","node","firstChild","removeChild","attribute","setAttribute","textContent","insertNode","target","position","insertAdjacentElement","replaceNode","__methodName__","parentNode","getTextContent","onlyFirstLevel","childNodes","forEach","nodeType","isInDom","contains","body","getData","properties","data","property","attributeValue","getAttribute","JSON","parse","Array","from","name","startsWith","replace","value","length","setData","dataSet","singleValue","singleKey","appliedValues","Object","entries","undefined","stringifiedValue","getValue","stringify","hasAttribute","removeAttribute","removeData","keys","reduce","removalDataSet","find","selector","onlyOne","scopeRex","querySelectorAll","fallbackScopeAttribute","found","findOne","findTextNodes","filter","isValidTextNode","extractTextNodes","concat","textNodes","childNode","measureHiddenDimensions","method","context","methods","offset","width","height","outer","client","inner","scroll","sandbox","id","class","style","measureClone","dimensions","toString"],"sources":["elements.js"],"mappings":"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","sourcesContent":["/*!\n * Module Elements\n */\n\n/**\n * @namespace Elements\n */\n\nconst MODULE_NAME = 'Elements';\n\n\n\n//###[ IMPORTS ]########################################################################################################\n\nimport {orDefault, isA, isPlainObject, hasValue, assert, size} from './basic.js';\nimport {randomUuid} from './random.js';\nimport {clone} from './objects.js';\n\n\n\n//###[ DATA ]###########################################################################################################\n\nconst NOT_AN_HTMLELEMENT_ERROR = 'given node/target is not an HTMLElement';\nlet BROWSER_HAS_CSS_SCOPE_SUPPORT;\ntry {\n\tdocument.querySelector(':scope *');\n} catch(ex){\n\tBROWSER_HAS_CSS_SCOPE_SUPPORT = false;\n}\n\n\n\n//###[ EXPORTS ]########################################################################################################\n\n/**\n * @namespace Elements:createNode\n */\n\n/**\n * Creates an element on the fly programmatically, based on provided name, attributes and content or markup,\n * without inserting it into the DOM.\n *\n * If you provide markup as \"tag\", make sure that there is one single root element, this method returns exactly one\n * element, not a NodeList. Also be sure to _not_ just pass HTML source from an unsecure source, since this\n * method does not deal with potential security risks.\n *\n * One thing about dynamically creating script tags with this: if you want the script is javascript and you want to\n * actually execute the script upon adding it to the dom, you cannot provide the complete tag as a source string,\n * since scripts created with innerHTML will not execute.\n * (see: https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML#security_considerations)\n * Instead, just provide the tag name and define attributes and source via the parameters instead.\n *\n * @param {?String} [tag='span'] - tag of the element to create or markup for root element\n * @param {?Object} [attributes=null] - tag attributes as key/value-pairs, will also be added to provided markup\n * @param {?String} [content=null] - content to insert into the element as textContent, be aware, that this will replace other content in provided markup\n * @returns {HTMLElement} the created DOM-node\n *\n * @memberof Elements:createNode\n * @alias createNode\n * @example\n * document.body.appendChild(\n *   createNode('div', {id : 'content', style : 'display:none;'}, 'loading...')\n * );\n * document.body.appendChild(\n *   createNode('<div id=\"content\" style=\"display:none;\">loading...</div>')\n * );\n * document.body.appendChild(\n *   createNode('script', {type : 'text/javascript'}, 'alert(\"Hello World\");');\n * );\n */\nexport function createNode(tag, attributes=null, content=null){\n\ttag = orDefault(tag, 'span', 'str').trim();\n\tattributes = isPlainObject(attributes) ? attributes : null;\n\tcontent = orDefault(content, null, 'str');\n\n\t// using anything more generic like template results in non-standard nodes like\n\t// <script type=\"text/json\"> not being creatable\n\tconst outerNode = document.createElement('div');\n\n\tif(\n\t\t/^<[^\\/][^<>]*>/.test(tag)\n\t\t&& /<\\/[^<>\\/]+>$/.test(tag)\n\t){\n\t\t// using DOMParser results in non-standard nodes like\n\t\t// <script type=\"text/json\"> not being creatable\n\t\touterNode.innerHTML = tag;\n\t} else {\n\t\touterNode.appendChild(document.createElement(tag));\n\t}\n\n\tconst node = outerNode.firstChild;\n\touterNode.removeChild(node);\n\n\tif( hasValue(attributes) ){\n\t\tfor( let attribute in attributes ){\n\t\t\tnode.setAttribute(attribute, `${attributes[attribute]}`);\n\t\t}\n\t}\n\n\tif( hasValue(content) ){\n\t\tnode.textContent = content;\n\t}\n\n\treturn node;\n}\n\n\n\n/**\n * @namespace Elements:insertNode\n */\n\n/**\n * Inserts a node into the DOM in relation to a target element.\n *\n * If the node is not an element, the parameter is treated as source and a node is created\n * automatically based on that.\n *\n * The position can be determined with the same values as in \"insertAdjacentElement\"\n * (see: https://developer.mozilla.org/en-US/docs/Web/API/Element/insertAdjacentElement),\n * but we also added the more intuitive jQuery aliases for positions:\n *\n * - \"beforebegin\" can also be described as \"before\"\n * - \"afterbegin\" can also be described as \"prepend\"\n * - \"beforeend\" can also be described as \"append\"\n * - \"afterend\" can also be descrived as \"after\"\n *\n * @param {HTMLElement} target - the element to which the node will be inserted in relation to\n * @param {HTMLElement|String} node - the node to insert, either as element or source string\n * @param {?String} [position='beforeend'] - the position to insert the node in relation to target, the default value appends the node as the last child in target\n * @throws error if target is not an HTMLElement\n * @returns {HTMLElement} the inserted DOM-node\n *\n * @memberof Elements:insertNode\n * @alias insertNode\n * @example\n * insertNode(document.querySelector('.list-container'), listItemElement);\n * insertNode(document.querySelector('.list-container'), '<li>Item 42</li>', 'prepend');\n */\nexport function insertNode(target, node, position='beforeend'){\n\tconst __methodName__ = 'insertNode';\n\n\tassert(isA(target, 'htmlelement'), `${MODULE_NAME}.${__methodName__} | ${NOT_AN_HTMLELEMENT_ERROR}`);\n\n\tif( !isA(node, 'htmlelement') ){\n\t\tnode = createNode(`${node}`);\n\t}\n\n\tswitch( position ){\n\t\tcase 'beforebegin':\n\t\tcase 'before':\n\t\t\tposition = 'beforebegin';\n\t\tbreak;\n\t\tcase 'afterend':\n\t\tcase 'after':\n\t\t\tposition = 'afterend';\n\t\tbreak;\n\t\tcase 'afterbegin':\n\t\tcase 'prepend':\n\t\t\tposition = 'afterbegin';\n\t\tbreak;\n\t\tcase 'beforeend':\n\t\tcase 'append':\n\t\t\tposition = 'beforeend';\n\t\tbreak;\n\t\tdefault:\n\t\t\tposition = 'beforeend';\n\t\tbreak;\n\t}\n\n\ttarget.insertAdjacentElement(position, node);\n\n\treturn node;\n}\n\n\n\n/**\n * @namespace Elements:replaceNode\n */\n\n/**\n * Replaces a node with another one.\n *\n * If the node is not an element, the parameter is treated as source and a node is created\n * automatically based on that.\n *\n * The target node needs a parent node for this function to work.\n *\n * @param {HTMLElement} target - the element to replace\n * @param {HTMLElement|String} node - the node to replace the target with\n * @throws error if target is not an HTMLElement or does not have a parent\n * @returns {HTMLElement} the replacement node\n *\n * @memberof Elements:replaceNode\n * @alias replaceNode\n * @example\n * replaceNode(document.querySelector('.hint'), newHintElement);\n * replaceNode(document.querySelector('.hint'), '<p class=\"hint\">Sale tomorrow!</p>');\n */\nexport function replaceNode(target, node){\n\tconst __methodName__ = 'replaceNode';\n\n\tassert(isA(target, 'htmlelement'), `${MODULE_NAME}.${__methodName__} | ${NOT_AN_HTMLELEMENT_ERROR}`);\n\n\tif( !isA(node, 'htmlelement') ){\n\t\tnode = createNode(`${node}`);\n\t}\n\n\tassert(isA(target.parentNode, 'htmlelement'), `${MODULE_NAME}.${__methodName__} | given target does not have a parent)`);\n\n\tinsertNode(target, node, 'after');\n\ttarget.parentNode.removeChild(target);\n\n\treturn node;\n}\n\n\n\n/**\n * @namespace Elements:getTextContent\n */\n\n/**\n * Return the de-nodified text content of a node-ridden string or a DOM-node.\n * Returns the raw text content, with all markup cleanly removed.\n * Can also be used to return only the concatenated child text nodes.\n *\n * @param {(String|Node)} target - the node-ridden string or DOM-node to \"clean\"\n * @param {?Boolean} [onlyFirstLevel=false] - true if only the text of direct child text nodes is to be returned\n * @throws error if target is neither markup nor node\n * @returns {String} the text content of the provided markup or node\n *\n * @memberof Elements:getTextContent\n * @alias getTextContent\n * @example\n * someElement.textContent = getTextContent('<p onlick=\"destroyWorld();\">red button <a>meow<span>woof</span></a></p>');\n */\nexport function getTextContent(target, onlyFirstLevel=false){\n\tconst __methodName__ = 'getTextContent';\n\n\tonlyFirstLevel = orDefault(onlyFirstLevel, false, 'bool');\n\n\tif( isA(target, 'string') ){\n\t\ttarget = createNode(target);\n\t}\n\n\tassert(isA(target, 'htmlelement'), `${MODULE_NAME}:${__methodName__} | target is neither node nor markup`);\n\n\tif( onlyFirstLevel ){\n\t\tlet textContent = '';\n\n\t\ttarget.childNodes.forEach(node => {\n\t\t\tif( node.nodeType === 3 ){\n\t\t\t\ttextContent += node.textContent;\n\t\t\t}\n\t\t});\n\n\t\treturn textContent;\n\t} else {\n\t\treturn target.textContent;\n\t}\n}\n\n\n\n/**\n * @namespace Elements:isInDom\n */\n\n/**\n * Returns if an element is currently part of the DOM or in a detached state.\n *\n * @param {HTMLElement} node - the element to check, whether it is currently in the dom or detached\n * @throws error if node is not a usable HTML element\n * @returns {Boolean} true if the element is part of the DOM at the moment\n *\n * @memberof Elements:isInDom\n * @alias isInDom\n * @example\n * if( !isInDom(el) ){\n *     elementMetaInformation.delete(el);\n * }\n */\nexport function isInDom(node){\n\tconst __methodName__ = 'isInDom';\n\n\tassert(isA(node, 'htmlelement'), `${MODULE_NAME}:${__methodName__} | ${NOT_AN_HTMLELEMENT_ERROR}`);\n\n\treturn isA(document.contains, 'function') ? document.contains(node) : document.body.contains(node);\n}\n\n\n\n/**\n * @namespace Elements:getData\n */\n\n/**\n * Returns the element's currently set data attribute value(s).\n *\n * This method has two major differences from the standard browser dataset-implementations:\n * 1. Property names are _not_ handled camel-cased in any way.\n *    The data attribute `data-my-naughty-dog` property does _not_ magically become `myNaughtyDog` on access,\n *    but keeps the original notation, just losing the prefix, so access it, by using `my-naughty-dog`\n * 2. All property values are treated as JSON first and foremost, falling back to string values, if the\n *    value is not parsable. This means, that `{\"foo\" : \"bar\"}` becomes an object, `[1, 2, 3]` becomes an array,\n *    `42` becomes a number, `true` becomes a boolean and `null` becomes a null-value. But `foobar` actually becomes\n *    the string \"foobar\". JSON-style double quotes are removed, when handling a single string.\n *\n * Keep in mind that things like `new Date()` will not work out of the box, since this is not included in the JSON\n * standard, but has to be serialized/deserialized.\n *\n * @param {HTMLElement} node - the element to read data from\n * @param {?String|Array<String>} [properties=null] - if set, returns value(s) of that specific property/properties (single value for exactly one property, dictionary for multiple), if left out, all properties are returned as a dictionary object\n * @throws error if node is not a usable HTML element\n * @returns {*|Object|null} JSON-parsed attribute value(s) with string fallback; either a single value for exactly one property, a dictionary of values for multiple or a call without properties (meaning all) or null, in case no data was found\n *\n * @memberof Elements:getData\n * @alias getData\n * @see setData\n * @see removeData\n * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/dataset\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse\n * @example\n * getData(createNode('<div data-my-naughty-dog=\"42\"></div>'), 'my-naughty-dog')\n * => 42\n * getData(createNode('<div data-my-naughty-dog='{\"foo\" : [1, \"two\", true]}'></div>'), 'my-naughty-dog')\n * => {\"foo\" : [1, \"two\", true]}\n * getData(createNode('<div data-my-naughty-dog='1, \"two\", true'></div>'), 'my-naughty-dog')\n * => '1, \"two\", true'\n * getData(createNode('<div data-my-naughty-dog=\"42\" data-foo=\"true\" data-bar=\"test\"></div>'), ['foo', 'bar'])\n * => {\"foo\" : true, \"bar\" : \"test\"}\n * getData(createNode('<div data-my-naughty-dog=\"42\" data-foo=\"true\" data-bar=\"test\"></div>'))\n * => {\"my-naughty-dog\" : 42,\"foo\" : true, \"bar\" : \"test\"}\n */\nexport function getData(node, properties=null){\n\tconst __methodName__ = 'getData';\n\n\tproperties = orDefault(properties, null, 'arr');\n\n\tassert(isA(node, 'htmlelement'), `${MODULE_NAME}:${__methodName__} | ${NOT_AN_HTMLELEMENT_ERROR}`);\n\n\tlet data = {};\n\n\tif( hasValue(properties) ){\n\t\tproperties.forEach(property => {\n\t\t\tlet attributeValue = node.getAttribute(`data-${property}`);\n\t\t\tif( hasValue(attributeValue) ){\n\t\t\t\ttry {\n\t\t\t\t\tdata[property] = JSON.parse(attributeValue);\n\t\t\t\t} catch(ex){\n\t\t\t\t\tdata[property] = attributeValue;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t} else {\n\t\tArray.from(node.attributes).forEach(attribute => {\n\t\t\tif( attribute.name.startsWith('data-') ){\n\t\t\t\tconst property = attribute.name.replace(/^data-/, '');\n\t\t\t\ttry {\n\t\t\t\t\tdata[property] = JSON.parse(attribute.value);\n\t\t\t\t} catch(ex){\n\t\t\t\t\tdata[property] = attribute.value;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tif( size(data) === 0 ){\n\t\tdata = null;\n\t} else if( (properties?.length === 1) ){\n\t\tdata = data[properties[0]] ?? null;\n\t}\n\n\treturn data;\n}\n\n\n\n/**\n * @namespace Elements:setData\n */\n\n/**\n * Writes data to an element, by setting data-attributes.\n *\n * Setting a value of `undefined` or an empty string removes the attribute.\n *\n * This method has two major differences from the standard browser dataset-implementations:\n * 1. Property names are _not_ handled camel-cased in any way.\n *    The data attribute `my-naughty-dog` property is _not_ magically created from `myNaughtyDog`,\n *    but the original notation will be kept, just adding the prefix, so set `data-my-naughty-dog`\n *    by using `my-naughty-dog`\n * 2. All property values are treated as JSON first and foremost, falling back to basic string values, if the\n *    value is not stringifiable as JSON. If the top-level value ends up to be a simple JSON string like '\"foo\"'\n *    or \"'foo'\", the double quotes are removed before writing the value.\n *\n * Keep in mind that things like `new Date()` will not work out of the box, since this is not included in the JSON\n * standard, but has to be serialized/deserialized.\n *\n * @param {HTMLElement} node - the element to write data to\n * @param {Object<String,*>|String} dataSet - the data to write to the element, properties have to be exact data-attribute names without the data-prefix, values are stringified (first with JSON.stringify and then as-is as a fallback), if value is a function it gets executed and the return value will be used from there on; if this is a string, this defines a single property to set, with the singleValue being the value to set\n * @param {?*} [singleValue=null] - if you only want to set exactly one property, you may set dataSet to the property name as a string and provide the value via this parameter instead\n * @throws error if node is not a usable HTML element or if dataSet is not a plain object if no single value has been given\n * @returns {Object<String,*>|*|null} the value(s) actually written to the element's data-attributes as they would be returned by getData (removed attributes are marked with `undefined`); null will be returned if nothing was changed; if only a single value was set, only that value will be returned\n *\n * @memberof Elements:setData\n * @alias setData\n * @see getData\n * @see removeData\n * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/dataset\n * @example\n * setData(element, {foobar : 'hello kittens!'});\n * => {foobar : 'hello kittens!'}\n * setData(element, 'foobar', 'hello kittens!');\n * => 'hello kittens!'\n * setData(element, {foobar : {a : 'foo', b : [1, 2, 3], c : {d : true}}});\n * => {foobar : {a : 'foo', b : [1, 2, 3], c : {d : true}}}\n * setData(element, 'foobar', {a : 'foo', b : [1, 2, 3], c : {d : true}});\n * => {a : 'foo', b : [1, 2, 3], c : {d : true}}\n * setData(element, {foobar : () => { return 'hello kittens!'; }});\n * => {foobar : 'hello kittens!'}\n * setData(element, {foobar : undefined});\n * => {foobar : undefined}\n * setData(element, boofar, '');\n * => undefined\n */\nexport function setData(node, dataSet, singleValue=null){\n\tconst __methodName__ = 'setData';\n\n\tassert(isA(node, 'htmlelement'), `${MODULE_NAME}:${__methodName__} | ${NOT_AN_HTMLELEMENT_ERROR}`);\n\n\tlet singleKey = null;\n\tif( hasValue(singleValue) ){\n\t\tsingleKey = `${dataSet}`;\n\t\tdataSet = {\n\t\t\t[singleKey] : singleValue\n\t\t};\n\t}\n\n\tassert(isPlainObject(dataSet), `${MODULE_NAME}:${__methodName__} | dataSet is not a plain object`);\n\n\tconst appliedValues = {};\n\n\tObject.entries(dataSet).forEach(([property, value]) => {\n\t\tif( isA(value, 'function') ){\n\t\t\tvalue = value();\n\t\t}\n\n\t\tif( value !== undefined ){\n\t\t\tlet stringifiedValue, getValue;\n\t\t\ttry {\n\t\t\t\tstringifiedValue = JSON.stringify(value);\n\t\t\t\tgetValue = JSON.parse(stringifiedValue);\n\t\t\t} catch(ex){\n\t\t\t\tstringifiedValue = `${value}`;\n\t\t\t\tgetValue = stringifiedValue;\n\t\t\t}\n\t\t\tstringifiedValue = stringifiedValue.replace(/^['\"]/, '').replace(/['\"]$/, '').trim();\n\n\t\t\tif( stringifiedValue !== '' ){\n\t\t\t\tappliedValues[property] = getValue;\n\t\t\t\tnode.setAttribute(`data-${property}`, stringifiedValue);\n\t\t\t} else if( node.hasAttribute(`data-${property}`) ){\n\t\t\t\tappliedValues[property] = undefined;\n\t\t\t\tnode.removeAttribute(`data-${property}`);\n\t\t\t}\n\t\t} else if( node.hasAttribute(`data-${property}`) ){\n\t\t\tappliedValues[property] = undefined;\n\t\t\tnode.removeAttribute(`data-${property}`);\n\t\t}\n\t});\n\n\tif( hasValue(singleKey) ){\n\t\treturn (singleKey in appliedValues) ?  appliedValues[singleKey] : null;\n\t} else {\n\t\treturn (size(appliedValues) > 0) ? appliedValues : null;\n\t}\n}\n\n\n\n/**\n * @namespace Elements:removeData\n */\n\n/**\n * Removes data from an element, by removing corresponding data-attributes.\n *\n * This method has a major difference from the standard browser dataset-implementations:\n * Property names are _not_ handled camel-cased in any way.\n * The data attribute's `my-naughty-dog` property is _not_ magically created from `myNaughtyDog`,\n * but the original notation will be kept, just adding the prefix,\n * so use `my-naughty-dog` to remove `data-my-naughty-dog`\n *\n * @param {HTMLElement} node - the element to remove data from\n * @param {?String|Array<String>} [properties=null] - if set, removes specified property/properties, if left out, all data properties are removed\n * @throws error if node is not a usable HTML element\n * @returns {*|Object<String,*>|null} the removed data values as they would be returned from getData (single value for one property, dictionaries for multiple or all) or null if nothing was removed\n *\n * @memberof Elements:removeData\n * @alias removeData\n * @see getData\n * @see setData\n * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/dataset\n * @example\n * const testNode = createNode(`<span data-foobar=\"test\" data-boofar=\"null\" data-baz='{\"a\" : [\"1\", 2, 3.3], \"b\" : true}'></span>`)\n * removeData(testNode, 'foobar')\n * => 'test' (testNode.outerHTML === `<span data-boofar=\"null\" data-baz='{\"a\" : [\"1\", 2, 3.3], \"b\" : true}'></span>`)\n * removeData(testNode, ['foobar', 'baz', 'test'])\n * => {foobar : 'test', baz : {\"a\" : [\"1\", 2, 3.3], \"b\" : true}} (testNode.outerHTML === `<span data-boofar=\"null\"></span>`)\n * removeData(testNode)\n * => {foobar : 'test', boofar : null, baz : {\"a\" : [\"1\", 2, 3.3], \"b\" : true}} (testNode.outerHTML === `<span></span>`)\n * removeData(testNode, 'test')\n * => null\n */\nexport function removeData(node, properties=null){\n\tconst __methodName__ = 'removeData';\n\n\tproperties = orDefault(properties, null, 'arr');\n\n\tassert(isA(node, 'htmlelement'), `${MODULE_NAME}:${__methodName__} | ${NOT_AN_HTMLELEMENT_ERROR}`);\n\n\tlet data = getData(node, properties);\n\tif( hasValue(data) ){\n\t\tif( properties?.length === 1 ){\n\t\t\tsetData(node, {[properties[0]] : undefined});\n\t\t} else {\n\t\t\tsetData(node, Object.keys(data).reduce((removalDataSet, property) => {\n\t\t\t\tremovalDataSet[property] = undefined;\n\t\t\t\treturn removalDataSet;\n\t\t\t}, {}));\n\t\t}\n\t} else {\n\t\tdata = null;\n\t}\n\n\treturn data;\n}\n\n\n\n/**\n * @namespace Elements:find\n */\n\n/**\n * Searches for and returns descendant nodes of a given node matching a CSS selector, just as querySelector(All).\n *\n * The main difference to querySelector(All) is, that this method automatically scopes the query, making sure, that the\n * given selector is actually fulfilled _inside_ the scope of the base element and not always regarding the whole\n * document. So, basically this implementation always automatically adds `:scope` to the beginning of the selector\n * if no scope has been defined (as soon as a scope is defined anywhere in the selector, no auto-handling will be done).\n * The function always takes care of handling browsers, that do no support `:scope` yet, by using a randomized query\n * attribute approach.\n *\n * The second (minor) difference is, that this function actually returns an array and does not return a NodeList. The\n * reason being quite simple: Arrays have far better support for basic list operations than NodeList. An example:\n * Getting the first found node is straightforward in both cases (item(0) vs. at(0)), but getting the last node becomes\n * hairy pretty quickly since, item() does not accept negative indices, whereas at() does. So, with an array, we can get\n * the last node simple by using at(-1). Arrays simply have the better API nowadays and since the NodeList would be\n * static here anyway ...\n *\n * The last little difference is, that the base node for this function may not be the document itself, since\n * attribute-based scoping fallback does not work on the document, since we cannot define attributes on the document\n * itself. Just use document.body instead.\n *\n * @param {HTMLElement} node - the element to search in\n * @param {?String} [selector='*'] - the element query selector to apply to node, to find fitting elements\n * @param {?Boolean} [onlyOne=false] - if true, uses querySelector instead of querySelectorAll and therefore returns a single node or null instead of an array\n * @throws error if node is not a usable HTML element\n * @return {Array<Node>|Node|null} descendant nodes matching the selector, a single node or null if onlyOne is true\n *\n * @memberof Elements:find\n * @alias find\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/querySelectorAll#user_notes\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array\n * @example\n * find(document.body, 'section ul > li a[href*=\"#\"]');\n * find(element, '> aside img[src]');\n * find(element, '> aside img[src]', true);\n * find(element, 'aside > :scope figcaption');\n * find(element, '*');\n * find(element, '[data-test=\"foobar\"] ~ li a[href]'));\n * find(element, 'a[href]').at(-1);\n */\nexport function find(node, selector='*', onlyOne=false){\n\tconst\n\t\t__methodName__ = 'find',\n\t\tscopeRex = /:scope(?![\\w-])/gi\n\t;\n\n\tassert(isA(node, 'htmlelement'), `${MODULE_NAME}:${__methodName__} | ${NOT_AN_HTMLELEMENT_ERROR}`);\n\n\tselector = orDefault(selector, '*', 'str').trim();\n\tif( !(scopeRex.test(selector)) ){\n\t\tselector = `:scope ${selector}`;\n\t}\n\tonlyOne = orDefault(onlyOne, false, 'bool');\n\n\tif( BROWSER_HAS_CSS_SCOPE_SUPPORT ){\n\t\treturn onlyOne ? node.querySelector(selector) : Array.from(node.querySelectorAll(selector));\n\t} else {\n\t\tconst fallbackScopeAttribute = `find-scope-${randomUuid()}`;\n\t\tselector = selector.replace(scopeRex, `[${fallbackScopeAttribute}]`);\n\n\t\tnode.setAttribute(fallbackScopeAttribute, '');\n\t\tconst found = onlyOne ? node.querySelector(selector) : Array.from(node.querySelectorAll(selector));\n\t\tnode.removeAttribute(fallbackScopeAttribute);\n\n\t\treturn found;\n\t}\n}\n\n\n\n/**\n * @namespace Elements:findOne\n */\n\n/**\n * Searches for and returns one descendant node of a given node matching a CSS selector, just as querySelector.\n *\n * The main difference to querySelector is, that this method automatically scopes the query, making sure, that the\n * given selector is actually fulfilled _inside_ the scope of the base element and not always regarding the whole\n * document. So, basically this implementation always automatically adds `:scope` to the beginning of the selector\n * if no scope has been defined (as soon as a scope is defined anywhere in the selector, no auto-handling will be done).\n * The function always takes care of handling browsers, that do no support `:scope` yet, by using a randomized query\n * attribute approach.\n *\n * The function is a shorthand for `find()` with `onlyOne` being true. The main reason this method existing, is, that\n * querySelector has a 2:1 performance advantage over querySelectorAll and nullish coalescing is easier using a\n * possible null result.\n *\n * @param {HTMLElement} node - the element to search in\n * @param {?String} [selector='*'] - the element query selector to apply to node, to find fitting element\n * @throws error if node is not a usable HTML element\n * @return {Node|null} descendant nodes matching the selector\n *\n * @memberof Elements:findOne\n * @alias findOne\n * @see find\n * @example\n * findOne(document.body, 'section ul > li a[href*=\"#\"]');\n * findOne(element, '> aside img[src]');\n * findOne(element, 'aside > :scope figcaption');\n * findOne(element, '*');\n * findOne(element, '[data-test=\"foobar\"] ~ li a[href]'));\n */\nexport function findOne(node, selector='*'){\n\treturn find(node, selector, true);\n}\n\n\n\n/**\n * @namespace Elements:findTextNodes\n */\n\n/**\n * Extracts all pure text nodes from an Element, starting in the element itself.\n *\n * Think of this function as a sort of find() where the result are not nodes, that query selectors can find, but pure\n * text nodes. So you'll get a set of recursively discovered text nodes without tags, representing the pure text content\n * of an element.\n *\n * If you define to set onlyFirstLevel, you'll be able to retrieve all text on the first level of an element _not_\n * included in any tag (paragraph contents without special formats as b/i/em/strong for example).\n *\n * @param {HTMLElement} node - the element to search for text nodes inside\n * @param {?Function} [filter=null] - a filter function to restrict the returned set, gets called with the textNode (you can access the parent via .parentNode)\n * @param {?Boolean} [onlyFirstLevel=false] - defines if the function should only return text nodes from the very first level of children\n * @throws error if node is not a usable HTML element\n * @return {Array<Node>} a list of text nodes\n *\n * @memberof Elements:findTextNodes\n * @alias findTextNodes\n * @example\n * const styledSentence = createElement('<div>arigatou <p>gozaimasu <span>deshita</span></p> mr. roboto<p>!<span>!!</span></p></div>');\n * findTextNodes(styledSentence).length;\n * => 6\n * findTextNodes(styledSentence, null, true).length;\n * => 2\n * findTextNodes(styledSentence, textNode => textNode.textContent.length < 9).length;\n * => 3\n * findTextNodes(styledSentence).map(node => node.textContent).join('');\n * \t=> 'arigatou gozaimasu deshita mr. roboto!!!';\n */\nexport function findTextNodes(node, filter=null, onlyFirstLevel=false){\n\tfilter = isA(filter, 'function') ? filter : () => true;\n\tonlyFirstLevel = orDefault(onlyFirstLevel, false, 'bool');\n\n\tconst\n\t\ttextNodeType = 3,\n\t\tisValidTextNode = node => {\n\t\t\treturn (node.nodeType === textNodeType)\n\t\t\t\t&& (node.textContent.trim() !== '')\n\t\t\t\t&& !!filter(node)\n\t\t\t;\n\t\t},\n\t\textractTextNodes = node => {\n\t\t\tif( isValidTextNode(node) ){\n\t\t\t\treturn [].concat(node);\n\t\t\t} else {\n\t\t\t\treturn Array.from(node.childNodes).reduce((textNodes, childNode) => {\n\t\t\t\t\treturn isValidTextNode(childNode)\n\t\t\t\t\t\t? textNodes.concat(childNode)\n\t\t\t\t\t\t: (\n\t\t\t\t\t\t\t!!onlyFirstLevel\n\t\t\t\t\t\t\t? textNodes\n\t\t\t\t\t\t\t: textNodes.concat(extractTextNodes(childNode))\n\t\t\t\t\t\t)\n\t\t\t\t\t;\n\t\t\t\t}, []);\n\t\t\t}\n\t\t}\n\t;\n\n\treturn extractTextNodes(node);\n}\n\n\n\n/**\n * @namespace Elements:measureHiddenDimensions\n */\n\n/**\n * Measures hidden elements by using a sandbox div. In some layout situations you may not be able to measure hidden\n * or especially detached elements correctly, sometimes simply because they are not rendered, other times because\n * they are rendered in a context where the browser does not keep correct styling information due to optimizations\n * considering visibility of the element.\n *\n * This method works by cloning a node and inserting it in a well hidden sandbox element for the time of the measurement,\n * after which the sandbox is immediately removed again. This method allows you to measure \"hidden\" elements inside the\n * DOM without the need to actually move elements around or show them visibly.\n *\n * Keep in mind, that only measurements inherent to the element itself are measurable if sandbox is inserted into the\n * body. Layout information from surrounding containers is, of course, not available. You can remedy this by setting the\n * context correctly. Keep in mind, that direct child selectors may not work in the context since the sandbox itself\n * constitutes a new level between context and element. In these cases you might have to adapt you selectors.\n *\n * @param {HTMLElement} node - the element to measure\n * @param {?String} [method='outer'] - the kind of measurement to take, allowed values are \"outer\"/\"offset\", \"inner\"/\"client\" or \"scroll\"\n * @param {?String} [selector=null] - selector to apply to element to find target\n * @param {?HTMLElement} [context=document.body] - context to use as container for measurement\n * @throws error if node is not a usable HTML element\n * @returns {Object<String,Number>} a plain object holding width and height measured according to the defined method\n *\n * @memberof Elements:measureHiddenDimensions\n * @alias measureHiddenDimensions\n * @see https://developer.mozilla.org/en-US/docs/Web/API/CSS_Object_Model/Determining_the_dimensions_of_elements#how_big_is_the_content\n * @example\n * measureHiddenDimensions(document.body.querySelector('div.hidden:first'), 'inner');\n * measureHiddenDimensions(document.body, 'outer, 'div.hidden:first', document.body.querySelector('main'));\n */\nexport function measureHiddenDimensions(node, method='outer', selector=null, context=document.body){\n\tconst __methodName__ = 'measureHidden';\n\n\tconst methods = {\n\t\toffset : {width : 'offsetWidth', height : 'offsetHeight'},\n\t\touter : {width : 'offsetWidth', height : 'offsetHeight'},\n\t\tclient : {width : 'clientWidth', height : 'clientHeight'},\n\t\tinner : {width : 'clientWidth', height : 'clientHeight'},\n\t\tscroll : {width : 'scrollWidth', height : 'scrollHeight'}\n\t};\n\tmethod = methods[orDefault(method, 'outer', 'str')] ?? methods.outer;\n\n\tassert(isA(node, 'htmlelement'), `${MODULE_NAME}:${__methodName__} | ${NOT_AN_HTMLELEMENT_ERROR}`);\n\tassert(isA(context, 'htmlelement'), `${MODULE_NAME}:${__methodName__} | context is no an htmlelement`);\n\n\tconst\n\t\tsandbox = createNode('div', {\n\t\t\t'id' : `sandbox-${randomUuid()}`,\n\t\t\t'class' : 'sandbox',\n\t\t\t'style' : 'display:block; opacity:0; visibility:hidden; pointer-events:none; position:absolute; top:-10000px; left:-10000px;'\n\t\t}),\n\t\tmeasureClone = clone(node)\n\t;\n\n\tcontext.appendChild(sandbox);\n\tsandbox.appendChild(measureClone);\n\n\tconst\n\t\ttarget = hasValue(selector) ? measureClone.querySelector(selector) : measureClone,\n\t\twidth = target?.[method.width] ?? 0,\n\t\theight = target?.[method.height] ?? 0,\n\t\tdimensions = {\n\t\t\twidth,\n\t\t\theight,\n\t\t\ttoString(){ return `${width}x${height}`; }\n\t\t}\n\t;\n\n\tcontext.removeChild(sandbox);\n\n\treturn dimensions;\n}\n"]}
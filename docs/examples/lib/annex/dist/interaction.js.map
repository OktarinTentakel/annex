{"version":3,"file":"interaction.js","names":["MODULE_NAME","assert","isA","orDefault","hasValue","Deferred","findTextNodes","applyStyles","TAPPABLE_ELEMENTS_SELECTOR","NOT_AN_HTMLELEMENT_ERROR","createSelection","node","startOffset","endOffset","selectionText","range","selection","rangeText","selectionStart","selectionEnd","focus","select","value","length","substring","window","getSelection","document","createRange","selectNodeContents","textNodes","startNodeIndex","startNode","endNodeIndex","endNode","remainingStartOffset","startOffsetNodeFound","setStart","remainingEndOffset","endOffsetNodeFound","setEnd","removeAllRanges","addRange","toString","body","createTextRange","moveToElementText","moveStart","moveEnd","text","removeSelections","empty","disableSelection","onselectstart","unselectable","enableSelection","undefined","obfuscatePrivateMailToLink","link","setAsContent","tld","afterAtWithoutTld","beforeAt","subject","ccTld","ccAfterAtWithoutTld","ccBeforeAt","optionParams","URLSearchParams","set","replaceAll","interactionCount","fAddLinkUrl","setAttribute","addEventListener","fRemoveLinkUrl","innerHTML","replace","obfuscatePrivateTelLink","secondTelPart","firstTelPart","regionPart","countryPart","setTappedState","element","tappedClass","tappedDuration","deferred","classList","add","setTimeout","remove","blur","resolve","setupAutoTappedStates","tappableElementsSelector","tapEvents","concat","forEach","tapEvent","e","target","matches"],"sources":["interaction.js"],"mappings":"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","sourcesContent":["/*!\n * Module Interaction\n */\n\n/**\n * @namespace Interaction\n */\n\nconst MODULE_NAME = 'Interaction';\n\n\n\n//###[ IMPORTS ]########################################################################################################\n\nimport {assert, isA, orDefault, hasValue, Deferred} from './basic.js';\nimport {findTextNodes} from './elements.js';\nimport {applyStyles} from './css.js';\n\n\n\n//###[ DATA ]###########################################################################################################\n\nexport const TAPPABLE_ELEMENTS_SELECTOR = 'a, button, .button, input[type=button], input[type=submit]';\nconst NOT_AN_HTMLELEMENT_ERROR = 'given node/target is not an HTMLElement';\n\n\n\n//###[ EXPORTS ]########################################################################################################\n\n/**\n * @namespace Interaction:createSelection\n */\n\n/**\n * Programmatically create a text selection inside a node, possibly reaching across several child nodes,\n * but virtually only working with the raw text content. Can also be used to create a selection in text\n * inputs for example.\n *\n * Be aware that the endOffset is neither the length to select nor the last index, but the offset starting\n * from the last character in the node counting backwards (like a reverse startOffset). The reason for this wonkyness\n * is the fact that we have to implement three different ways of creating selections in this function, this\n * notation being the most compatible one. We assume the default use case for this method is to select all content\n * of a node with the possibility to skip one or two unwanted characters on each side of the content.\n *\n * Hint: You cannot create a selection spanning normal inline text into an input, ending there. To create a selection in\n * a text input, please target that element specifically or make sure the selection spans the whole input.\n * Furthermore, on mobile/iOS devices creation of selection ranges might only be possible in text inputs.\n *\n * @param  {HTMLElement} node - the element to create a selection inside\n * @param  {?Number} [startOffset=0] - characters to leave out at the beginning of the text content\n * @param  {?Number} [endOffset=0] - characters to leave out at the end of the text content\n * @return {String} the selected text\n *\n * @memberof Interaction:createSelection\n * @alias createSelection\n * @see removeSelections\n * @example\n * const selectedText = createSelection(copytextElement, 12, 6);\n */\nexport function createSelection(node, startOffset=0, endOffset=0){\n\tconst __methodName__ = 'createSelection';\n\n\tstartOffset = orDefault(startOffset, 0, 'int');\n\tendOffset = orDefault(endOffset, 0, 'int');\n\n\tassert(isA(node, 'htmlelement'), `${MODULE_NAME}:${__methodName__} | ${NOT_AN_HTMLELEMENT_ERROR}`);\n\n\tlet\tselectionText, range, selection, rangeText;\n\n\tif( hasValue(node.selectionStart, node.selectionEnd) ){\n\t\tnode.focus();\n\t\tnode.select();\n\t\trangeText = node.value;\n\t\tnode.selectionStart = startOffset;\n\t\tnode.selectionEnd = rangeText.length - endOffset;\n\t\tselectionText = rangeText.substring(node.selectionStart, node.selectionEnd);\n\t} else if( isA(window.getSelection, 'function') ){\n\t\trange = document.createRange();\n\t\trange.selectNodeContents(node);\n\n\t\tif( hasValue(startOffset) || hasValue(endOffset) ){\n\t\t\tconst textNodes = findTextNodes(node);\n\t\t\tif( textNodes.length > 0 ){\n\t\t\t\tlet\n\t\t\t\t\tstartNodeIndex = 0,\n\t\t\t\t\tstartNode = textNodes[startNodeIndex],\n\t\t\t\t\tendNodeIndex = textNodes.length - 1,\n\t\t\t\t\tendNode = textNodes[endNodeIndex]\n\t\t\t\t;\n\n\t\t\t\tif( hasValue(startOffset) ){\n\t\t\t\t\tlet\n\t\t\t\t\t\tremainingStartOffset = startOffset,\n\t\t\t\t\t\tstartOffsetNodeFound = (remainingStartOffset <= startNode.length)\n\t\t\t\t\t;\n\n\t\t\t\t\twhile( !startOffsetNodeFound && hasValue(startNode) ){\n\t\t\t\t\t\tstartNodeIndex++;\n\t\t\t\t\t\tif( hasValue(textNodes[startNodeIndex]) ){\n\t\t\t\t\t\t\tremainingStartOffset -= startNode.length;\n\t\t\t\t\t\t\tstartNode = textNodes[startNodeIndex];\n\t\t\t\t\t\t\tstartOffsetNodeFound = (remainingStartOffset <= startNode.length);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tremainingStartOffset = startNode.length;\n\t\t\t\t\t\t\tstartOffsetNodeFound = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\trange.setStart(startNode, remainingStartOffset);\n\t\t\t\t}\n\n\t\t\t\tif( hasValue(endOffset) ){\n\t\t\t\t\tlet\n\t\t\t\t\t\tremainingEndOffset = endOffset,\n\t\t\t\t\t\tendOffsetNodeFound = (remainingEndOffset <= endNode.length)\n\t\t\t\t\t;\n\n\t\t\t\t\twhile( !endOffsetNodeFound && hasValue(endNode) ){\n\t\t\t\t\t\tendNodeIndex--;\n\t\t\t\t\t\tif( hasValue(textNodes[endNodeIndex]) ){\n\t\t\t\t\t\t\tremainingEndOffset -= endNode.length;\n\t\t\t\t\t\t\tendNode = textNodes[endNodeIndex];\n\t\t\t\t\t\t\tendOffsetNodeFound = (remainingEndOffset <= endNode.length);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tremainingEndOffset = endNode.length;\n\t\t\t\t\t\t\tendOffsetNodeFound = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\trange.setEnd(endNode, endNode.length - remainingEndOffset);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tselection = window.getSelection();\n\t\tselection.removeAllRanges();\n\t\tselection.addRange(range);\n\t\tselectionText = range.toString();\n\t} else if( isA(document.body.createTextRange, 'function') ){\n\t\trange = document.body.createTextRange();\n\t\trange.moveToElementText(node);\n\n\t\tif( hasValue(startOffset) ){\n\t\t\trange.moveStart('character', startOffset);\n\t\t}\n\n\t\tif( hasValue(endOffset) ){\n\t\t\trange.moveEnd('character', -endOffset);\n\t\t}\n\n\t\trange.select();\n\n\t\tselectionText = range.text;\n\t}\n\n\treturn selectionText;\n}\n\n\n\n/**\n * @namespace Interaction:removeSelections\n */\n\n/**\n * Removes all text selections from the current window if possible.\n * Certain mobile devices like iOS devices might block this behaviour actively.\n *\n * @memberof Interaction:removeSelections\n * @alias removeSelections\n * @see createSelection\n * @example\n * removeSelections();\n */\nexport function removeSelections(){\n\tif( isA(window.getSelection, 'function') ){\n\t\twindow.getSelection().removeAllRanges();\n\t} else if( isA(document.getSelection, 'function') ){\n\t\tdocument.getSelection().removeAllRanges();\n\t}\n\n\tif( hasValue(document.selection) ){\n\t\tdocument.selection.empty();\n\t}\n}\n\n\n\n/**\n * @namespace Interaction:disableSelection\n */\n\n/**\n * Disables the possibility to create a selection in an element.\n *\n * @param  {HTMLElement} node - the element to disable user selection for\n * @return {HTMLElement} the node with disabled selection\n *\n * @memberof Interaction:disableSelection\n * @alias disableSelection\n * @see enableSelection\n * @example\n * disableSelection(widget);\n */\nexport function disableSelection(node){\n\tconst __methodName__ = 'disableSelection';\n\n\tassert(isA(node, 'htmlelement'), `${MODULE_NAME}:${__methodName__} | ${NOT_AN_HTMLELEMENT_ERROR}`);\n\n\tnode.onselectstart = () => false;\n\tnode.unselectable = 'on';\n\tapplyStyles(node, {'user-select' : 'none'}, true);\n\tapplyStyles(node, {'-webkit-touch-callout' : 'none'});\n\n\treturn node;\n}\n\n\n\n/**\n * @namespace Interaction:enableSelection\n */\n\n/**\n * (Re)enables the possibility to create a selection in an element. Most likely after having been disabled\n * using `disableSelection`.\n *\n * @param  {HTMLElement} node - the element to (re)enable user selection for\n * @return {HTMLElement} the node with (re)enabled selection\n *\n * @memberof Interaction:enableSelection\n * @alias enableSelection\n * @see disableSelection\n * @example\n * enableSelection(widget);\n */\nexport function enableSelection(node){\n\tconst __methodName__ = 'disableSelection';\n\n\tassert(isA(node, 'htmlelement'), `${MODULE_NAME}:${__methodName__} | ${NOT_AN_HTMLELEMENT_ERROR}`);\n\n\tnode.onselectstart = undefined;\n\tnode.unselectable = 'off';\n\tapplyStyles(node, {'user-select' : null}, true);\n\tapplyStyles(node, {'-webkit-touch-callout' : null});\n\n\treturn node;\n}\n\n\n\n/**\n * @namespace Interaction:obfuscatePrivateMailToLink\n */\n\n/**\n * Augment a link element to hold an obfuscated private mailto link, to be able to contact people\n * via their own mail address, without the need to openly write the address into the DOM permanently,\n * in a way crawlers could identify easily.\n *\n * The method takes all parts of the address as (hopefully) unidentifiable parameters and then applies them internally,\n * to build an email string with mailto protocol dynamically on mouse or focus interaction in the link's href,\n * offering normal link functionality from here on. If the interaction ends, the href is removed again immediately,\n * so the link is only and exclusively readable and complete during user interaction.\n *\n * You may set the link text yourself or set `setAsContent` to true, to let the function fill the link text with\n * the completed address. Be aware, that this, although still being obfuscated, lowers the level of security for this\n * solution.\n *\n * Although most parameters are technically optional, this function still expects `beforeAt` and `afterAtWithoutTld` to\n * be filled. While these parts are strictly necessary here: I'd always suggest to use all parts, since, the more\n * of an address is written together, the easier the address can be parsed.\n *\n * @param {HTMLElement} link - the link to augment, has to be a node where we can set a \"href\" attribute\n * @param {?Boolean} [setAsContent=false] - define if the address should be used as link text (still uses string obfuscation, but weaker against bot with JS execution)\n * @param {?String} [tld=''] - the top level domain to use\n * @param {?String} [afterAtWithoutTld=''] - the address part after the @ but before the tld\n * @param {?String} [beforeAt=''] - the address part before the @\n * @param {?String} [subject=''] - the subject the mail should have, if you want to preset this\n * @param {?String} [body=''] - the body text the mail should have initially, if you want to preset this\n * @param {?String} [ccTld=''] - the top level domain to use for the cc address\n * @param {?String} [ccAfterAtWithoutTld=''] - the address part after the @ but before the tld for the cc address\n * @param {?String} [ccBeforeAt=''] - the address part before the @ for the cc address\n * @throws error if beforeAt or afterAtWithoutTld are empty\n * @return {HTMLElement} the augmented link\n *\n * @memberof Interaction:obfuscatePrivateMailToLink\n * @alias obfuscatePrivateMailToLink\n * @example\n * obfuscatePrivateMailToLink(document.querySelector('a'), true, 'de', 'gmail', 'recipient', 'Hello there!', 'How are you these days?');\n */\nexport function obfuscatePrivateMailToLink(\n\tlink,\n\tsetAsContent=false,\n\ttld='',\n\tafterAtWithoutTld='',\n\tbeforeAt='',\n\tsubject='',\n\tbody='',\n\tccTld='',\n\tccAfterAtWithoutTld='',\n\tccBeforeAt=''\n){\n\tconst __methodName__ = 'obfuscatePrivateMailToLink';\n\n\tsetAsContent = orDefault(setAsContent, false, 'bool');\n\tsubject = orDefault(subject, '', 'str');\n\tbody = orDefault(body, '', 'str');\n\tbeforeAt = orDefault(beforeAt, '', 'str');\n\tafterAtWithoutTld = orDefault(afterAtWithoutTld, '', 'str');\n\ttld = orDefault(tld, '', 'str');\n\tccBeforeAt = orDefault(ccBeforeAt, '', 'str');\n\tccAfterAtWithoutTld = orDefault(ccAfterAtWithoutTld, '', 'str');\n\tccTld = orDefault(ccTld, '', 'str');\n\n\tassert((beforeAt !== '') && (afterAtWithoutTld !== ''), `${MODULE_NAME}:${__methodName__} | basic mail parts missing`);\n\n\tif( tld !== '' ){\n\t\ttld = `.${tld}`;\n\t}\n\n\tif( ccTld !== '' ){\n\t\tccTld = `.${ccTld}`;\n\t}\n\n\tlet optionParams = new URLSearchParams();\n\tif( subject !== '' ){\n\t\toptionParams.set('subject', subject);\n\t}\n\tif( body !== '' ){\n\t\toptionParams.set('body', body);\n\t}\n\tif( (ccBeforeAt !== '') && (ccAfterAtWithoutTld !== '') ){\n\t\toptionParams.set('cc', `${ccBeforeAt}@${ccAfterAtWithoutTld}${ccTld}`);\n\t}\n\toptionParams = optionParams.toString();\n\tif( optionParams !== '' ){\n\t\toptionParams = `?${optionParams.replaceAll('+', '%20')}`;\n\t}\n\n\tlet interactionCount = 0;\n\tconst fAddLinkUrl = () => {\n\t\tinteractionCount++;\n\t\tlink.setAttribute('href', `mailto:${beforeAt}@${afterAtWithoutTld}${tld}${optionParams}`);\n\t};\n\tlink.addEventListener('mouseenter', fAddLinkUrl);\n\tlink.addEventListener('focusin', fAddLinkUrl);\n\tconst fRemoveLinkUrl = () => {\n\t\tinteractionCount--;\n\t\tif( interactionCount <= 0 ){\n\t\t\tlink.setAttribute('href', '');\n\t\t}\n\t};\n\tlink.addEventListener('mouseleave', fRemoveLinkUrl);\n\tlink.addEventListener('focusout', fRemoveLinkUrl);\n\n\tif( setAsContent ){\n\t\tlink.innerHTML = (`${beforeAt}@${afterAtWithoutTld}${tld}`).replace(/(\\w{1})/g, '$1&zwnj;');\n\t}\n\n\treturn link;\n}\n\n\n\n/**\n * @namespace Interaction:obfuscatePrivateTelLink\n */\n\n/**\n * Augment a link element to hold an obfuscated private tel link, to be able to contact people\n * via their own phone number, without the need to openly write the number into the DOM permanently,\n * in a way crawlers could identify easily.\n *\n * The method takes all parts of the number as (hopefully) unidentifiable parameters and then applies them internally,\n * to build a number string with tel protocol dynamically on mouse or focus interaction in the link's href,\n * offering normal link functionality from here on. If the interaction ends, the href is removed again immediately,\n * so the link is only and exclusively readable and complete during user interaction.\n *\n * You may set the link text yourself or set `setAsContent` to true, to let the function fill the link text with\n * the completed address. Be aware, that this, although still being obfuscated, lowers the level of security for this\n * solution.\n *\n * Although most parameters are technically optional, this function still expects `secondTelPart` or `firstTelPart` to\n * be filled. While only one part is strictly necessary here: I'd always suggest to use all parts, since, the more\n * of a number is written together, the easier the number can be parsed.\n *\n * @param {HTMLElement} link - the link to augment, has to be a node where we can set a \"href\" attribute\n * @param {?Boolean} [setAsContent=false] - define if the number should be used as link text, being formatted according to DIN 5008 (still uses string obfuscation, but weaker against bot with JS execution)\n * @param {?Number|String} [secondTelPart=''] - second half of the main number +49 04 123(4-56)<-this; add a dash to signify where a base number ends and the personal part starts\n * @param {?Number|String} [firstTelPart=''] - first half of the main number +49 04 (123)<-this 4-56\n * @param {?Number|String} [regionPart=''] - the local part of the number after the country part e.g. +49(04)<-this 1234-56\n * @param {?Number|String} [countryPart=''] - the country identifier with or without + this->(+49) 04 1234-56 (do not prefix with a local 0!)\n * @throws error if `secondTelPart` and `firstTelPart` are empty\n * @return {HTMLElement} the augmented link\n *\n * @memberof Interaction:obfuscatePrivateTelLink\n * @alias obfuscatePrivateTelLink\n * @example\n * obfuscatePrivateTelLink(document.querySelector('a'), true, 123, 439, 40, '+49');\n */\nexport function obfuscatePrivateTelLink(\n\tlink,\n\tsetAsContent=false,\n\tsecondTelPart='',\n\tfirstTelPart='',\n\tregionPart='',\n\tcountryPart=''\n){\n\tconst __methodName__ = 'obfuscatePrivateTelLink';\n\n\tsetAsContent = orDefault(setAsContent, false, 'bool');\n\tsecondTelPart = orDefault(secondTelPart, '', 'str').replace(/[^0-9\\-]/g, '');\n\tfirstTelPart = orDefault(firstTelPart, '', 'str').replace(/[^0-9\\-]/g, '');\n\tregionPart = orDefault(regionPart, '', 'str').replace(/[^0-9]/g, '');\n\tcountryPart = orDefault(countryPart, '', 'str').replace(/[^0-9]/g, '');\n\n\tassert((firstTelPart !== '') || (secondTelPart !== ''), `${MODULE_NAME}:${__methodName__} | basic tel parts missing`);\n\n\tlet interactionCount = 0;\n\tconst fAddLinkUrl = () => {\n\t\tinteractionCount++;\n\t\tlink.setAttribute('href', `tel:+${countryPart}${regionPart}${firstTelPart.replace(/-/g, '')}${secondTelPart.replace(/-/g, '')}`);\n\t};\n\tlink.addEventListener('mouseenter', fAddLinkUrl);\n\tlink.addEventListener('focusin', fAddLinkUrl);\n\tconst fRemoveLinkUrl = () => {\n\t\tinteractionCount--;\n\t\tif( interactionCount <= 0 ){\n\t\t\tlink.setAttribute('href', '');\n\t\t}\n\t};\n\tlink.addEventListener('mouseleave', fRemoveLinkUrl);\n\tlink.addEventListener('focusout', fRemoveLinkUrl);\n\n\tif( setAsContent ){\n\t\tlink.innerHTML = (`+${countryPart} ${regionPart} ${firstTelPart}${secondTelPart}`).replace(/(\\w{1})/g, '$1&zwnj;');\n\t}\n}\n\n\n\n/**\n * @namespace Interaction:setTappedState\n */\n\n/**\n * Sets a \"tapped\" state on an element (via a CSS class), which removes itself again after a short time.\n *\n * The sole reason for doing this, is to be able to apply styling to a tap/click action across devices without\n * trailing styles, which would result by using something like `:focus`.\n *\n * @param {HTMLElement} element - the link to augment, has to be a node where we can set a \"href\" attribute\n * @param {?String} [tappedClass='tapped'] - the CSS class to set on the element to signify the \"tapped\" state\n * @param {?Number} [tappedDuration=200] - the duration in milliseconds, the \"tapped\" state should last\n * @throws error if element is not an HTMLElement\n * @return {Deferred} resolves with the element, when the tapped state ends\n *\n * @memberof Interaction:setTappedState\n * @alias setTappedState\n * @example\n * setTappedState(link);\n * setTappedState(link, 'clicked', 500);\n */\nexport function setTappedState(element, tappedClass='tapped', tappedDuration=200){\n\tconst __methodName__ = 'setTappedState';\n\n\ttappedClass = orDefault(tappedClass, 'tapped', 'str');\n\ttappedDuration = orDefault(tappedDuration, 200, 'int');\n\n\tassert(isA(element, 'htmlelement'), `${MODULE_NAME}:${__methodName__} | ${NOT_AN_HTMLELEMENT_ERROR}`);\n\n\tconst deferred = new Deferred();\n\n\telement.classList.add(tappedClass);\n\twindow.setTimeout(() =>{\n\t\telement.classList.remove(tappedClass);\n\t\telement.blur();\n\t\tdeferred.resolve(element);\n\t}, tappedDuration);\n\n\treturn deferred;\n}\n\n\n\n/**\n * @namespace Interaction:setupAutoTappedStates\n */\n\n/**\n * This function registers a global event handler on the document body, to automatically add \"tapped\" states (as a CSS\n * class) to \"tappable\" elements on \"tap\".\n *\n * What is a \"tap\" you ask? Well, it's either a pointer click or a finger touch or anything resembling these actions\n * on your current device.\n *\n * The idea behind that is this: usually, on pointer devices, we have a `:hover` state to signify user interaction\n * with an element, while on touch devices, we only know that an interaction took place after a user touched an element\n * with his/her finger, \"tapped\" it so to speak. Styling a touch with CSS would only be possible via `:focus`, which\n * has the problems, that focus has a different meaning on pointer devices and the focus state does not end\n * automatically, resulting in trailing visual states.\n *\n * So, what we do instead, is that we just generally observe taps (via \"click\" event, which works across devices as\n * expected) and set a class on the element, for a short time, which removes itself automatically again, to be able\n * to define a visual state or a short animation for that class. So, for example, let's say the function has been\n * executed. After that, you can define something like `a.tapped { color: orange; }`, which would result in orange\n * coloring for a short time, after clicking/touching the element. Combine this with `:hover`, `:focus` definitions\n * in CSS to define a complete effect setup.\n *\n * @param {?HTMLElement} [element=document.body] - the element to use as delegation parent for events, should contain the tappable elements you'd like to target\n * @param {?String} [tappableElementsSelector='a, button, .button, input[type=button], input[type=submit]'] - selector to identify a tappable element by in a delegated event handler\n * @param {?String|Array<String>} [tapEvents='click'] - the DOM event(s) to register for taps\n * @param {?String} [tappedClass='tapped'] - the CSS class to set on the element to signify the \"tapped\" state\n * @param {?Number} [tappedDuration=200] - the duration in milliseconds, the \"tapped\" state should last\n * @throws error if element is not an HTMLElement\n *\n * @memberof Interaction:setupAutoTappedStates\n * @alias setupAutoTappedStates\n * @example\n * setupAutoTappedStates();\n * setupAutoTappedStates(document.body, 'a, button', 'customevent');\n */\nexport function setupAutoTappedStates(\n\telement=null,\n\ttappableElementsSelector=TAPPABLE_ELEMENTS_SELECTOR,\n\ttapEvents='click',\n\ttappedClass='tapped',\n\ttappedDuration=200\n){\n\tconst __methodName__ = 'setupAutoTappedStates';\n\n\t// document.body not in function default to prevent errors on import in document-less contexts\n\telement = orDefault(element, document.body);\n\ttappableElementsSelector = orDefault(tappableElementsSelector, TAPPABLE_ELEMENTS_SELECTOR, 'str');\n\ttapEvents = orDefault(tapEvents, 'click', 'str');\n\ttapEvents = [].concat(tapEvents);\n\n\tassert(isA(element, 'htmlelement'), `${MODULE_NAME}:${__methodName__} | ${NOT_AN_HTMLELEMENT_ERROR}`);\n\n\ttapEvents.forEach(tapEvent => {\n\t\telement.addEventListener(tapEvent, e => {\n\t\t\tif(\n\t\t\t\thasValue(e.target?.matches)\n\t\t\t\t&& e.target.matches(tappableElementsSelector)\n\t\t\t){\n\t\t\t\tsetTappedState(e.target, tappedClass, tappedDuration);\n\t\t\t}\n\t\t});\n\t});\n}\n"]}
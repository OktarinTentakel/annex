{"version":3,"file":"navigation.js","names":["MODULE_NAME","warn","hasValue","orDefault","isPlainObject","isArray","isWindow","isFunction","assert","createNode","browserSupportsHistoryManipulation","urlHref","HISTORY","current","state","title","getHostAndPathname","popState","listening","callbacks","handler","e","historyNew","forEach","cb","stateful","hostAndPathname","host","undefined","pathname","window","location","ex","redirect","url","params","anchor","target","postParams","markListParams","formAttributes","method","action","redirectForm","paramName","val","appendChild","type","name","value","document","body","submit","removeChild","URL","origin","eLink","createElement","href","rel","click","parentNode","open","assign","openTab","openWindow","options","parentWindow","tryAsPopup","windowName","optionArray","prop","includes","push","join","reload","cached","postUsable","form","replace","changeCurrentUrl","usePushState","history","pushState","replaceState","path","onHistoryChange","callback","clearOld","usePreviousState","__methodName__","statefulCallback","original","addEventListener","offHistoryChange","oldCallbackCount","length","reduce","cbs","newCallbackCount","removeEventListener"],"sources":["navigation.js"],"mappings":"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","ignoreList":[],"sourcesContent":["/*!\n * Module Navigation\n */\n\n/**\n * @namespace Navigation\n */\n\nconst MODULE_NAME = 'Navigation';\n\n\n\n//###[ IMPORTS ]########################################################################################################\n\nimport {warn} from './logging.js';\nimport {hasValue, orDefault, isPlainObject, isArray, isWindow, isFunction, assert} from './basic.js';\nimport {createNode} from './elements.js';\nimport {browserSupportsHistoryManipulation} from './context.js';\nimport {urlHref} from './urls.js';\n\n\n\n//###[ DATA ]###########################################################################################################\n\nexport const HISTORY = {\n\tcurrent : {\n\t\tstate : null,\n\t\ttitle : '',\n\t\t...getHostAndPathname()\n\t},\n\tpopState : {\n\t\tlistening : false,\n\t\tcallbacks : [],\n\t\thandler(e){\n\t\t\tconst historyNew = {\n\t\t\t\tstate : e.state,\n\t\t\t\ttitle : e.title,\n\t\t\t\t...getHostAndPathname()\n\t\t\t};\n\n\t\t\tHISTORY.popState.callbacks.forEach(cb => {\n\t\t\t\tcb.stateful(e, historyNew);\n\t\t\t});\n\n\t\t\tHISTORY.current = historyNew;\n\t\t}\n\t}\n};\n\n\n\n//###[ HELPERS ]########################################################################################################\n\nfunction getHostAndPathname(){\n\tconst hostAndPathname = {\n\t\thost : undefined,\n\t\tpathname : undefined\n\t};\n\n\ttry {\n\t\thostAndPathname.host = window.location.host;\n\t\thostAndPathname.pathname = window.location.pathname;\n\t} catch(ex){\n\t\thostAndPathname.host = undefined;\n\t\thostAndPathname.pathname = undefined;\n\t}\n\n\treturn hostAndPathname;\n}\n\n\n\n//###[ EXPORTS ]########################################################################################################\n\n/**\n * @namespace Navigation:redirect\n */\n\n/**\n * Everything you need to do basic navigation without history API.\n *\n * Provide a URL to navigate to or leave the URL out, to use the current full URL. See `urlHref` for details.\n *\n * Add GET-parameters (adding to those already present in the URL), define an anchor (or automatically get the one\n * defined in the URL), set a target to define a window to navigate to (or open a new one) and even\n * define POST-parameters to navigate while providing POST-data.\n *\n * Provided params have to be a flat plain object, with ordinal values or arrays of ordinal values on the first level.\n * Everything else will be stringified and url-encoded as is. Usually, parameters defined here add to present\n * parameters in the URL. To force-override present values, declare the param name with a \"!\" prefix\n * (`{'!presentparam' : 'new'}`).\n *\n * If you define POST-params to navigate to a URL providing POST-data we internally build a custom form element,\n * with type \"post\", filled with hidden fields adding the form data, which we submit to navigate to the action, which\n * contains our url. Even the target carries over.\n *\n * If you define a target window and therefore open a new tab/window this function adds \"noopener,noreferrer\"\n * automatically if the origins do not match to increase security. If you need the opener, have a look at\n * \"openWindow\", which gives you more manual control in that regard.\n *\n * If you define a target and open an external URL, repeated calls to the same target will open multiple windows\n * due to the security settings.\n *\n * @param {?String|URL} [url=null] - the location to load, if null current location is reloaded/used\n * @param {?Object} [params=null] - plain object of GET-parameters to add to the url\n * @param {?String} [anchor=null] - anchor/hash to set for called url, has precedence over URL hash\n * @param {?String} [target=null] - name of the window to perform the redirect to/in, use \"_blank\" to open a new window/tab\n * @param {?Object} [postParams=null] - plain object of postParameters to send with the redirect, solved with a hidden form\n * @param {?Boolean} [markListParams=false] - if true, params with more than one value will be marked with \"[]\" preceding the param name\n * @throws error if url is not usable\n *\n * @memberof Navigation:redirect\n * @alias redirect\n * @see Urls.urlHref\n * @example\n * redirect('https://test.com', {search : 'kittens', order : 'asc'}, 'fluffykittens');\n * redirect(null, {order : 'desc'});\n */\nexport function redirect(url=null, params=null, anchor=null, target=null, postParams=null, markListParams=false){\n\turl = urlHref(url, params, anchor, markListParams);\n\ttarget = orDefault(target, null, 'str');\n\tpostParams = isPlainObject(postParams) ? postParams : null;\n\n\n\tif( hasValue(postParams) ){\n\t\tconst formAttributes = {method : 'post', action : url, 'data-ajax' : 'false'};\n\t\tif( hasValue(target) ){\n\t\t\tformAttributes.target = target;\n\t\t}\n\n\t\tconst redirectForm = createNode('form', formAttributes);\n\t\tfor( let paramName in postParams ){\n\t\t\tif( isArray(postParams[paramName]) ){\n\t\t\t\tpostParams[paramName].forEach(val => {\n\t\t\t\t\tredirectForm.appendChild(createNode(\n\t\t\t\t\t\t'input',\n\t\t\t\t\t\t{type : 'hidden', name : `${paramName}[]`, value : `${val}`}\n\t\t\t\t\t));\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tredirectForm.appendChild(createNode(\n\t\t\t\t\t'input',\n\t\t\t\t\t{type : 'hidden', name : paramName, value : `${postParams[paramName]}`}\n\t\t\t\t));\n\t\t\t}\n\t\t}\n\n\t\tdocument.body.appendChild(redirectForm);\n\t\tredirectForm.submit();\n\t\tdocument.body.removeChild(redirectForm);\n\t} else if( hasValue(target) ){\n\t\tconst parsedUrl = new URL(url);\n\n\t\tif( parsedUrl.origin !== window.location.origin ){\n\t\t\t// we have to jump through hoops here, since adding security features to window.open\n\t\t\t// forces popup windows in some browsers and although we can set opener via the created\n\t\t\t// window, we cannot reliably set the referrer that way\n\t\t\tconst eLink = document.createElement('a');\n\t\t\teLink.href = url;\n\t\t\teLink.target = target;\n\t\t\teLink.rel = 'noopener noreferrer';\n\t\t\tdocument.body.appendChild(eLink);\n\t\t\teLink.click();\n\t\t\teLink.parentNode.removeChild(eLink);\n\t\t} else {\n\t\t\twindow.open(url, target);\n\t\t}\n\t} else {\n\t\twindow.location.assign(url);\n\t}\n}\n\n\n\n/**\n * @namespace Navigation:openTab\n */\n\n/**\n * Opens a sub-window for the current window as _blank, which should result in a new tab in most browsers.\n *\n * This method is just a shortcut for \"redirect\" with a set target and reasonable parameters.\n *\n * By using \"redirect\", this method also automatically takes care of adding \"noopener,noreferrer\" to external\n * links, which are determined by not having the same origin as the current location. For more manual control\n * over such parameters, have a look at \"openWindow\" instead.\n *\n * @param {?String} [url] - the location to load, if null current location is reloaded/used\n * @param {?Object} [params=null] - plain object of GET-parameters to add to the url, adds to existing ones in the URL and overwrites existing ones with same name\n * @param {?String} [anchor=null] - anchor/hash to set for called url, has precedence over URL hash\n * @param {?Object} [postParams=null] - plain object of postParameters to send with the redirect, solved with a hidden form\n *\n * @memberof Navigation:openTab\n * @alias openTab\n * @see redirect\n * @example\n * openTab('/misc/faq.html');\n */\nexport function openTab(url, params=null, anchor=null, postParams=null){\n\tredirect(url, params, anchor, '_blank', postParams);\n}\n\n\n\n/**\n * @namespace Navigation:openWindow\n */\n\n/**\n * Opens a sub-window for the current window or another defined parent window.\n * Be aware that most browsers open new windows as a tab by default, have a look at the \"tryAsPopup\"-parameter\n * if you need to open a new standalone window and your configuration results in new tabs instead.\n *\n * For window options (in this implementation, we consider \"name\" to be an option as well), see:\n * https://developer.mozilla.org/en-US/docs/Web/API/Window/open#window_features\n *\n * Keep in mind to set \"noopener\" and/or \"noreferrer\" for external URLs in options, to improve security and privacy.\n * Hint for older MS browsers: if you set these security options, these will most likely open the URL in a popup\n * window. If you want to circumvent this, you'll have to drop the \"noreferrer\" and settle for \"noopener\", by\n * setting opener to null on the returned window like this: `openWindow('url').opener = null;`\n *\n * @param {?String|URL} [url=null] - the URL to load in the new window, if nullish, the current URL is used\n * @param {?Object} [options=null] - parameters for the new window according to the definitions of window.open & \"name\" for the window name\n * @param {?Window} [parentWindow=null] - parent window for the new window, current if not defined\n * @param {?Boolean} [tryAsPopup=false] - defines if it should be tried to force a real new window instead of a tab\n * @throws error if url is not usable\n * @returns {Window} the newly opened window/tab\n *\n * @memberof Navigation:openWindow\n * @alias openWindow\n * @see Urls.urlHref\n * @example\n * openWindow('/img/gallery.html');\n * openWindow('http://www.kittens.com', {name : 'kitten_popup'}, parent);\n */\nexport function openWindow(url=null, options=null, parentWindow=null, tryAsPopup=false){\n\turl = urlHref(url);\n\toptions = isPlainObject(options) ? options : null;\n\tparentWindow = isWindow(parentWindow) ? parentWindow : window;\n\ttryAsPopup = orDefault(tryAsPopup, false, 'bool');\n\n\tlet\twindowName = '';\n\tconst optionArray = [];\n\n\tif( hasValue(options) ){\n\t\tfor( let prop in options ){\n\t\t\tif( prop === 'name' ){\n\t\t\t\twindowName = options[prop];\n\t\t\t}\n\n\t\t\tif( (prop !== 'name') || tryAsPopup ){\n\t\t\t\tif( [true, 1, 'yes'].includes(options[prop]) ){\n\t\t\t\t\toptionArray.push(`${prop}`);\n\t\t\t\t} else {\n\t\t\t\t\toptionArray.push(`${prop}=${options[prop]}`);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn parentWindow.open(url, windowName, optionArray.join(','));\n}\n\n\n\n/**\n * @namespace Navigation:reload\n */\n\n/**\n * Reloads the current window-location. Differentiates between cached and cache-refreshing reload.\n * Hint: the forcedReload param in window.location.reload is deprecated and not supported anymore in all browsers,\n * so, in order to do a cache busting reload we have to use a trick, by using a POST-reload, since POST never\n * gets cached. If, for some reason, you cannot POST to a URL, I also provided a second, less effective fallback,\n * using \"replace\".\n *\n * Hint: depending on your browser a cached reload may keep the current scrolling position in the document, while\n * the uncached variants won't\n *\n * @param {?Boolean} [cached=true] - should we use the cache on reload?\n * @param {?Boolean} [postUsable=true] - if set to false, we try to replace URL instead of POSTing to it\n *\n * @memberof Navigation:reload\n * @alias reload\n * @example\n * // with cache\n * reload();\n * // without cache via POST\n * reload(false);\n * // without cache via \"replace\"\n * reload(false, false);\n */\nexport function reload(cached=true, postUsable=true){\n\tcached = orDefault(cached, true, 'bool');\n\tpostUsable = orDefault(postUsable, true, 'bool');\n\n\tif( !cached && postUsable ){\n\t\tconst form = document.createElement('form');\n\t\tform.method = 'post';\n\t\tform.action = window.location.href;\n\t\tdocument.body.appendChild(form);\n\t\tform.submit();\n\t\tdocument.body.removeChild(form);\n\t} else if( !cached && !postUsable ){\n\t\twindow.location.replace(window.location.href);\n\t} else {\n\t\twindow.location.reload();\n\t}\n}\n\n\n\n/**\n * @namespace Navigation:changeCurrentUrl\n */\n\n/**\n * Changes the current URL by using the history API (this means, we can only change to a path on the same origin).\n * Be aware that this replaces the current URL in the history _without_ any normal navigation or reload.\n * This method only works if the history API is supported by the browser, otherwise no navigation will occur\n * (but a warning will be shown in console).\n * For more details on the history API see:\n * https://developer.mozilla.org/en-US/docs/Web/API/History\n *\n * @param {?String|URL} [url=null] - a url to change the current address to on the same origin, will use current URL if nullish\n * @param {?Boolean} [usePushState=false] - push new state instead of replacing current\n * @param {?*} [state=null] - a serializable object to append to the history state (gets retrieved on popState-event)\n * @param {?String} [title=null] - a name/title for the new state (as of yet, only Safari uses this, other browser will return undefined)\n * @throws error if state is not serializable by browser\n *\n * @memberof Navigation:changeCurrentUrl\n * @alias changeCurrentUrl\n * @see onHistoryChange\n * @see Urls.urlHref\n * @example\n * changeCurrentUrl('/article/important-stuff', false, {id : 666});\n */\nexport function changeCurrentUrl(url=null, usePushState=false, state=null, title=null){\n\turl = urlHref(url);\n\tusePushState = orDefault(usePushState, false, 'bool');\n\ttitle = orDefault(title, '', 'str');\n\n\tif ( browserSupportsHistoryManipulation() ) {\n\t\tif( usePushState ){\n\t\t\twindow.history.pushState(state, title, url);\n\t\t} else {\n\t\t\twindow.history.replaceState(state, title, url);\n\t\t}\n\n\t\tHISTORY.current = {\n\t\t\tstate,\n\t\t\ttitle,\n\t\t\thost : window.location.host,\n\t\t\tpath : window.location.pathname\n\t\t};\n\t} else {\n\t\twarn(`${MODULE_NAME}:changeCurrentUrl | this browser does not support history api, skipping`);\n\t}\n}\n\n\n\n/**\n * @namespace Navigation:onHistoryChange\n */\n\n/**\n * Registers an onpopstate event if history API is available (does nothing and warns if not available).\n * Takes a callback, which is provided with states as plain objects like: {state, title, host, path}.\n * Hint: do not rely on title, since that property may only be supported by browsers like Safari,\n * serialize everything important into state and use title as orientation only.\n *\n * In case of a regular binding all callbacks get the current state, so the state that is being changed to, but\n * if you set \"usePreviousState\" to true and prior navigation was done with \"changeCurrentUrl\", all callbacks\n * get two states: \"from\" and \"to\". With this you can define rules an behaviour depending on the state you are\n * coming from. Keep in mind: this only works if you use \"changeCurrentUrl\" for navigation in tandem with this method.\n *\n * @param {Function} callback - function to execute on popstate\n * @param {?Boolean} [clearOld=false] - defines if old handlers should be removed before setting new one\n * @param {?Boolean} [usePreviousState=false] - defines if callbacks should be provided with previous state as well (in that case, changeCurrentUrl must have been used for prior navigation)\n * @throws error if callback is no function\n *\n * @memberof Navigation:onHistoryChange\n * @alias onHistoryChange\n * @see changeCurrentUrl\n * @see offHistoryChange\n * @example\n * onHistoryChange(function(){ alert('Hey, don\\'t do this!'); }, true);\n */\nexport function onHistoryChange(callback, clearOld=false, usePreviousState=false){\n\tconst __methodName__ = 'onHistoryChange';\n\n\tclearOld = orDefault(clearOld, false, 'bool');\n\tusePreviousState = orDefault(usePreviousState, false, 'bool');\n\n\tassert(isFunction(callback), `${MODULE_NAME}:${__methodName__} | callback is no function`);\n\n\tif ( browserSupportsHistoryManipulation() ) {\n\t\tif( clearOld ){\n\t\t\tHISTORY.popState.callbacks = [];\n\t\t}\n\n\t\tconst statefulCallback = function(e, historyNew){\n\t\t\tif( usePreviousState ){\n\t\t\t\tcallback(HISTORY.current, historyNew);\n\t\t\t} else {\n\t\t\t\tcallback(historyNew);\n\t\t\t}\n\t\t};\n\n\t\tHISTORY.popState.callbacks.push({\n\t\t\toriginal : callback,\n\t\t\tstateful : statefulCallback\n\t\t});\n\n\t\tif( !HISTORY.popState.listening ){\n\t\t\tHISTORY.popState.listening = true;\n\n\t\t\twindow.addEventListener('popstate',\tHISTORY.popState.handler);\n\t\t}\n\t} else {\n\t\twarn(`${MODULE_NAME}:${__methodName__} | this browser does not support history api, skipping`);\n\t}\n}\n\n\n\n/**\n * @namespace Navigation:offHistoryChange\n */\n\n/**\n * Removes registered history change handlers, that have been created with \"onHistoryChange\".\n * If a callback is provided, that callback is removed from callbacks, if the function is called\n * without parameters all callbacks are removed and the event listener for the callbacks is removed.\n *\n * @param {?Function} [callback=true] - reference to the callback to be removed, if missing all callbacks are removed\n * @throws error if callback is no function\n * @return {Boolean} true if callback(s) are/were removed, false if nothing was done\n *\n * @memberof Navigation:offHistoryChange\n * @alias offHistoryChange\n * @see changeCurrentUrl\n * @see onHistoryChange\n * @example\n * offHistoryChange(thatOneCallback);\n * offHistoryChange();\n */\nexport function offHistoryChange(callback=null){\n\tconst __methodName__ = 'offHistoryChange';\n\n\tif( hasValue(callback) ){\n\t\tassert(isFunction(callback), `${MODULE_NAME}:${__methodName__} | callback is not a function`);\n\n\t\tconst oldCallbackCount = HISTORY.popState.callbacks.length;\n\t\tHISTORY.popState.callbacks = HISTORY.popState.callbacks.reduce((cbs, cb) => {\n\t\t\tif( cb.original !== callback ){\n\t\t\t\tcbs.push(cb);\n\t\t\t}\n\n\t\t\treturn cbs;\n\t\t}, []);\n\t\tconst newCallbackCount = HISTORY.popState.callbacks.length;\n\n\t\tif( newCallbackCount === 0 ){\n\t\t\twindow.removeEventListener('popstate', HISTORY.popState.handler);\n\t\t\tHISTORY.popState.listening = false;\n\t\t}\n\n\t\treturn oldCallbackCount > newCallbackCount;\n\t} else {\n\t\tHISTORY.popState.callbacks = [];\n\t\twindow.removeEventListener('popstate', HISTORY.popState.handler);\n\t\tHISTORY.popState.listening = false;\n\n\t\treturn true;\n\t}\n}\n"]}
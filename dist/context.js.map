{"version":3,"file":"context.js","names":["MODULE_NAME","hasValue","isA","orDefault","Observable","throttle","reschedule","INTERACTION_TYPE_DETECTION","touchHappening","touchEndingTimer","touchStartHandler","CURRENT_INTERACTION_TYPE","getValue","setValue","touchEndHandler","blurHandler","mouseMoveHandler","browserSupportsHistoryManipulation","window","history","pushState","replaceState","contextHasHighDpi","matchMedia","matches","browserScrollbarWidth","sandbox","document","createElement","style","visibility","opacity","pointerEvents","overflow","position","top","right","left","height","scrollbarEnforcer","width","appendChild","body","scrollbarWidth","offsetWidth","removeChild","detectInteractionType","returnObservable","navigator","maxTouchPoints","addEventListener","detectAppleDevice","additionalTest","family","exec","userAgent","deviceType","Array","isArray","length","platform"],"sources":["context.js"],"mappings":";;;AAQA,MAAMA,YAAc,iBAMZC,SAAUC,IAAKC,UAAWC,eAAiB,oBAC3CC,aAAe,wBACfC,eAAiB,cAMzB,MAAMC,2BAA6B,CAClCC,gBAAiB,EACjBC,iBAAmB,KACnBC,oBACCH,2BAA2BC,gBAAiB,EACA,UAAxCG,yBAAyBC,YAC5BD,yBAAyBE,SAAS,QAEpC,EACAC,kBACCP,2BAA2BE,iBAAmBH,WAAWC,2BAA2BE,iBAAkB,MAAM,KAC3GF,2BAA2BC,gBAAiB,CAAK,GAEnD,EACAO,cACCR,2BAA2BE,iBAAmBH,WAAWC,2BAA2BE,iBAAkB,MAAM,KAC3GF,2BAA2BC,gBAAiB,CAAK,GAEnD,EACAQ,iBAAmBX,SAAS,KAAM,WAC5BM,yBAAyBC,SAAS,aAAgBL,2BAA2BC,gBACjFG,yBAAyBE,SAAS,UAEpC,YAGM,IAAIF,gCAuBJ,SAASM,qCACf,OAAOhB,SAASiB,OAAOC,UACnBjB,IAAIgB,OAAOC,QAAQC,UAAW,aAC9BlB,IAAIgB,OAAOC,QAAQE,aAAc,WAEtC,QAsBO,SAASC,oBACf,QAAIJ,OAAOK,YACHL,OAAOK,WACb,8RAMCC,OAIJ,QAwBO,SAASC,wBACf,MAAMC,EAAUC,SAASC,cAAc,OACvCF,EAAQG,MAAMC,WAAa,SAC3BJ,EAAQG,MAAME,QAAU,IACxBL,EAAQG,MAAMG,cAAgB,OAC9BN,EAAQG,MAAMI,SAAW,SACzBP,EAAQG,MAAMK,SAAW,QACzBR,EAAQG,MAAMM,IAAM,IACpBT,EAAQG,MAAMO,MAAQ,IACtBV,EAAQG,MAAMQ,KAAO,IAErBX,EAAQG,MAAMS,OAAS,OAEvB,MAAMC,EAAoBZ,SAASC,cAAc,OACjDW,EAAkBV,MAAMW,MAAQ,OAChCD,EAAkBV,MAAMS,OAAS,QAEjCZ,EAAQe,YAAYF,GACpBZ,SAASe,KAAKD,YAAYf,GAE1B,MAAMiB,EAAiBjB,EAAQkB,YAAcL,EAAkBK,YAI/D,OAFAjB,SAASe,KAAKG,YAAYnB,GAEnBiB,CACR,QAmCO,SAASG,sBAAsBC,GAAiB,GAiBtD,OAhBAA,EAAmB5C,UAAU4C,GAAkB,EAAO,QAEjD9C,SAASU,4BACbA,yBAA2B,IAAIP,WAAW,IACrC,iBAAkBuB,UAAc,eAAgBA,UAAcT,OAAO8B,UAAUC,eAAiB,EACpGtC,yBAAyBE,SAAS,SAElCF,yBAAyBE,SAAS,WAGnCc,SAASuB,iBAAiB,aAAc3C,2BAA2BG,mBACnEiB,SAASuB,iBAAiB,WAAY3C,2BAA2BO,iBACjEI,OAAOgC,iBAAiB,OAAQ3C,2BAA2BQ,aAC3DY,SAASuB,iBAAiB,YAAa3C,2BAA2BS,mBAG5D+B,EAAmBpC,yBAA2BA,yBAAyBC,UAC/E,QA2BO,SAASuC,kBAAkBC,EAAe,MAChD,IACCC,EAAS,6BAA6BC,KAAKpC,OAAO8B,UAAUO,WAC5DC,EAAa,KAmBd,GAhBIC,MAAMC,QAAQL,IAAYA,EAAOM,OAAS,EAC7CN,EAASA,EAAO,IAEhBA,EAAS,0BAA0BC,KAAKpC,OAAO8B,UAAUY,UAErDH,MAAMC,QAAQL,IAAYA,EAAOM,OAAS,GAC7CN,EAASA,EAAO,GAED,QAAXA,IACHA,EAAS,cAGVA,EAAS,MAIPpD,SAASoD,GAAS,CAUrB,OANa,cAAXA,GACGnC,OAAO8B,UAAUC,eAAiB,IAEtCI,EAAS,QAGFA,GACP,IAAK,OACJG,EAAa,OACd,MACA,IAAK,SACJA,EAAa,SACd,MACA,IAAK,OACJA,EAAa,OACd,MACA,IAAK,YACJA,EAAa,MAIXtD,IAAIkD,EAAgB,cACvBI,EAAaJ,EAAeI,GAE9B,CAEA,OAAOA,CACR","sourcesContent":["/*!\n * Module Context\n */\n\n/**\n * @namespace Context\n */\n\nconst MODULE_NAME = 'Context';\n\n\n\n//###[ IMPORTS ]########################################################################################################\n\nimport {hasValue, isA, orDefault, Observable} from './basic.js';\nimport {throttle} from './functions.js';\nimport {reschedule} from './timers.js';\n\n\n\n//###[ DATA ]###########################################################################################################\n\nconst INTERACTION_TYPE_DETECTION = {\n\ttouchHappening : false,\n\ttouchEndingTimer : null,\n\ttouchStartHandler(){\n\t\tINTERACTION_TYPE_DETECTION.touchHappening = true;\n\t\tif( CURRENT_INTERACTION_TYPE.getValue() !== 'touch' ){\n\t\t\tCURRENT_INTERACTION_TYPE.setValue('touch');\n\t\t}\n\t},\n\ttouchEndHandler(){\n\t\tINTERACTION_TYPE_DETECTION.touchEndingTimer = reschedule(INTERACTION_TYPE_DETECTION.touchEndingTimer, 1032, () => {\n\t\t\tINTERACTION_TYPE_DETECTION.touchHappening = false;\n\t\t});\n\t},\n\tblurHandler(){\n\t\tINTERACTION_TYPE_DETECTION.touchEndingTimer = reschedule(INTERACTION_TYPE_DETECTION.touchEndingTimer, 1032, () => {\n\t\t\tINTERACTION_TYPE_DETECTION.touchHappening = false;\n\t\t});\n\t},\n\tmouseMoveHandler : throttle(1000, function(){\n\t\tif( (CURRENT_INTERACTION_TYPE.getValue('pointer')) && !INTERACTION_TYPE_DETECTION.touchHappening ){\n\t\t\tCURRENT_INTERACTION_TYPE.setValue('pointer');\n\t\t}\n\t})\n};\n\nexport let CURRENT_INTERACTION_TYPE;\n\n\n\n//###[ EXPORTS ]########################################################################################################\n\n/**\n * @namespace Context:browserSupportsHistoryManipulation\n */\n\n/**\n * Detects if the browser supports history manipulation, by checking the most common\n * methods for presence in the history-object.\n *\n * @returns {Boolean} true if browser seems to support history manipulation\n *\n * @memberof Context:browserSupportsHistoryManipulation\n * @alias browserSupportsHistoryManipulation\n * @example\n * if( browserSupportsHistoryManipulation() ){\n *   window.history.replaceState(null, 'test', '/test');\n * }\n */\nexport function browserSupportsHistoryManipulation(){\n\treturn hasValue(window.history)\n\t\t&& isA(window.history.pushState, 'function')\n\t\t&& isA(window.history.replaceState, 'function')\n\t;\n}\n\n\n\n/**\n * @namespace Context:contextHasHighDpi\n */\n\n/**\n * Checks if the context would benefit from high DPI graphics.\n *\n * @returns {Boolean} true if device has high DPI, false if not or browser does not support media queries\n *\n * @memberof Context:contextHasHighDpi\n * @alias contextHasHighDpi\n * @example\n * if( contextHasHighDpi() ){\n *     document.querySelectorAll('img').forEach(img => {\n *         img.setAttribute('src', img.getAttribute('src').replace('.jpg', '@2x.jpg'));\n *     });\n * }\n */\nexport function contextHasHighDpi(){\n\tif( window.matchMedia ){\n\t\treturn window.matchMedia(\n\t\t\t'only screen and (-webkit-min-device-pixel-ratio: 1.5),'\n\t\t\t+'only screen and (-o-min-device-pixel-ratio: 3/2),'\n\t\t\t+'only screen and (min--moz-device-pixel-ratio: 1.5),'\n\t\t\t+'only screen and (min-device-pixel-ratio: 1.5),'\n\t\t\t+'only screen and (min-resolution: 144dpi),'\n\t\t\t+'only screen and (min-resolution: 1.5dppx)'\n\t\t).matches;\n\t} else {\n\t\treturn false;\n\t}\n}\n\n\n\n/**\n * @namespace Context:browserScrollbarWidth\n */\n\n/**\n * Returns the current context's scrollbar width. Returns 0 if scrollbar is over content.\n * There are edge cases in which we might want to calculate positions in respect to the\n * actual width of the scrollbar. For example when working with elements with a 100vw width.\n *\n * This method temporarily inserts three elements into the body while forcing the body to\n * actually show scrollbars, measuring the difference between 100vw and 100% on the body and\n * returns the result.\n *\n * @returns {Number} the width of the body scrollbar in pixels\n *\n * @memberof Context:browserScrollbarWidth\n * @alias browserScrollbarWidth\n * @example\n * foobarElement.style.width = `calc(100vw - ${browserScrollbarWidth()}px)`;\n */\nexport function browserScrollbarWidth(){\n\tconst sandbox = document.createElement('div');\n\tsandbox.style.visibility = 'hidden';\n\tsandbox.style.opacity = '0';\n\tsandbox.style.pointerEvents = 'none';\n\tsandbox.style.overflow = 'scroll';\n\tsandbox.style.position = 'fixed';\n\tsandbox.style.top = '0';\n\tsandbox.style.right = '0';\n\tsandbox.style.left = '0';\n\t// firefox needs container to be at least 30px high to display scrollbar\n\tsandbox.style.height = '50px';\n\n\tconst scrollbarEnforcer = document.createElement('div');\n\tscrollbarEnforcer.style.width = '100%';\n\tscrollbarEnforcer.style.height = '100px';\n\n\tsandbox.appendChild(scrollbarEnforcer);\n\tdocument.body.appendChild(sandbox);\n\n\tconst scrollbarWidth = sandbox.offsetWidth - scrollbarEnforcer.offsetWidth;\n\n\tdocument.body.removeChild(sandbox);\n\n\treturn scrollbarWidth;\n}\n\n\n\n/**\n * @namespace Context:detectInteractionType\n */\n\n/**\n * Try to figure out the current type of interaction between the user and the document.\n * This is determined by the input device and is currently limited to either \"pointer\" or \"touch\".\n *\n * On call the function returns an educated guess about the fact what interaction type might be more\n * probable based on browser features and sets up event listeners to update Context module's CURRENT_INTERACTION_TYPE\n * observable (to which you may subscribe to be informed about updates), when interaction type should change while\n * the page is being interacted with. In case a touch occurs we determine touch interaction and\n * on mousemove we determine pointer interaction. If you use this observable to set up a class on your document for\n * example you can even relatively safely handle dual devices like a surface book.\n *\n * Hint: because touch devices also emit a single mousemove after touchend with a single touch we have to block\n * mousemove detection for 1s after the last touchend. Therefore, it takes up to 1s after the last touch event until\n * we are able to detect the change to a pointer device.\n *\n * @param {?Boolean} [returnObservable=false] - if set to true, the call returns Context module's CURRENT_INTERACTION_TYPE observable\n * @returns {String|Observable} interaction type string \"pointer\" or \"touch\", or the CURRENT_INTERACTION_TYPE observable\n *\n * @memberof Context:detectInteractionType\n * @alias detectInteractionType\n * @example\n * let interactionTypeGuess = detectInteractionType();\n * detectInteractionType(true).subscribe(function(type){\n *     document.body.classList.toggle('touch', type === 'touch');\n * });\n */\n\nexport function detectInteractionType(returnObservable=false){\n\treturnObservable = orDefault(returnObservable, false, 'bool');\n\n\tif( !hasValue(CURRENT_INTERACTION_TYPE) ){\n\t\tCURRENT_INTERACTION_TYPE = new Observable('');\n\t\tif( ('ontouchstart' in document) && ('ontouchend' in document) && (window.navigator.maxTouchPoints > 0) ){\n\t\t\tCURRENT_INTERACTION_TYPE.setValue('touch');\n\t\t} else {\n\t\t\tCURRENT_INTERACTION_TYPE.setValue('pointer');\n\t\t}\n\n\t\tdocument.addEventListener('touchstart', INTERACTION_TYPE_DETECTION.touchStartHandler);\n\t\tdocument.addEventListener('touchend', INTERACTION_TYPE_DETECTION.touchEndHandler);\n\t\twindow.addEventListener('blur', INTERACTION_TYPE_DETECTION.blurHandler);\n\t\tdocument.addEventListener('mousemove', INTERACTION_TYPE_DETECTION.mouseMoveHandler);\n\t}\n\n\treturn returnObservable ? CURRENT_INTERACTION_TYPE : CURRENT_INTERACTION_TYPE.getValue();\n}\n\n\n\n/**\n * @namespace Context:detectAppleDevice\n */\n\n/**\n * Try to determine if the execution context is an Apple device and if so: which type.\n *\n * We use an escalating test starting with the user agent and then, as a fallback, checking the platform value\n * to determine the general device class (iPhone, iPad ,iPod ,Macintosh). If we get a Macintosh, we double check\n * if the device might be a falsely reporting iPad with iPadOS13+.\n *\n * You can hook up additional tests by providing an \"additionalTest\" function as a function parameter,\n * that function takes the evaluated device type at the end of the function and expects a new device type to be\n * returned. Using this, you can tap into the process and handle edge cases yourself.\n *\n * @param {?Function} [additionalTest=null] - if set, is executed after determining the device type, takes the current device type as parameter and is expected to return a new one; use this to add edge case tests to overwrite the result in certain conditions\n * @returns {String} \"ipad\", \"iphone\", \"ipod\" or \"mac\"\n *\n * @memberof Context:detectAppleDevice\n * @alias detectAppleDevice\n * @example\n * const IS_IOS_DEVICE = ['iphone', 'ipod', 'ipad'].includes(detectAppleDevice());\n */\nexport function detectAppleDevice(additionalTest=null){\n\tlet\n\t\tfamily = /iPhone|iPad|iPod|Macintosh/.exec(window.navigator.userAgent),\n\t\tdeviceType = null\n\t;\n\n\tif( Array.isArray(family) && (family.length > 0) ){\n\t\tfamily = family[0];\n\t} else {\n\t\tfamily = /^(iPhone|iPad|iPod|Mac)/.exec(window.navigator.platform);\n\n\t\tif( Array.isArray(family) && (family.length > 0) ){\n\t\t\tfamily = family[0];\n\n\t\t\tif( family === 'Mac' ){\n\t\t\t\tfamily = 'Macintosh';\n\t\t\t}\n\t\t} else {\n\t\t\tfamily = null;\n\t\t}\n\t}\n\n\tif( hasValue(family) ){\n\t\t// If User-Agent reports Macintosh double check this against touch points, since the device might\n\t\t// be a disguised iPad with i(Pad)Os13+\n\t\tif(\n\t\t\t(family === 'Macintosh')\n\t\t\t&& (window.navigator.maxTouchPoints > 1)\n\t\t){\n\t\t\tfamily = 'iPad';\n\t\t}\n\n\t\tswitch( family ) {\n\t\t\tcase 'iPad':\n\t\t\t\tdeviceType = 'ipad';\n\t\t\tbreak;\n\t\t\tcase 'iPhone':\n\t\t\t\tdeviceType = 'iphone';\n\t\t\tbreak;\n\t\t\tcase 'iPod':\n\t\t\t\tdeviceType = 'ipod';\n\t\t\tbreak;\n\t\t\tcase 'Macintosh':\n\t\t\t\tdeviceType = 'mac';\n\t\t\tbreak;\n\t\t}\n\n\t\tif( isA(additionalTest, 'function') ){\n\t\t\tdeviceType = additionalTest(deviceType);\n\t\t}\n\t}\n\n\treturn deviceType;\n}\n"]}
{"version":3,"sources":["context.js"],"names":["MODULE_NAME","hasValue","isA","orDefault","throttle","createNode","reschedule","CURRENT_INTERACTION_TYPE","detectInteractionType","browserSupportsHistoryManipulation","window","history","pushState","replaceState","contextHasHighDpi","matchMedia","matches","browserScrollbarWidth","sandbox","style","visibility","opacity","pointerEvents","overflow","position","top","right","left","height","scrollbarEnforcer","width","appendChild","document","body","scrollbarWidth","offsetWidth","removeChild","changeCallback","initialCallbackCall","navigator","maxTouchPoints","touchHappening","touchEndingTimer","addEventListener","detectAppleDevice","additionalTest","family","exec","userAgent","deviceType","Array","isArray","length","platform"],"mappings":";;;AAQA,MAAMA,YAAc,iBAIZC,SAAUC,IAAKC,cAAgB,oBAC/BC,aAAe,wBACfC,eAAiB,uBACjBC,eAAiB,qBAMlB,IAAIC,yBACXA,yBAA2BC,+BAqBpB,SAASC,qCACf,OAAOR,SAASS,OAAOC,UACnBT,IAAIQ,OAAOC,QAAQC,UAAW,aAC9BV,IAAIQ,OAAOC,QAAQE,aAAc,mBAwB/B,SAASC,oBACf,QAAIJ,OAAOK,YACHL,OAAOK,WACb,8RAMCC,eA4BG,SAASC,wBACf,MAAMC,EAAUb,WAAW,OAC3Ba,EAAQC,MAAMC,WAAa,SAC3BF,EAAQC,MAAME,QAAU,IACxBH,EAAQC,MAAMG,cAAgB,OAC9BJ,EAAQC,MAAMI,SAAW,SACzBL,EAAQC,MAAMK,SAAW,QACzBN,EAAQC,MAAMM,IAAM,IACpBP,EAAQC,MAAMO,MAAQ,IACtBR,EAAQC,MAAMQ,KAAO,IAErBT,EAAQC,MAAMS,OAAS,OAEvB,MAAMC,EAAoBxB,WAAW,OACrCwB,EAAkBV,MAAMW,MAAQ,OAChCD,EAAkBV,MAAMS,OAAS,QAEjCV,EAAQa,YAAYF,GACpBG,SAASC,KAAKF,YAAYb,GAE1B,MAAMgB,EAAiBhB,EAAQiB,YAAcN,EAAkBM,YAI/D,OAFAH,SAASC,KAAKG,YAAYlB,GAEnBgB,SAuCD,SAAS1B,sBAAsB6B,EAAgBC,GAAoB,GASzE,GARAA,EAAsBnC,UAAUmC,GAAqB,EAAO,QAG3D/B,yBADI,iBAAkByB,UAAc,eAAgBA,UAActB,OAAO6B,UAAUC,eAAiB,EACzE,QAEA,UAGxBtC,IAAImC,EAAgB,YAAa,CACpC,IACCI,GAAiB,EACjBC,EAAmB,KAGpBV,SAASW,iBAAiB,cAAc,KACvCF,GAAiB,EAEgB,UAA7BlC,2BACHA,yBAA2B,QAC3B8B,EAAe9B,8BAIjByB,SAASW,iBAAiB,YAAY,KACrCD,EAAmBpC,WAAWoC,EAAkB,MAAM,KACrDD,GAAiB,QAInB/B,OAAOiC,iBAAiB,QAAQ,KAC/BD,EAAmBpC,WAAWoC,EAAkB,MAAM,KACrDD,GAAiB,QAInBT,SAASW,iBAAiB,YAAavC,SAAS,KAAM,KACnB,YAA7BG,0BAA4CkC,IAChDlC,yBAA2B,UAC3B8B,EAAe9B,+BAIb+B,GACHD,EAAe9B,0BAIjB,OAAOA,gCA4BD,SAASqC,kBAAkBC,GACjC,IACCC,EAAS,6BAA6BC,KAAKrC,OAAO6B,UAAUS,WAC5DC,EAAa,KAmBd,GAhBIC,MAAMC,QAAQL,IAAYA,EAAOM,OAAS,EAC7CN,EAASA,EAAO,IAEhBA,EAAS,0BAA0BC,KAAKrC,OAAO6B,UAAUc,UAErDH,MAAMC,QAAQL,IAAYA,EAAOM,OAAS,GAC7CN,EAASA,EAAO,GAED,QAAXA,IACHA,EAAS,cAGVA,EAAS,MAIP7C,SAAS6C,GAAS,CAUrB,OANa,cAAXA,GACGpC,OAAO6B,UAAUC,eAAiB,IAEtCM,EAAS,QAGFA,GACP,IAAK,OACJG,EAAa,OACb,MACD,IAAK,SACJA,EAAa,SACb,MACD,IAAK,OACJA,EAAa,OACb,MACD,IAAK,YACJA,EAAa,MAIX/C,IAAI2C,EAAgB,cACvBI,EAAaJ,EAAeI,IAI9B,OAAOA","file":"context.js","sourcesContent":["/*!\n * Module Context\n */\n\n/**\n * @namespace Context\n */\n\nconst MODULE_NAME = 'Context';\n\n\n\nimport {hasValue, isA, orDefault} from './basic.js';\nimport {throttle} from './functions.js';\nimport {createNode} from './elements.js';\nimport {reschedule} from './timers.js';\n\n\n\n//###( MODULE DATA )###\n\nexport let CURRENT_INTERACTION_TYPE;\nCURRENT_INTERACTION_TYPE = detectInteractionType();\n\n\n\n/**\n * @namespace Context:browserSupportsHistoryManipulation\n */\n\n/**\n * Detects if the browser supports history manipulation, by checking the most common\n * methods for presence in the history-object.\n *\n * @returns {Boolean} true if browser seems to support history manipulation\n *\n * @memberof Context:browserSupportsHistoryManipulation\n * @alias browserSupportsHistoryManipulation\n * @example\n * if( browserSupportsHistoryManipulation() ){\n *   window.history.replaceState(null, 'test', '/test');\n * }\n */\nexport function browserSupportsHistoryManipulation(){\n\treturn hasValue(window.history)\n\t\t&& isA(window.history.pushState, 'function')\n\t\t&& isA(window.history.replaceState, 'function')\n\t;\n}\n\n\n\n/**\n * @namespace Context:contextHasHighDpi\n */\n\n/**\n * Checks if the context would benefit from high DPI graphics.\n *\n * @returns {Boolean} true if device has high DPI, false if not or browser does not support media queries\n *\n * @memberof Context:contextHasHighDpi\n * @alias contextHasHighDpi\n * @example\n * if( contextHasHighDpi() ){\n *     document.querySelectorAll('img').forEach(img => {\n *         img.setAttribute('src', img.getAttribute('src').replace('.jpg', '@2x.jpg'));\n *     });\n * }\n */\nexport function contextHasHighDpi(){\n\tif( window.matchMedia ){\n\t\treturn window.matchMedia(\n\t\t\t'only screen and (-webkit-min-device-pixel-ratio: 1.5),'\n\t\t\t+'only screen and (-o-min-device-pixel-ratio: 3/2),'\n\t\t\t+'only screen and (min--moz-device-pixel-ratio: 1.5),'\n\t\t\t+'only screen and (min-device-pixel-ratio: 1.5),'\n\t\t\t+'only screen and (min-resolution: 144dpi),'\n\t\t\t+'only screen and (min-resolution: 1.5dppx)'\n\t\t).matches;\n\t} else {\n\t\treturn false;\n\t}\n}\n\n\n\n/**\n * @namespace Context:browserScrollbarWidth\n */\n\n/**\n * Returns the current context's scrollbar width. Returns 0 if scrollbar is over content.\n * There are edge cases in which we might want to calculate positions in respect to the\n * actual width of the scrollbar. For example when working with elements with a 100vw width.\n *\n * This method temporarily inserts three elements into the body while forcing the body to\n * actually show scrollbars, measuring the difference between 100vw and 100% on the body and\n * returns the result.\n *\n * @returns {Number} the width of the body scrollbar in pixels\n *\n * @memberof Context:browserScrollbarWidth\n * @alias browserScrollbarWidth\n * @example\n * foobarElement.style.width = `calc(100vw - ${browserScrollbarWidth()}px)`;\n */\nexport function browserScrollbarWidth(){\n\tconst sandbox = createNode('div');\n\tsandbox.style.visibility = 'hidden';\n\tsandbox.style.opacity = '0';\n\tsandbox.style.pointerEvents = 'none';\n\tsandbox.style.overflow = 'scroll';\n\tsandbox.style.position = 'fixed';\n\tsandbox.style.top = '0';\n\tsandbox.style.right = '0';\n\tsandbox.style.left = '0';\n\t// firefox needs container to be at least 30px high to display scrollbar\n\tsandbox.style.height = '50px';\n\n\tconst scrollbarEnforcer = createNode('div');\n\tscrollbarEnforcer.style.width = '100%';\n\tscrollbarEnforcer.style.height = '100px';\n\n\tsandbox.appendChild(scrollbarEnforcer);\n\tdocument.body.appendChild(sandbox);\n\n\tconst scrollbarWidth = sandbox.offsetWidth - scrollbarEnforcer.offsetWidth;\n\n\tdocument.body.removeChild(sandbox);\n\n\treturn scrollbarWidth;\n}\n\n\n\n/**\n * @namespace Context:detectInteractionType\n */\n\n/**\n * Try to figure out the current type of interaction between the user and the document.\n * This is determined by the input device and is currently limited to either \"pointer\" or \"touch\".\n *\n * On call the function return an educated guess about the fact what interaction type might be more\n * probable based on browser features.\n *\n * Additionally, you can (and maybe should) provide a changeCallback, which gets an updated value\n * if the interaction type changes, based on event listeners listening to interaction-specific user events.\n * In case a touch occurs we determine touch interaction and on mousemove we determine pointer interaction.\n * If you use this callback to set up a class on your document or update an observable you can even relatively\n * safely handle dual devices like a surface book.\n *\n * Hint: because touch devices also emit a single mousemove after touchend with a single touch we have to block\n * mousemove detection for 1s after the last touchend. Therefore it takes up to 1s after the last touch event until\n * we are able to detect the change to a pointer device.\n *\n * @param {?Function} [changeCallback] - gets executed if the interaction type changes and takes one parameter with the current interaction type value\n * @param {?Boolean} [initialCallbackCall=false] - if set to true, executes the callback immediately once\n * @returns {String} \"pointer\" or \"touch\"\n *\n * @memberof Context:detectInteractionType\n * @alias detectInteractionType\n * @example\n * let interactionTypeGuess = detectInteractionType();\n * detectInteractionType(function(type){\n *     document.body.classList.toggle('touch', type === 'touch');\n * }, true);\n */\n\nexport function detectInteractionType(changeCallback, initialCallbackCall=false){\n\tinitialCallbackCall = orDefault(initialCallbackCall, false, 'bool');\n\n\tif( ('ontouchstart' in document) && ('ontouchend' in document) && (window.navigator.maxTouchPoints > 0) ){\n\t\tCURRENT_INTERACTION_TYPE = 'touch';\n\t} else {\n\t\tCURRENT_INTERACTION_TYPE = 'pointer';\n\t}\n\n\tif( isA(changeCallback, 'function') ){\n\t\tlet\n\t\t\ttouchHappening = false,\n\t\t\ttouchEndingTimer = null\n\t\t;\n\n\t\tdocument.addEventListener('touchstart', () => {\n\t\t\ttouchHappening = true;\n\n\t\t\tif( CURRENT_INTERACTION_TYPE !== 'touch' ){\n\t\t\t\tCURRENT_INTERACTION_TYPE = 'touch';\n\t\t\t\tchangeCallback(CURRENT_INTERACTION_TYPE);\n\t\t\t}\n\t\t});\n\n\t\tdocument.addEventListener('touchend', () => {\n\t\t\ttouchEndingTimer = reschedule(touchEndingTimer, 1032, () => {\n\t\t\t\ttouchHappening = false;\n\t\t\t});\n\t\t});\n\n\t\twindow.addEventListener('blur', () => {\n\t\t\ttouchEndingTimer = reschedule(touchEndingTimer, 1032, () => {\n\t\t\t\ttouchHappening = false;\n\t\t\t});\n\t\t});\n\n\t\tdocument.addEventListener('mousemove', throttle(1000, () => {\n\t\t\tif( (CURRENT_INTERACTION_TYPE !== 'pointer') && !touchHappening ){\n\t\t\t\tCURRENT_INTERACTION_TYPE = 'pointer';\n\t\t\t\tchangeCallback(CURRENT_INTERACTION_TYPE);\n\t\t\t}\n\t\t}));\n\n\t\tif( initialCallbackCall ){\n\t\t\tchangeCallback(CURRENT_INTERACTION_TYPE);\n\t\t}\n\t}\n\n\treturn CURRENT_INTERACTION_TYPE;\n}\n\n\n\n/**\n * @namespace Context:detectAppleDevice\n */\n\n/**\n * Try to determine if the execution context is an Apple device and if so: which type.\n *\n * We use an escalating test starting with the user agent and then, as a fallback, checking the platform value\n * to determine the general device class (iPhone, iPad ,iPod ,Macintosh). If we get a Macintosh, we double check\n * if the device might be a falsely reporting iPad with iPadOS13+.\n *\n * You can hook up additional tests by providing an \"additionalTest\" function as a function parameter,\n * that function takes the evaluated device type at the end of the function and expects a new device type to be\n * returned. Using this, you can tap into the process and handle edge cases yourself.\n *\n * @param {?Function} [additionalTest] - if set, is executed after determining the device type, takes the current device type as parameter and is expected to return a new one; use this to add edge case tests to overwrite the result in certain conditions\n * @returns {String} \"ipad\", \"iphone\", \"ipod\" or \"mac\"\n *\n * @memberof Context:detectAppleDevice\n * @alias detectAppleDevice\n * @example\n * const IS_IOS_DEVICE = ['iphone', 'ipod', 'ipad'].includes(detectAppleDevice());\n */\nexport function detectAppleDevice(additionalTest){\n\tlet\n\t\tfamily = /iPhone|iPad|iPod|Macintosh/.exec(window.navigator.userAgent),\n\t\tdeviceType = null\n\t;\n\n\tif( Array.isArray(family) && (family.length > 0) ){\n\t\tfamily = family[0];\n\t} else {\n\t\tfamily = /^(iPhone|iPad|iPod|Mac)/.exec(window.navigator.platform);\n\n\t\tif( Array.isArray(family) && (family.length > 0) ){\n\t\t\tfamily = family[0];\n\n\t\t\tif( family === 'Mac' ){\n\t\t\t\tfamily = 'Macintosh';\n\t\t\t}\n\t\t} else {\n\t\t\tfamily = null;\n\t\t}\n\t}\n\n\tif( hasValue(family) ){\n\t\t// If User-Agent reports Macintosh double check this against touch points, since the device might\n\t\t// be a disguised iPad with i(Pad)Os13+\n\t\tif(\n\t\t\t(family === 'Macintosh')\n\t\t\t&& (window.navigator.maxTouchPoints > 1)\n\t\t){\n\t\t\tfamily = 'iPad';\n\t\t}\n\n\t\tswitch( family ) {\n\t\t\tcase 'iPad':\n\t\t\t\tdeviceType = 'ipad';\n\t\t\t\tbreak;\n\t\t\tcase 'iPhone':\n\t\t\t\tdeviceType = 'iphone';\n\t\t\t\tbreak;\n\t\t\tcase 'iPod':\n\t\t\t\tdeviceType = 'ipod';\n\t\t\t\tbreak;\n\t\t\tcase 'Macintosh':\n\t\t\t\tdeviceType = 'mac';\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif( isA(additionalTest, 'function') ){\n\t\t\tdeviceType = additionalTest(deviceType);\n\t\t}\n\t}\n\n\treturn deviceType;\n}\n"]}
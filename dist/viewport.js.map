{"version":3,"file":"viewport.js","names":["MODULE_NAME","hasValue","orDefault","isWindow","isFunction","isElement","Deferred","assert","EasingFunctions","requestAnimationFrame","isInViewport","element","mustBeFullyInside","bb","viewportBounds","getBoundingClientRect","err","top","right","window","innerWidth","bottom","innerHeight","left","scrollTo","durationMs","offset","easing","scrollEvenIfFullyInViewport","cancelOnUserScroll","easeInOutCubic","res","elementIsWindow","self","elementInViewport","start","targetY","cancelled","startY","pageYOffset","Math","round","diff","fScroll","timestamp","time","progress","min","resolve","fCancelScroll","reject","Error","removeEventListener","addEventListener"],"sources":["viewport.js"],"mappings":";;;AAQA,MAAMA,YAAc,kBAMZC,SAAUC,UAAWC,SAAUC,WAAYC,UAAWC,SAAUC,WAAa,oBAC7EC,oBAAsB,wBACtBC,0BAA4B,qBA0B7B,SAASC,aAAaC,EAASC,GAAkB,GAGvD,IAAIC,EAQAC,EAVJF,EAAoBV,UAAUU,GAAmB,EAAO,QAGxD,IACCC,EAAKF,EAAQI,uBAId,CAHE,MAAMC,GAEP,OAAO,CACR,CAmBA,OAfCF,EADGF,EACc,CAChBK,IAAK,EACLC,MAAQC,OAAOC,WACfC,OAASF,OAAOG,YAChBC,KAAO,GAGS,CAChBN,IAA8B,GAAtBJ,EAAGQ,OAASR,EAAGI,KACvBC,MAASC,OAAOC,YAAcP,EAAGK,MAAQL,EAAGU,MAAS,EACrDF,OAAUF,OAAOG,aAAeT,EAAGQ,OAASR,EAAGI,KAAQ,EACvDM,KAA+B,GAAtBV,EAAGK,MAAQL,EAAGU,OAKxBV,EAAGI,KAAOH,EAAeG,KACzBJ,EAAGK,OAASJ,EAAeI,OAC3BL,EAAGU,MAAQT,EAAeS,MAC1BV,EAAGQ,QAAUP,EAAeO,MAE9B,QAyCO,SAASG,SAASb,EAASc,EAAW,IAAMC,EAAO,EAAGC,EAAO,iBAAkBC,GAA4B,EAAOC,GAAmB,GAC3IJ,EAAavB,UAAUuB,EAAY,IAAM,OACzCC,EAASxB,UAAUwB,EAAQ,EAAG,OAC9BC,EAASzB,UAAUyB,EAAQ,iBAAkB,OAC7CC,EAA8B1B,UAAU0B,GAA6B,EAAO,QAC5EC,EAAqB3B,UAAU2B,GAAoB,EAAO,QAE1DtB,OAAOF,UAAUM,IAAYR,SAASQ,GAAU,wCAChDJ,OAAOkB,EAAa,EAAG,8CAKtBE,EAHIvB,WAAWI,gBAAgBmB,IAGtBnB,gBAAgBmB,GAFhBnB,gBAAgBsB,eAK1B,MACCC,EAAM,IAAIzB,SACV0B,EAAmBrB,EAAQsB,OAAStB,EAIrC,IAAIuB,GAAoBF,GAA0BtB,aAAaC,GAAS,GAGxE,IACCA,EAAQI,uBAGT,CAFE,MAAMC,GACPkB,GAAoB,CACrB,CAEA,GAAIN,IAAgCM,EAAmB,CACtD,IAAIC,EAAOC,EAASC,GAAY,EAChC,MAAMC,EAASnB,OAAOoB,YAGrBH,EADGJ,EACON,EAEAP,OAAOoB,YAAc5B,EAAQI,wBAAwBE,IAAMuB,KAAKC,MAAMtB,OAAOG,YAAc,GAAKI,EAG3G,MACCgB,EAAON,EAAUE,EACjBK,EAAU,SAASC,GAClB,IAAKP,EAAW,CACVpC,SAASkC,KACbA,EAAQS,GAGT,MACCC,EAAOD,EAAYT,EACnBW,EAAWnB,EAAOa,KAAKO,IAAIF,EAAOpB,EAAY,IAG/CN,OAAOK,SAAS,EAAGc,EAAUI,EAAOI,GAE/BD,EAAOpB,GAAgBqB,EAAW,EACtCrC,sBAAsBkC,GAEtBZ,EAAIiB,SAEN,CACD,EAGD,GAAInB,EAAoB,CACvB,MAAMoB,EAAgB,WACrBZ,GAAY,EACZN,EAAImB,OAAO,IAAIC,MAAM,cACrBhC,OAAOiC,oBAAoB,iBAAkBH,GAC7C9B,OAAOiC,oBAAoB,aAAcH,EAC1C,EAEA9B,OAAOkC,iBAAiB,iBAAkBJ,GAC1C9B,OAAOkC,iBAAiB,aAAcJ,EACvC,CAEa,IAATP,GACHjC,sBAAsBkC,EAExB,CAEA,OAAOZ,CACR","sourcesContent":["/*!\n * Module Viewport\n */\n\n/**\n * @namespace Viewport\n */\n\nconst MODULE_NAME = 'Viewport';\n\n\n\n//###[ IMPORTS ]########################################################################################################\n\nimport {hasValue, orDefault, isWindow, isFunction, isElement, Deferred, assert} from './basic.js';\nimport {EasingFunctions} from './animation.js';\nimport {requestAnimationFrame} from './timers.js';\n\n\n\n//###[ EXPORTS ]########################################################################################################\n\n/**\n * @namespace Viewport:isInViewport\n */\n\n/**\n * Returns if the current element is visible in the window's viewport at the moment.\n * This method uses getBoundingClientRect(), which has to be supported by the browser, otherwise\n * the method will always return true.\n *\n * @param {HTMLElement} element - the element to check\n * @param {?Boolean} [mustBeFullyInside=false] - defines if the element has to be fully enclosed in the viewport, default is false\n * @returns {Boolean} true if in viewport\n *\n * @memberof Viewport:isInViewport\n * @alias isInViewport\n * @example\n * if( isInViewport(document.querySelector('div.moving'), true) ){\n *   ...\n * }\n */\nexport function isInViewport(element, mustBeFullyInside=false){\n\tmustBeFullyInside = orDefault(mustBeFullyInside, false, 'bool');\n\n\tlet bb;\n\ttry {\n\t\tbb = element.getBoundingClientRect();\n\t} catch(err){\n\t\t// if we cannot calculate position, we must assume the element is in\n\t\treturn true;\n\t}\n\n\tlet viewportBounds;\n\tif( mustBeFullyInside ){\n\t\tviewportBounds = {\n\t\t\ttop: 0,\n\t\t\tright : window.innerWidth,\n\t\t\tbottom : window.innerHeight,\n\t\t\tleft : 0\n\t\t};\n\t} else {\n\t\tviewportBounds = {\n\t\t\ttop : -(bb.bottom - bb.top) + 1,\n\t\t\tright : (window.innerWidth + (bb.right - bb.left)) + 1,\n\t\t\tbottom : (window.innerHeight + (bb.bottom - bb.top)) + 1,\n\t\t\tleft : -(bb.right - bb.left) + 1\n\t\t};\n\t}\n\n\treturn (\n\t\tbb.top >= viewportBounds.top &&\n\t\tbb.right <= viewportBounds.right &&\n\t\tbb.left >= viewportBounds.left &&\n\t\tbb.bottom <= viewportBounds.bottom\n\t);\n}\n\n\n\n/**\n * @namespace Viewport:scrollTo\n */\n\n/**\n * Scrolls the viewport to the element's position (first pixel at half viewport height).\n * Does not do anything if target element is already fully in viewport, unless scrollEvenIfFullyInViewport is set to\n * true. Uses getBoundingClientRect to measure viewport check, scrolls always if missing.\n *\n * If you use this function on a window, the offset is directly used as scrollTop, so this function may also be used for\n * things like back to top buttons.\n *\n * Scrolls may be cancelled by setting cancelOnUserScroll to true, but keep in mind, that this will only work\n * with mousewheels and (maybe) touchpads on modern browsers. No keyboard or scrollbar support yet.\n * The root of the problem is that a user scroll is indistinguishable from a js-triggered scroll,\n * since both trigger the scroll event and look exactly the same. So we have to use exotic\n * and specific events like mousewheel and DOMMouseScroll. So, please, use cancelOnUserScroll only\n * as a convenience option and not as a must.\n *\n *\n * @param {HTMLElement|Window} element - the element to scroll to or the window to scroll within\n * @param {?Number} [durationMs=1000] - duration of the scrolling animation\n * @param {?Number} [offset=0] - offset from the viewport center to apply to the end position\n * @param {?String} [easing='easeInOutCubic'] - easing function to use, can be any of Animation.EasingFunctions\n * @param {?Boolean} [scrollEvenIfFullyInViewport=false] - if true, forces method to always scroll no matter the element's position\n * @param {?Boolean} [cancelOnUserScroll=false] - if true, scrolling animation will immediately be canceled on manual user scroll, return value will not resolve in that case\n * @throws error if element is not usable or if durationMs is <= 0\n * @returns {Deferred} resolves when scroll complete, rejects if scroll fails or is cancelled\n *\n * @memberof Viewport:scrollTo\n * @alias scrollTo\n * @see EasingFunctions\n * @example\n * document.querySelector('a.jumpitem').addEventListener('click', function(){ scrollTo(document.querySelector('.jumptarget'), function(){ alert('scrolled!'); }, 500, -100, true); });\n * scrollTo(document.querySelector('.jumptarget'), function(){ alert('Not triggered if user uses mousewheel.'); }, 5000, -0, false, true);\n * scrollTo(window, null, 500, 0, false, true);\n */\nexport function scrollTo(element, durationMs=1000, offset=0, easing='easeInOutCubic', scrollEvenIfFullyInViewport=false, cancelOnUserScroll=false){\n\tdurationMs = orDefault(durationMs, 1000, 'int');\n\toffset = orDefault(offset, 0, 'int');\n\teasing = orDefault(easing, 'easeInOutCubic', 'str');\n\tscrollEvenIfFullyInViewport = orDefault(scrollEvenIfFullyInViewport, false, 'bool');\n\tcancelOnUserScroll = orDefault(cancelOnUserScroll, false, 'bool');\n\n\tassert(isElement(element) || isWindow(element), `${MODULE_NAME}:scrollTo | element unusable`);\n\tassert(durationMs > 0, `${MODULE_NAME}:scrollTo | durationMs must be > 0`);\n\n\tif( !isFunction(EasingFunctions[easing]) ){\n\t\teasing = EasingFunctions.easeInOutCubic;\n\t} else {\n\t\teasing = EasingFunctions[easing];\n\t}\n\n\tconst\n\t\tres = new Deferred(),\n\t\telementIsWindow = (element.self === element)\n\t;\n\n\t// the window itself is considered not to be in viewport\n\tlet elementInViewport = elementIsWindow ? false : isInViewport(element, true);\n\n\t// in this case missing support for bounding rects should result in scrolling\n\ttry {\n\t\telement.getBoundingClientRect();\n\t} catch(err){\n\t\telementInViewport = false;\n\t}\n\n\tif( scrollEvenIfFullyInViewport || !elementInViewport ){\n\t\tlet start, targetY, cancelled = false;\n\t\tconst startY = window.pageYOffset;\n\n\t\tif( elementIsWindow ){\n\t\t\ttargetY = offset;\n\t\t} else {\n\t\t\ttargetY = window.pageYOffset + element.getBoundingClientRect().top - Math.round(window.innerHeight / 2) + offset;\n\t\t}\n\n\t\tconst\n\t\t\tdiff = targetY - startY,\n\t\t\tfScroll = function(timestamp){\n\t\t\t\tif( !cancelled ){\n\t\t\t\t\tif( !hasValue(start) ){\n\t\t\t\t\t\tstart = timestamp;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst\n\t\t\t\t\t\ttime = timestamp - start,\n\t\t\t\t\t\tprogress = easing(Math.min(time / durationMs, 1))\n\t\t\t\t\t;\n\n\t\t\t\t\twindow.scrollTo(0, startY + (diff * progress));\n\n\t\t\t\t\tif( (time < durationMs) && (progress < 1) ){\n\t\t\t\t\t\trequestAnimationFrame(fScroll)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tres.resolve();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t;\n\n\t\tif( cancelOnUserScroll ){\n\t\t\tconst fCancelScroll = function(){\n\t\t\t\tcancelled = true;\n\t\t\t\tres.reject(new Error('cancelled'));\n\t\t\t\twindow.removeEventListener('DOMMouseScroll', fCancelScroll);\n\t\t\t\twindow.removeEventListener('mousewheel', fCancelScroll);\n\t\t\t};\n\n\t\t\twindow.addEventListener('DOMMouseScroll', fCancelScroll);\n\t\t\twindow.addEventListener('mousewheel', fCancelScroll);\n\t\t}\n\n\t\tif( diff !== 0 ){\n\t\t\trequestAnimationFrame(fScroll);\n\t\t}\n\t}\n\n\treturn res;\n}\n"]}
{"version":3,"file":"basic.js","names":["MODULE_NAME","log","warn","assert","condition","message","orDefault","Error","attempt","closure","isFunction","ex","hasValue","res","Array","from","arguments","forEach","value","size","target","countStringCharacters","values","length","getType","Object","isEmpty","emptyValues","undefined","obj","isArray","__additionalEmptyValues__","concat","Set","includes","hasMembers","memberNames","verbose","memberName","info","expression","defaultValue","caster","additionalEmptyValues","toLowerCase","parseInt","parseFloat","deepType","prototype","toString","call","slice","test","match","isA","type","isBoolean","isNumber","isBigInt","isInt","intVal","isFloat","floatVal","isNaN","checkForIdentity","isString","isSymbol","isObject","isPlainObject","constructor","isDate","isError","isGenerator","isIterator","isRegExp","isSet","isWeakSet","isMap","isWeakMap","isDocument","isElement","isCollection","isNodeList","isWindow","isEventTarget","addEventListener","removeEventListener","dispatchEvent","isSelector","fragment","document","createDocumentFragment","querySelector","isPotentialId","prefix","idRex","postfix","maskFixes","mask","str","replace","rex","RegExp","matches","exec","minMax","min","max","Deferred","STATUS_FULFILLED","STATUS_REJECTED","this","resolve","reject","provision","status","isSettled","promise","Promise","resolution","rejection","then","f","catch","finally","Observable","initialValue","__className__","_value","_subscriptions","getValue","setValue","newValue","force","oldValue","isNewValue","s","subscribe","subscription","indexOf","unsubscribe","filter"],"sources":["basic.js"],"mappings":"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","sourcesContent":["/*!\n * Module Basic\n */\n\n/**\n * @namespace Basic\n */\n\nconst MODULE_NAME = 'Basic';\n\n\n\n//###[ IMPORTS ]########################################################################################################\n\nimport {log, warn} from './logging.js';\n\n\n\n//###[ EXPORTS ]########################################################################################################\n\n/**\n * @namespace Basic:assert\n */\n\n/**\n * Classical assert method. If condition is falsy, throw assert exception.\n *\n * @param {Boolean} condition - defines if an assertion is successful\n * @param {?String} [message='assert exception: assertion failed'] - to display if assertion fails\n * @throws assert exception\n *\n * @memberof Basic:assert\n * @alias assert\n * @example\n * function set(name, value){\n *   assert(name.length > 0);\n *   assert(isPlainObject(value), 'error: value must be plain object');\n *   ...\n * }\n */\nexport function assert(condition, message){\n\tif( !condition ){\n\t\tmessage = orDefault(message, 'assert exception: assertion failed', 'str');\n\t\tthrow new Error(message);\n\t}\n}\n\n\n\n/**\n * @namespace Basic:attempt\n */\n\n/**\n * Attempt to compute contents of closure and catch all occurring exceptions.\n * The boolean result tells you if the operation was successful or not.\n *\n * This is most helpful, when used to test value conversions or other atomic/singluar operations, where it\n * just is important if something isolated works or not.\n *\n * Do not encapsulate complex code in the closure and mind recursively occurring exceptions!\n *\n * @param {Function} closure - the code to test\n * @throws error if closure is not a function\n * @returns {Boolean} true if no exception occurred\n *\n * @memberof Basic:attempt\n * @alias attempt\n * @example\n * if( !attempt(function(){ foobar(); }) ){ console.log('foobar cannot be executed!'); }\n */\nexport function attempt(closure){\n\tassert(isFunction(closure), `${MODULE_NAME}:attempt | closure is no function`);\n\n\ttry {\n\t\tclosure();\n\t} catch(ex){\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n\n\n/**\n * @namespace Basic:hasValue\n */\n\n/**\n * Check if variable(s) is set, by being neither undefined nor null.\n *\n * @param {...*} [...] - add any number of variables you wish to check\n * @returns {Boolean} variable(s) is/are set\n *\n * @memberof Basic:hasValue\n * @alias hasValue\n * @example\n * function set(name, value){\n *   if( hasValue(name, value) ){\n *     ...\n *   }\n * }\n */\nexport function hasValue(){\n\tlet res = true;\n\n\tArray.from(arguments).forEach(value => {\n\t\tres &&= ((value !== undefined) && (value !== null));\n\t});\n\n\treturn res;\n}\n\n\n\n/**\n * @namespace Basic:size\n */\n\n/**\n * Determine the (value) size of a collection.\n *\n * A collection is an object with countable values:\n * - Arrays return their length\n * - Sets and Maps return their size\n * - Strings return their (character) length\n * - Iterators return the length of their value list\n * - Objects return the length of their value list\n * - any object implementing .values() returns the length of the returned value list\n *\n * @param {Object|Array|Set|Map|String|Iterable} target - a collection to determine the (value) size of\n * @param {?Boolean} [countStringCharacters=true] - if we want to determine the length of a string, we'd normally like to count actual characters, but length normally returns the technical length counting more than one for unicode chars, set this to \"false\" to use technical length instead of characters\n * @returns {Number|null} the size of the collection or null if no size could be determined\n *\n * @memberof Basic:size\n * @alias size\n * @example\n * size('æ—¥æœ¬å›½ðŸ’©ðŸ‘»');\n * => 5\n * size('æ—¥æœ¬å›½ðŸ’©ðŸ‘»', false);\n * => 7\n * size({a : 1, b : new Date(), c : [1, 2, 3]});\n * => 3\n * size(['test', 'test', 'test']);\n * => 3\n * size(new Set(['test1', 'test2', 'test3']));\n * => 3\n * size(new Set(['test1', 'test2', 'test3']).values());\n * => 3\n * size(new Map([[1, 1], [new Date(), new Date()], ['foo', 'bar']]));\n * => 3\n * size(new Map([[1, 1], [new Date(), new Date()], ['foo', 'bar']]).values());\n * => 3\n * size(null);\n * => null\n * size(undefined);\n * => null\n */\nexport function size(target, countStringCharacters=true){\n\tif( isFunction(target?.values) ) return Array.from(target.values()).length;\n\n\tlet res;\n\tswitch( getType(target) ){\n\t\tcase 'array':\n\t\t\tres = target.length;\n\t\tbreak;\n\n\t\tcase 'set':\n\t\tcase 'map':\n\t\t\tres = target.size;\n\t\tbreak;\n\n\t\tcase 'iterator':\n\t\t\tres = Array.from(target).length;\n\t\tbreak;\n\n\t\tcase 'string':\n\t\t\t// see: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/length#description\n\t\t\tres = countStringCharacters ? [...target].length : target.length;\n\t\tbreak;\n\n\t\tcase 'object':\n\t\t\tres = Object.values(target).length;\n\t\tbreak;\n\n\t\tdefault:\n\t\t\tres = null;\n\t\tbreak;\n\t}\n\n\treturn res;\n}\n\n\n\n/**\n * @namespace Basic:isEmpty\n */\n\n/**\n * Check if variable(s) contain non-empty value\n * (not undefined, null, '', 0, [], {} or an empty Set/Map).\n *\n * You can supply additional non-empty values by providing an object having the key \"__additionalEmptyValues__\" as\n * any single parameter. Multiple occurrences will be merged.\n *\n * @param {...*} [...] - add any number of variables you wish to check\n * @returns {Boolean} variable(s) is/are empty\n *\n * @memberof Basic:isEmpty\n * @alias isEmpty\n * @example\n * function set(name, value){\n *   if( isEmpty(fooBar) || isEmpty({'__additionalEmptyValues__' : [false, '0']}, someArray, someSet, someString, value) ){\n *     ...\n *   }\n * }\n */\nexport function isEmpty(){\n\tlet\n\t\tres = true,\n\t\temptyValues = [undefined, null, '', 0]\n\t;\n\n\tArray.from(arguments).forEach(obj => {\n\t\tif( isArray(obj?.__additionalEmptyValues__) ){\n\t\t\temptyValues = emptyValues.concat(obj.__additionalEmptyValues__);\n\t\t}\n\t});\n\temptyValues = Array.from(new Set(emptyValues));\n\n\tArray.from(arguments).forEach(obj => {\n\t\tif( res && !isArray(obj?.__additionalEmptyValues__) ){\n\t\t\tres = emptyValues.includes(obj);\n\n\t\t\tif( !res ){\n\t\t\t\tres = (size(obj) === 0);\n\t\t\t}\n\t\t}\n\t});\n\n\treturn res;\n}\n\n\n\n/**\n * @namespace Basic:hasMembers\n */\n\n/**\n * \"Validates\" an object in a very basic way by checking if all given members are present and are not nullish.\n *\n * @param {Object} obj - the object to check\n * @param {String[]} memberNames - the names of the members to check\n * @param {Boolean} [verbose=false] - defines if method should output missing members to console\n * @returns {Boolean} all memberNames present and not nullish\n *\n * @memberof Basic:hasMembers\n * @alias hasMembers\n * @example\n * function pat(kitten){\n *   if( hasMembers(kitten, ['fluff', 'meow', 'scratch']) ){\n *     ...\n *   }\n * }\n */\nexport function hasMembers(obj, memberNames, verbose=false){\n\tmemberNames = orDefault(memberNames, [], 'arr');\n\tverbose = orDefault(verbose, false, 'bool');\n\n\tlet res = true;\n\n\tmemberNames.forEach(memberName => {\n\t\tif( !hasValue(obj[`${memberName}`]) ){\n\t\t\tif( verbose ){\n\t\t\t\tlog().info(`${MODULE_NAME}:hasMembers | missing member ${memberName}`);\n\t\t\t}\n\n\t\t\tres = false;\n\t\t}\n\t});\n\n\treturn res;\n}\n\n\n\n/**\n * @namespace Basic:orDefault\n */\n\n/**\n * If an expression returns a non-value (undefined or null), use the default value instead.\n * Define a caster name, to force expression result/value into certain data type.\n *\n * @param {*} expression - the expression to evaluate\n * @param {*} defaultValue - the default value to use if the expression is considered empty\n * @param {?(String|Function)} [caster=null] - either a default caster by name ('str', 'string', 'int', 'integer', 'bool', 'boolean', 'float', 'arr', 'array') or a function getting the value and returning the transformed value\n * @param {?Array} [additionalEmptyValues=null] - if set, provides a list of additional values to be considered empty, apart from undefined and null\n * @returns {*} expression of defaultValue\n *\n * @memberof Basic:orDefault\n * @alias orDefault\n * @example\n * function set(name, value){\n *   name = orDefault(name, 'kittens!', 'string', ['', 'none']);\n *   value = orDefault(value, 42, 'int');\n * }\n */\nexport function orDefault(expression, defaultValue, caster=null, additionalEmptyValues=null){\n\tif( hasValue(additionalEmptyValues) ){\n\t\tadditionalEmptyValues = [].concat(additionalEmptyValues);\n\t} else {\n\t\tadditionalEmptyValues = [];\n\t}\n\n\tif( hasValue(caster) ){\n\t\tif(\n\t\t\t!isFunction(caster)\n\t\t\t&& ([\n\t\t\t\t'str', 'string',\n\t\t\t\t'int', 'integer',\n\t\t\t\t'bool', 'boolean',\n\t\t\t\t'float',\n\t\t\t\t'arr', 'array'\n\t\t\t].includes(`${caster.toLowerCase()}`))\n\t\t){\n\t\t\tcaster = `${caster}`.toLowerCase();\n\n\t\t\tif( ['str', 'string'].includes(caster) ){\n\t\t\t\tcaster = function(value){ return `${value}`; };\n\t\t\t} else if( ['int', 'integer'].includes(caster) ){\n\t\t\t\tcaster = function(value){ return parseInt(value, 10); };\n\t\t\t} else if( ['bool', 'boolean'].includes(caster) ){\n\t\t\t\tcaster = function(value){ return !!value; };\n\t\t\t} else if( caster === 'float' ){\n\t\t\t\tcaster = function(value){ return parseFloat(value); };\n\t\t\t} else if( ['arr', 'array'].includes(caster) ){\n\t\t\t\tcaster = function(value){ return [].concat(value); };\n\t\t\t}\n\t\t} else if( !isFunction(caster) ){\n\t\t\tcaster = function(value){ return value; };\n\t\t}\n\t} else {\n\t\tcaster = function(value){ return value; };\n\t}\n\n\tif( !hasValue(expression) || (additionalEmptyValues.includes(expression)) ){\n\t\treturn defaultValue;\n\t} else {\n\t\treturn caster(expression);\n\t}\n}\n\n\n\n/**\n * @namespace Basic:getType\n */\n\n/**\n * Prod-ready type detection for values, expanding on flawed typeof functionality, roughly following\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof, but expanding on\n * useful frontend types like \"htmldocument\", \"htmlelement\", \"htmlcollection\" and \"nodelist\"\n *\n * Types:\n * - \"undefined\"\n * - \"null\"\n * - \"boolean\"\n * - \"number\"\n * - \"bigint\"\n * - \"string\"\n * - \"symbol\"\n * - \"function\"\n * - \"object\"\n * - \"array\"\n * - \"date\"\n * - \"error\"\n * - \"generator\"\n * - \"iterator\"\n * - \"regexp\"\n * - \"set\"\n * - \"weakset\"\n * - \"map\"\n * - \"weakmap\"\n * - \"htmldocument\"\n * - \"htmlelement\"\n * - \"htmlcollection\"\n * - \"nodelist\"\n * - \"window\"\n *\n * @param {*} [value] - variable to check the type of\n * @returns {String} the value type in lower case\n *\n * @memberof Basic:getType\n * @alias getType\n * @example\n * if( getType(cb) === 'function' ){\n *     ...\n * }\n */\nexport function getType(value) {\n\tif( !hasValue(value) ) return `${value}`.toLowerCase();\n\n\tconst deepType = Object.prototype.toString.call(value).slice(8,-1).toLowerCase();\n\n\tif( deepType === 'generatorfunction' ) return 'function';\n\tif( deepType === 'document' ) return 'htmldocument';\n\tif( deepType === 'element' ) return 'htmlelement';\n\tif( /^html.*element$/.test(deepType) ) return 'htmlelement';\n\tif( /^.*iterator$/.test(deepType) ) return 'iterator';\n\n\treturn deepType.match(/^(array|bigint|date|error|function|generator|regexp|symbol|set|weakset|map|weakmap|htmldocument|htmlcollection|nodelist|window)$/)\n\t\t? deepType\n\t\t: ((typeof value === 'object') || (typeof value === 'function')) ? 'object' : typeof value\n\t;\n}\n\n\n\n/**\n * @namespace Basic:isA\n */\n\n/**\n * Short form of \"getType\"-method with a more compact syntax.\n * Can identify all types listed in getType.\n *\n * @param {*} value - variable to check the type of\n * @param {String} type - the name of the type to check for, has to be a standard JS-type, is case insensitive\n * @returns {Boolean} target has type\n *\n * @memberof Basic:isA\n * @alias isA\n * @see getType\n * @example\n * let stringBool = (isA(test, 'boolean') && test) ? 'true' : 'false';\n */\nexport function isA(value, type){\n\tif(\n\t\t[\n\t\t\t'undefined',\n\t\t\t'null',\n\t\t\t'boolean',\n\t\t\t'number',\n\t\t\t'bigint',\n\t\t\t'string',\n\t\t\t'symbol',\n\t\t\t'function',\n\t\t\t'object',\n\t\t\t'array',\n\t\t\t'date',\n\t\t\t'error',\n\t\t\t'generator',\n\t\t\t'iterator',\n\t\t\t'regexp',\n\t\t\t'set',\n\t\t\t'weakset',\n\t\t\t'map',\n\t\t\t'weakmap',\n\t\t\t'htmldocument',\n\t\t\t'htmlelement',\n\t\t\t'htmlcollection',\n\t\t\t'nodelist',\n\t\t\t'window'\n\t\t].includes(`${type}`.toLowerCase())\n\t){\n\t\treturn getType(value) === `${type}`.toLowerCase();\n\t} else {\n\t\twarn(`${MODULE_NAME}:isA | \"${type}\" is not a recognized type`);\n\t\treturn false;\n\t}\n}\n\n\n\n/**\n * @namespace Basic:isBoolean\n */\n\n/**\n * Returns if a value is a boolean value.\n *\n * @param {*} value - the value to check\n * @returns {Boolean} true if value is a boolean\n *\n * @memberof Basic:isBoolean\n * @alias isBoolean\n * @example\n * if( isBoolean(val) ){\n *   console.log('val must be either true or false');\n * }\n */\nexport function isBoolean(value){\n\treturn isA(value, 'boolean');\n}\n\n\n\n/**\n * @namespace Basic:isNumber\n */\n\n/**\n * Returns if a value is a number.\n *\n * Hint: to check numbers in more detail, use isInt, isFloat and isNaN\n *\n * @param {*} value - the value to check\n * @returns {Boolean} true if value is a number\n *\n * @memberof Basic:isNumber\n * @alias isNumber\n * @see isInt\n * @see isFloat\n * @see isNaN\n * @example\n * if( isNumber(val) ){\n *   result = val * 5;\n * }\n */\nexport function isNumber(value){\n\treturn isA(value, 'number');\n}\n\n\n\n/**\n * @namespace Basic:isBigInt\n */\n\n/**\n * Returns if a value is a BigInt value.\n *\n * @param {*} value - the value to check\n * @returns {Boolean} true if value is a BigInt\n *\n * @memberof Basic:isBigInt\n * @alias isBigInt\n * @example\n * if( isBigInt(val) ){\n *   console.log('this is a really huge number!');\n * }\n */\nexport function isBigInt(value){\n\treturn isA(value, 'bigint');\n}\n\n\n\n/**\n * @namespace Basic:isInt\n */\n\n/**\n * Returns if a value is truly a real integer value and not just an int-parsable value for example.\n * Since JS only knows the data type \"number\" all numbers are usable as floats by default, but not the\n * other way round.\n *\n * @param {*} intVal - the value the check\n * @returns {Boolean} true if intVal is a true integer value\n *\n * @memberof Basic:isInt\n * @alias isInt\n * @example\n * if( !isInt(val) ){\n *   val = parseInt(val, 10);\n * }\n */\nexport function isInt(intVal){\n\treturn parseInt(intVal, 10) === intVal;\n}\n\n\n\n/**\n * @namespace Basic:isFloat\n */\n\n/**\n * Returns if a value is a numeric value, usable as a float number in any calculation.\n * Any number that fulfills isInt, is also considered a valid float, which lies in JS's\n * nature of not differentiating ints and floats by putting them both into a \"number\"-type.\n * So ints are always floats, but not necessarily the other way round.\n *\n * @param {*} floatVal - the value to check\n * @returns {Boolean} true if floatVal is usable in a float context\n *\n * @memberof Basic:isFloat\n * @alias isFloat\n * @example\n * if( !isFloat(val) ){\n *   alert('val can not be calculated with!');\n * }\n */\nexport function isFloat(floatVal){\n\treturn parseFloat(floatVal) === floatVal;\n}\n\n\n\n/**\n * @namespace Basic:isNaN\n */\n\n/**\n * Returns if an expression is NaN or not.\n * This method employs two different approaches:\n * By default it really checks if the expression is the _value_ NaN or not, this being a valid JS-value for something.\n * In JS this gets checked by comparing an expression with itself on identity, since NaN is the only value not being\n * identical to itself. If you set checkForIdentity to false, this method will use the standard JS-isNaN, which\n * inspects the expression, tries to cast or parse a number from it and returns the result.\n *\n * @param {*} expression - the expression to check\n * @param {Boolean} [checkForIdentity=true] - set to false if you want to use default JS-functionality\n * @returns {Boolean} true if expression is NaN\n *\n * @memberof Basic:isNaN\n * @alias isNaN\n * @example\n * if( !isNaN(suspiciousCalculatedValue) ){\n *   return suspiciousCalculatedValue * 3;\n * }\n */\nexport function isNaN(expression, checkForIdentity=true){\n\tcheckForIdentity = orDefault(checkForIdentity, true, 'bool');\n\n\tif( checkForIdentity ){\n\t\treturn expression !== expression;\n\t} else {\n\t\treturn isNaN(expression);\n\t}\n}\n\n\n\n/**\n * @namespace Basic:isString\n */\n\n/**\n * Returns if a value is a string.\n *\n * @param {*} value - the value to check\n * @returns {Boolean} true if value is a string\n *\n * @memberof Basic:isString\n * @alias isString\n * @example\n * if( isString(val) ){\n *   return prefix+val;\n * }\n */\nexport function isString(value){\n\treturn isA(value, 'string');\n}\n\n\n\n/**\n * @namespace Basic:isSymbol\n */\n\n/**\n * Returns if a value is a symbol.\n *\n * @param {*} value - the value to check\n * @returns {Boolean} true if value is a symbol\n *\n * @memberof Basic:isSymbol\n * @alias isSymbol\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol\n * @example\n * if( isSymbol(val) ){\n *   return val.description;\n * }\n */\nexport function isSymbol(value){\n\treturn isA(value, 'symbol');\n}\n\n\n\n/**\n * @namespace Basic:isFunction\n */\n\n/**\n * Returns if a value is a function.\n *\n * @param {*} value - the value to check\n * @returns {Boolean} true if value is a function\n *\n * @memberof Basic:isFunction\n * @alias isFunction\n * @example\n * if( isFunction(val) ){\n *   val();\n * }\n */\nexport function isFunction(value){\n\treturn isA(value, 'function');\n}\n\n\n\n/**\n * @namespace Basic:isObject\n */\n\n/**\n * Returns if a value is an object.\n *\n * Hint: if you explicitly want to check for a plain object, use isPlainObject\n *\n * @param {*} value - the value to check\n * @returns {Boolean} true if value is an object\n *\n * @memberof Basic:isObject\n * @alias isObject\n * @see isPlainObject\n * @example\n * if( isObject(val) ){\n *   val.newProperty = 'foobar';\n * }\n */\nexport function isObject(value){\n\treturn isA(value, 'object');\n}\n\n\n\n/**\n * @namespace Basic:isPlainObject\n */\n\n/**\n * Returns if a value is an object literal, so so-called \"plain object.\n * A plain object is something like \"{hello : 'world'}\".\n *\n * This might especially be helpful when dealing with JSON configs, so quickly check if\n * something might even be parsed JSON (which in most cases is a plain object in js).\n *\n * Be aware that this function cannot differentiate between constructor-based simple objects and\n * plain objects declared inline. So, if someone took on the work to instantiate a base object and assign\n * properties either in a function or a constructor, we accept that as a plain object.\n *\n * @param {*} value - the value to check\n * @returns {Boolean} true if value seems to be a plain object\n *\n * @memberof Basic:isPlainObject\n * @alias isPlainObject\n * @example\n * const isParameterConfigObject = isPlainObject(param);\n */\nexport function isPlainObject(value){\n\treturn isObject(value)\n\t\t&& hasValue(value)\n\t\t&& (value.constructor === Object)\n\t\t&& Object.prototype.toString.call(value) === '[object Object]'\n\t;\n}\n\n\n\n/**\n * @namespace Basic:isArray\n */\n\n/**\n * Returns if a value is an array.\n *\n * @param {*} value - the value to check\n * @returns {Boolean} true if value is an array\n *\n * @memberof Basic:isArray\n * @alias isArray\n * @example\n * if( isArray(val) ){\n *   val.push('foobar');\n * }\n */\nexport function isArray(value){\n\treturn isA(value, 'array');\n}\n\n\n\n/**\n * @namespace Basic:isDate\n */\n\n/**\n * Returns if a value is a date.\n *\n * @param {*} value - the value to check\n * @returns {Boolean} true if value is a date\n *\n * @memberof Basic:isDate\n * @alias isDate\n * @example\n * if( isDate(val) ){\n *   return val.toISOString();\n * }\n */\nexport function isDate(value){\n\treturn isA(value, 'date');\n}\n\n\n\n/**\n * @namespace Basic:isError\n */\n\n/**\n * Returns if a value is an error.\n *\n * @param {*} value - the value to check\n * @returns {Boolean} true if value is an error\n *\n * @memberof Basic:isError\n * @alias isError\n * @example\n * if( isError(val) ){\n *   return val.message;\n * }\n */\nexport function isError(value){\n\treturn isA(value, 'error');\n}\n\n\n\n/**\n * @namespace Basic:isGenerator\n */\n\n/**\n * Returns if a value is a generator.\n *\n * @param {*} value - the value to check\n * @returns {Boolean} true if value is a generator\n *\n * @memberof Basic:isGenerator\n * @alias isGenerator\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator\n * @example\n * if( isGenerator(val) ){\n *   return val.return(val.next().value);\n * }\n */\nexport function isGenerator(value){\n\treturn isA(value, 'generator');\n}\n\n\n\n/**\n * @namespace Basic:isIterator\n */\n\n/**\n * Returns if a value is an iterator.\n *\n * @param {*} value - the value to check\n * @returns {Boolean} true if value is an iterator\n *\n * @memberof Basic:isIterator\n * @alias isIterator\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Iterator\n * @example\n * if( isIterator(val) ){\n *   return val.next().value;\n * }\n */\nexport function isIterator(value){\n\treturn isA(value, 'iterator');\n}\n\n\n\n/**\n * @namespace Basic:isRegExp\n */\n\n/**\n * Returns if a value is a regular expression.\n *\n * @param {*} value - the value to check\n * @returns {Boolean} true if value is a regular expression\n *\n * @memberof Basic:isRegExp\n * @alias isRegExp\n * @example\n * if( isRegExp(val) ){\n *   return val.test('foobar');\n * }\n */\nexport function isRegExp(value){\n\treturn isA(value, 'regexp');\n}\n\n\n\n/**\n * @namespace Basic:isSet\n */\n\n/**\n * Returns if a value is a set.\n *\n * @param {*} value - the value to check\n * @returns {Boolean} true if value is a set\n *\n * @memberof Basic:isSet\n * @alias isSet\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set\n * @example\n * if( isSet(val) ){\n *   return val.has('foobar');\n * }\n */\nexport function isSet(value){\n\treturn isA(value, 'set');\n}\n\n\n\n/**\n * @namespace Basic:isWeakSet\n */\n\n/**\n * Returns if a value is a weak set.\n *\n * @param {*} value - the value to check\n * @returns {Boolean} true if value is a weak set\n *\n * @memberof Basic:isWeakSet\n * @alias isWeakSet\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet\n * @example\n * if( isWeakSet(val) ){\n *   return val.has(someSymbol);\n * }\n */\nexport function isWeakSet(value){\n\treturn isA(value, 'weakset');\n}\n\n\n\n/**\n * @namespace Basic:isMap\n */\n\n/**\n * Returns if a value is a map.\n *\n * @param {*} value - the value to check\n * @returns {Boolean} true if value is a map\n *\n * @memberof Basic:isMap\n * @alias isMap\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map\n * @example\n * if( isMap(val) ){\n *   return val.get('foobar');\n * }\n */\nexport function isMap(value){\n\treturn isA(value, 'map');\n}\n\n\n\n/**\n * @namespace Basic:isWeakMap\n */\n\n/**\n * Returns if a value is a weak map.\n *\n * @param {*} value - the value to check\n * @returns {Boolean} true if value is a weak map\n *\n * @memberof Basic:isWeakMap\n * @alias isWeakMap\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap\n * @example\n * if( isWeakMap(val) ){\n *   return val.get('foobar');\n * }\n */\nexport function isWeakMap(value){\n\treturn isA(value, 'weakmap');\n}\n\n\n\n/**\n * @namespace Basic:isDocument\n */\n\n/**\n * Returns if a value is an HTML document.\n *\n * @param {*} value - the value to check\n * @returns {Boolean} true if value is an HTML document\n *\n * @memberof Basic:isDocument\n * @alias isDocument\n * @example\n * if( isDocument(val) ){\n *   return val.body;\n * }\n */\nexport function isDocument(value){\n\treturn isA(value, 'htmldocument');\n}\n\n\n\n/**\n * @namespace Basic:isElement\n */\n\n/**\n * Returns if a value is an HTML element.\n * Be aware, that this explicitly means an element, not necessarily any node.\n * So text nodes, comments and such do not qualify.\n *\n * @param {*} value - the value to check\n * @returns {Boolean} true if value is an HTML element\n *\n * @memberof Basic:isElement\n * @alias isElement\n * @example\n * if( isElement(target) ){\n *   target.classList.add('foo');\n * }\n */\nexport function isElement(value){\n\treturn isA(value, 'htmlelement');\n}\n\n\n\n/**\n * @namespace Basic:isCollection\n */\n\n/**\n * Returns if a value is a collection of html elements.\n *\n * @param {*} value - the value to check\n * @returns {Boolean} true if value is a collection of html elements\n *\n * @memberof Basic:isCollection\n * @alias isCollection\n * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLCollection\n * @example\n * if( isCollection(val) ){\n *   return val.item(0);\n * }\n */\nexport function isCollection(value){\n\treturn isA(value, 'htmlcollection');\n}\n\n\n\n/**\n * @namespace Basic:isNodeList\n */\n\n/**\n * Returns if a value is a node list.\n *\n * @param {*} value - the value to check\n * @returns {Boolean} true if value is a node list\n *\n * @memberof Basic:isNodeList\n * @alias isNodeList\n * @see https://developer.mozilla.org/en-US/docs/Web/API/NodeList\n * @example\n * if( isNodeList(val) ){\n *   return val.item(0);\n * }\n */\nexport function isNodeList(value){\n\treturn isA(value, 'nodelist');\n}\n\n\n\n/**\n * @namespace Basic:isWindow\n */\n\n/**\n * Returns if a value is a window.\n *\n * @param {*} value - the value to check\n * @returns {Boolean} true if value is a window\n *\n * @memberof Basic:isWindow\n * @alias isWindow\n * @example\n * if( isWindow(val) ){\n *   return val.location.origin;\n * }\n */\nexport function isWindow(value){\n\treturn isA(value, 'window');\n}\n\n\n\n/**\n * @namespace Basic:isEventTarget\n */\n\n/**\n * Returns if a value is an EventTarget, which means that it is able to dispatch and receive events.\n * This is determined via duck-typing and not via class inheritance check, since this method is not\n * about type-safety, but the question if we can use the target for events, which is simply determined\n * by three essential object methods: addEventListener, removeEventListener and dispatchEvent. All\n * objects supporting these are fine with us.\n *\n * @param {*} value - the value to check\n * @returns {Boolean} true if value supports event methods\n *\n * @memberof Basic:isEventTarget\n * @alias isEventTarget\n * @example\n * if( isEventTarget(target) ){\n *   target.dispatchEvent(new CustomEvent('foobar'));\n * }\n */\nexport function isEventTarget(value){\n\treturn hasValue(value)\n\t\t&& isFunction(value.addEventListener)\n\t\t&& isFunction(value.removeEventListener)\n\t\t&& isFunction(value.dispatchEvent)\n\t;\n}\n\n\n\n/**\n * @namespace Basic:isSelector\n */\n\n/**\n * Returns if a value is a valid selector, usable in methods such as querySelector\n * and querySelectorAll.\n *\n * @param {*} value - the value to check\n * @returns {Boolean} true if value is a valid selector\n *\n * @memberof Basic:isSelector\n * @alias isSelector\n * @example\n * if( isSelector(selector) ){\n *   document.querySelector(selector)?.style.setProperty('color', 'red');\n * }\n */\nexport function isSelector(value){\n\t// almost all values like \"null\", \"undefined\" and \"NaN\" are accepted querySelectors, numbers are not\n\tvalue = orDefault(value, 0, 'str');\n\n\tconst fragment = document.createDocumentFragment();\n\n\ttry {\n\t\tfragment.querySelector(value);\n\t} catch(ex){\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n\n\n/**\n * @namespace Basic:isPotentialId\n */\n\n/**\n * Determines if a given value is potentially a valid id for something, because it matches a format of given\n * prefix, postfix and id regex. \"Potential\", because we can only assume by the format, we do not actually know\n * if the id really matches anything like a database entry for example.\n *\n * @param {(String|Number)} value - the value to test, will be stringified\n * @param {?String} [prefix=''] - a prefix for the id\n * @param {?String} [idRex='[1-9][0-9]*'] - the regex string to use to identify the id part of the value\n * @param {?String} [postfix=''] - a postfix for the id\n * @param {?Boolean} [maskFixes=true] - usually, prefixes are not treated as regexes and are automatically masked, if you'd like to define complex pre- and postfixes using regexes, set this to false\n * @returns {String|Boolean} if value is potential id according to format, the id is returned as a string (still usable as a truthy value), otherwise the return value is false\n *\n * @memberof Basic:isPotentialId\n * @alias isPotentialId\n * @example\n * if( isPotentialId(id, 'test_(', '[0-9]+', ')') ){\n *   createJsonRequest(`/backend/${id}`).then(() => { alert('done'); });\n * }\n */\nexport function isPotentialId(value, prefix='', idRex='[1-9][0-9]*', postfix='', maskFixes=true){\n\tvalue = `${value}`;\n\tprefix = orDefault(prefix, '', 'str');\n\tidRex = orDefault(idRex, '[1-9][0-9]*', 'str');\n\tpostfix = orDefault(postfix, '', 'str');\n\tmaskFixes = orDefault(maskFixes, true, 'bool');\n\n\tconst mask = str => `${str}`.replace(/([\\-\\[\\]\\/{}()*+?.\\\\^$|])/g, \"\\\\$&\");\n\n\tlet rex;\n\tif( maskFixes ){\n\t\trex = new RegExp(`^${mask(prefix)}(${idRex})${mask(postfix)}$`);\n\t} else {\n\t\trex = new RegExp(`^${prefix}(${idRex})${postfix}$`);\n\t}\n\n\tconst matches = rex.exec(value);\n\treturn hasValue(matches) ? matches[1] : false;\n}\n\n\n\n/**\n * @namespace Basic:minMax\n */\n\n/**\n * Checks if a value is within bounds of a minimum and maximum and returns\n * the value or the upper or lower bound respectively.\n *\n * Accepts all values comparable with > and <.\n *\n * @param {*} min - the lower bound\n * @param {*} value - the value to check\n * @param {*} max - the upper bound\n * @throws error if min is not smaller than max\n * @returns {*} value, min or max\n *\n * @memberof Basic:minMax\n * @alias minMax\n * @example\n * let croppedVal = minMax(-100, value, 100);\n */\nexport function minMax(min, value, max){\n\tassert(min <= max, `${MODULE_NAME}:minMax | min can not be larger than max`);\n\n\treturn (value < min)\n\t\t? min\n\t\t: (\n\t\t\t(value > max)\n\t\t\t\t? max\n\t\t\t\t: value\n\t\t)\n\t;\n}\n\n\n\n/**\n * @namespace Basic:Deferred\n */\n\n/**\n * @typedef Deferred\n * @type {Object}\n * @property {Promise} promise - the wrapped promise\n * @property {Function} resolve - resolves the wrapped promise with given value\n * @property {Function} reject - rejects the wrapped promise with given error\n * @property {Function} then - defines a success handler for the wrapped promise and returns its result\n * @property {Function} catch - defines an error handler for the wrapped promise and returns its result\n * @property {Function} finally - defines a \"settled\" handler for the wrapped promise and returns its result\n * @property {String} status - holds the current resolution status, can either be \"pending\", \"fulfilled\" or \"rejected\"\n * @property {Function} isSettled - returns true, if the Deferred is either \"fulfilled\" or \"rejected\"\n * @property {?*} [provision=null] - may contain (a) provisional value(s) to use for a newly instantiated Deferred, before it has resolved to the actual value(s)\n */\n\n/**\n * Class that wraps a Promise, to allow resolving and rejecting outside the\n * Promise's function scope. This allows for decoupled handling of states and\n * handling promises as references in a distributed context, like a class, where\n * a Deferred might then represent an async state.\n *\n * Deferreds also provide accessible status information, normal Promises do not have.\n * Accessing the \"status\" property returns the current status, being either \"pending\",\n * \"fulfilled\" or \"rejected\". You may also check if the Deferred has been settled via\n * \"isSettled()\". If you want to provide a preliminary result, available before the\n * promise has settled, you may set this result as a payload using the \"provision\" property.\n *\n * This follows ideas by jQuery and Q Promises:\n * - https://api.jquery.com/jQuery.Deferred/\n * - https://github.com/kriskowal/q/wiki/Coming-from-jQuery#deferreds-promises-resolvers\n *\n * Keep in mind, that Promises might need a polyfill such as core-js.\n *\n * @memberof Basic:Deferred\n * @name Deferred\n * @example\n * const doStuff = new Deferred();\n * doStuff.provision = 'provisional value';\n * doStuff\n *   .then(value => { alert(`yeah, ready with \"${value}\"!`); })\n *   .catch(error => { console.error(error); })\n *   .finally(() => { console.info('has been settled); })\n * ;\n * if( foobar === 42 ){\n *   doStuff.resolve(42);\n * } else {\n *   doStuff.reject(new Error('not 42!'));\n * }\n * console.info(doStuff.status);\n */\nexport class Deferred {\n\tconstructor(){\n\t\tconst\n\t\t\tSTATUS_PENDING = 'pending',\n\t\t\tSTATUS_FULFILLED = 'fulfilled',\n\t\t\tSTATUS_REJECTED = 'rejected'\n\t\t;\n\t\tthis.resolve = null;\n\t\tthis.reject = null;\n\t\tthis.provision = null;\n\t\tthis.status = STATUS_PENDING;\n\t\tthis.isSettled = () => [STATUS_FULFILLED, STATUS_REJECTED].includes(this.status);\n\t\tthis.promise = new Promise((resolve, reject) => {\n\t\t\tthis.resolve = resolution => {\n\t\t\t\tthis.status = STATUS_FULFILLED;\n\t\t\t\tresolve(resolution);\n\t\t\t};\n\t\t\tthis.reject = rejection => {\n\t\t\t\tthis.status = STATUS_REJECTED;\n\t\t\t\treject(rejection);\n\t\t\t};\n\t\t});\n\t}\n\n\tthen(f){\n\t\treturn this.promise.then(f);\n\t}\n\n\tcatch(f){\n\t\treturn this.promise.catch(f);\n\t}\n\n\tfinally(f){\n\t\treturn this.promise.finally(f);\n\t}\n}\n\n\n\n/**\n * @namespace Basic:Observable\n */\n\n/**\n * @typedef Observable\n * @type {Object}\n * @property {Function} getValue - returns the current value\n * @property {Function} setValue - sets a new value, which will subsequently trigger all subscriptions\n * @property {Function} subscribe - register a given function to be executed on any value change, the subscription receives the new and the old value on each execution, returns the subscription value, which can later be used to unsubscribe again\n * @property {Function} unsubscribe - removes a given subscription again, use subscription value returned by subscribe here\n */\n\n/**\n * A class offering the bare minimum feature set to observe a value and subscribe to future value changes.\n * No automatic magic going on here, this simply follows a basic subscription pattern, where each subscription is\n * a function, being called with a newly set value. This closely resembles the kind of observables knockout is using.\n *\n * @memberof Basic:Observable\n * @name Observable\n * @example\n * const status = new Observable('ok');\n * const subscription = status.subscribe(s => {\n *     console.log(`status changed to: ${s}`);\n * });\n * status.setValue('oh noez');\n * status.unsubscribe(subscription);\n */\nexport class Observable {\n\tconstructor(initialValue){\n\t\tthis.__className__ = 'Observable';\n\t\tthis._value = initialValue;\n\t\tthis._subscriptions = [];\n\t}\n\n\tgetValue(){\n\t\treturn this._value;\n\t}\n\n\tsetValue(newValue, force=false){\n\t\tconst\n\t\t\toldValue = this._value,\n\t\t\tisNewValue = oldValue !== newValue\n\t\t;\n\t\tthis._value = newValue;\n\t\tif( isNewValue || force ){\n\t\t\tthis._subscriptions.forEach(s => s(newValue, oldValue));\n\t\t}\n\t}\n\n\tsubscribe(subscription){\n\t\tconst __methodName__ = 'subscribe';\n\t\tassert(isFunction(subscription), `${MODULE_NAME}:${this.__className__}.${__methodName__} | subscription must be function`);\n\t\tif( this._subscriptions.indexOf(subscription) < 0 ){\n\t\t\tthis._subscriptions = [...this._subscriptions, subscription];\n\t\t}\n\t\treturn subscription;\n\t}\n\n\tunsubscribe(subscription){\n\t\tthis._subscriptions = this._subscriptions.filter(s => s !== subscription);\n\t}\n\n\ttoString(){\n\t\treturn `${this._value}`;\n\t}\n}\n"]}
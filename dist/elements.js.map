{"version":3,"sources":["elements.js"],"names":["MODULE_NAME","orDefault","isA","isPlainObject","hasValue","assert","createNode","tag","attributes","content","trim","outerNode","document","createElement","test","innerHTML","node","firstChild","attribute","setAttribute","textContent","getTextContent","target","onlyFirstLevel","childNodes","forEach","nodeType"],"mappings":";;;AAQA,MAAMA,YAAc,kBAIZC,UAAWC,IAAKC,cAAeC,SAAUC,WAAa,oBA+BvD,SAASC,WAAWC,EAAKC,EAAW,KAAMC,EAAQ,MACxDF,EAAMN,UAAUM,EAAK,OAAQ,OAAOG,OACpCF,EAAaL,cAAcK,GAAcA,EAAa,KACtDC,EAAUR,UAAUQ,EAAS,KAAM,OAEnC,MAAME,EAAYC,SAASC,cAAc,QAGxC,cAAcC,KAAKP,IAChB,gBAAgBO,KAAKP,GAExBI,EAAUI,UAAYR,EAAIG,OAE1BC,EAAUI,UAAY,IAAIR,MAG3B,MAAMS,EAAOL,EAAUM,WAEvB,GAAIb,SAASI,GACZ,IAAK,IAAIU,KAAaV,EACrBQ,EAAKG,aAAaD,EAAW,GAAGV,EAAWU,MAQ7C,OAJId,SAASK,KACZO,EAAKI,YAAcX,GAGbO,SAwBD,SAASK,eAAeC,EAAQC,GAAe,GASrD,GARAA,EAAiBtB,UAAUsB,GAAgB,EAAO,QAE9CrB,IAAIoB,EAAQ,YACfA,EAAShB,WAAWgB,IAGrBjB,OAAOH,IAAIoB,EAAQ,eAAgB,+DAE/BC,EAAgB,CACnB,IAAIH,EAAc,GAQlB,OANAE,EAAOE,WAAWC,SAAQT,IACH,IAAlBA,EAAKU,WACRN,GAAeJ,EAAKI,gBAIfA,EAEP,OAAOE,EAAOF","file":"elements.js","sourcesContent":["/*!\n * Module Elements\n */\n\n/**\n * @namespace Elements\n */\n\nconst MODULE_NAME = 'Elements';\n\n\n\nimport {orDefault, isA, isPlainObject, hasValue, assert} from './basic.js'\n\n\n\n/**\n * @namespace Elements:createNode\n */\n\n/**\n * Creates an element on the fly programmatically, based on provided name, attributes and content or markup,\n * without inserting it into the DOM.\n *\n * If you provide markup as \"tag\", make sure that there is one single root element, this method returns exactly one\n * element, not a NodeList.\n *\n * @param {?String} [tag='span'] - tag of the element to create or markup for root element\n * @param {?Object} [attributes=null] - tag attributes as key/value-pairs, will also be added to provided markup\n * @param {?String} [content=null] - content to insert into the element as textContent, be aware, that this will replace other content in provided markup\n * @returns {HTMLElement} DOM-node\n *\n * @memberof Elements:createNode\n * @alias createNode\n * @example\n * window.body.appendChild(\n *  createNode('div', {id : 'content', style : 'display:none;'}, 'loading...')\n * );\n * window.body.appendChild(\n *  createNode('<div id=\"content\" style=\"display:none;\">loading...</div>')\n * );\n *\n */\nexport function createNode(tag, attributes=null, content=null){\n\ttag = orDefault(tag, 'span', 'str').trim();\n\tattributes = isPlainObject(attributes) ? attributes : null;\n\tcontent = orDefault(content, null, 'str');\n\n\tconst outerNode = document.createElement('main');\n\n\tif(\n\t\t/^<[^<>\\/]+>/.test(tag)\n\t\t&& /<\\/[^<>\\/]+>$/.test(tag)\n\t){\n\t\touterNode.innerHTML = tag.trim();\n\t} else {\n\t\touterNode.innerHTML = `<${tag}/>`;\n\t}\n\n\tconst node = outerNode.firstChild;\n\n\tif( hasValue(attributes) ){\n\t\tfor( let attribute in attributes ){\n\t\t\tnode.setAttribute(attribute, `${attributes[attribute]}`);\n\t\t}\n\t}\n\n\tif( hasValue(content) ){\n\t\tnode.textContent = content;\n\t}\n\n\treturn node;\n}\n\n\n\n/**\n * @namespace Elements:getTextContent\n */\n\n/**\n * Return the de-nodified text content of a node-ridden string or a DOM-node.\n * Returns the raw text content, with all markup cleanly removed.\n * Can also be used to return only the concatenated child text nodes.\n *\n * @param {(String|Node)} target - the node-ridden string or DOM-node to \"clean\"\n * @param {?Boolean} [onlyFirstLevel=false] - true if only the text of direct child text nodes is to be returned\n * @throws error if target is neither markup nor node\n * @returns {String} the text content of the provided markup or node\n *\n * @memberof Elements:getTextContent\n * @alias getTextContent\n * @example\n * someElement.textContent = getTextContent('<p onlick=\"destroyWorld();\">red button <a>meow<span>woof</span></a></p>');\n */\nexport function getTextContent(target, onlyFirstLevel=false){\n\tonlyFirstLevel = orDefault(onlyFirstLevel, false, 'bool');\n\n\tif( isA(target, 'string') ){\n\t\ttarget = createNode(target);\n\t}\n\n\tassert(isA(target, 'htmlelement'), `${MODULE_NAME}:getTextContent | target is neither node nor markup`);\n\n\tif( onlyFirstLevel ){\n\t\tlet textContent = '';\n\n\t\ttarget.childNodes.forEach(node => {\n\t\t\tif( node.nodeType === 3 ){\n\t\t\t\ttextContent += node.textContent;\n\t\t\t}\n\t\t});\n\n\t\treturn textContent;\n\t} else {\n\t\treturn target.textContent;\n\t}\n}\n"]}
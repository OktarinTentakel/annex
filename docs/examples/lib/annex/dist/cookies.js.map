{"version":3,"sources":["cookies.js"],"names":["MODULE_NAME","assert","isA","orDefault","hasValue","warn","encodeCookieValue","value","encodeURIComponent","replace","decodeURIComponent","decodeCookieValue","slice","encodeCookieName","name","escape","decodeCookieName","normalizeCookieOptions","options","normalizedOptions","optionsProp","toLowerCase","expires","Date","now","Math","round","parseFloat","toUTCString","path","domain","secure","httponly","samesite","includes","getCookie","names","Set","concat","map","n","trim","foundNames","res","size","document","cookie","cookies","split","i","cookieParts","cookieName","cookieValue","join","has","add","ex","getCookies","Array","from","arguments","forEach","argument","setCookie","cookieOptions","option","removeCookie"],"mappings":"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","file":"cookies.js","sourcesContent":["/*!\n * Module Cookies\n */\n\n/**\n * @namespace Cookies\n */\n\nconst MODULE_NAME = 'Cookies';\n\n\n\nimport {assert, isA, orDefault, hasValue} from './basic.js';\nimport {warn} from './logging.js';\n\n\n\n//###( HELPERS )###\n\n/*\n * Encodes a string to be stored in a cookie.\n */\nfunction encodeCookieValue(value){\n\treturn encodeURIComponent(value).replace(/%(2[346BF]|3[AC-F]|40|5[BDE]|60|7[BCD])/g, decodeURIComponent);\n}\n\n\n\n/*\n * Decodes a cookie value to be used as a string in JavaScript.\n */\nfunction decodeCookieValue(value){\n\tif( value[0] === '\"' ){\n\t\tvalue = value.slice(1, -1);\n\t}\n\treturn value.replace(/(%[\\dA-F]{2})+/gi, decodeURIComponent);\n}\n\n\n\n/*\n * Makes sure a cookie name conforms to the cookie name rules and translates special chars to % representations.\n */\nfunction encodeCookieName(name){\n\treturn encodeURIComponent(`${name}`)\n\t\t.replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent)\n\t\t// using escape, because encodeURIComponent, indeed, does _not_ encode brackets\n\t\t.replace(/[()]/g, escape)\n\t;\n}\n\n\n\n/*\n * Decodes a cookie name, set prior with encodeCookieName to a standard JavaScript string again.\n */\nfunction decodeCookieName(name){\n\treturn decodeURIComponent(name);\n}\n\n\n\n/**\n * @typedef CookieOptions\n * @type {Object}\n * @property {?Date|Number} [expires=null] - expiry time of the cookie, either a Date object or time in milliseconds\n * @property {?Number} [max-age=null] - max age of the cookie in seconds\n * @property {?String} [path='/'] - the cookie path, setting this to \"auto\" or an empty string defines auto-mode, which targets the current site path, which usually is the default, but we use '/' to set a cookie for while site, this being the common use-case\n * @property {?Boolean} [secure=false] - define if the cookie should only be transmitted via https (see: https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#restrict_access_to_cookies)\n * @property {?Boolean} [httponly=false] - define this, if cookie should only be sent to servers and not be accessible to javascript (see: https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#restrict_access_to_cookies)\n * @property {?String} [samesite=null] - define if this cookie should be included in cross-site requests, may be either \"strict\" (will only ever transmit same-site), \"lax\" (usual browser default, transmits same-site and top-level GET) or \"none\" (no restrictions, will always be sent)\n */\n\n/*\n * Makes sure, that supplied cookie options are in a usable form for setting a cookie.\n */\nfunction normalizeCookieOptions(options){\n\toptions = orDefault(options, {});\n\n\tconst normalizedOptions = {};\n\tfor( let optionsProp in options ){\n\t\tnormalizedOptions[optionsProp.toLowerCase()] = options[optionsProp];\n\t}\n\toptions = normalizedOptions;\n\n\tif( options.expires ){\n\t\tif( !isA(options.expires, 'date') ){\n\t\t\toptions.expires = new Date(Date.now() + (Math.round(parseFloat(options.expires)) * 24 * 60 * 60 * 1000));\n\t\t}\n\n\t\toptions.expires = options.expires.toUTCString();\n\t} else {\n\t\toptions.expires = null;\n\t}\n\n\toptions['max-age'] = orDefault(options['max-age'], null, 'int');\n\n\toptions.path = orDefault(options.path, '/', 'str');\n\tif( options.path === 'auto' ){\n\t\toptions.path = '';\n\t}\n\n\toptions.domain = orDefault(options.domain, null, 'str');\n\n\toptions.secure = orDefault(options.secure, false, 'bool');\n\n\toptions.httponly = orDefault(options.httponly, false, 'bool');\n\n\toptions.samesite = orDefault(options.samesite, null, 'str');\n\tif( hasValue(options.samesite) ){\n\t\toptions.samesite = options.samesite.toLowerCase();\n\t\tif( !['strict', 'lax', 'none'].includes(options.samesite) ){\n\t\t\twarn(`${MODULE_NAME}:setCookie | unknown samesite mode \"${options.samesite}\"`);\n\t\t}\n\t}\n\n\treturn options;\n}\n\n\n\n/**\n * @namespace Cookies:getCookie\n */\n\n/**\n * Retrieves a decoded cookie value by name. Automatically decodes the value (assumes, that, if encoded, url/percent\n * encoding has been used).\n *\n * @param {?String|Array<String>} [name] - the name of the cookie (or several names), if empty, all available cookies are returned\n * @returns {String|Object|null} decoded value of the cookie, null, if no such cookie available or a dictionary of found cookies if all or a list are being returned (if a list is requested and non are found, an empty object is returned)\n *\n * @memberof Cookies:getCookie\n * @alias getCookie\n * @see getCookies\n * @see setCookie\n * @see removeCookie\n * @example\n * getCookie('foobar')\n * => 'value'\n * getCookie(['foobar', 'boofar'])\n * => {foobar : 'value', boofar : 'value'}\n * getCookie()\n * => all available cookies\n */\nexport function getCookie(name){\n\tconst\n\t\tnames = hasValue(name) ? new Set([].concat(name).map(n => n.trim())) : new Set(),\n\t\tfoundNames = new Set()\n\t;\n\n\tlet res = (names.size === 0) ? {} : null;\n\tif( !hasValue(document.cookie) ) return res;\n\n\tconst cookies = document.cookie.split(';');\n\tfor( let i in cookies ){\n\t\ttry {\n\t\t\tconst\n\t\t\t\tcookie = cookies[i].trim(),\n\t\t\t\tcookieParts = cookie.split('='),\n\t\t\t\tcookieName = decodeCookieName(cookieParts[0]).trim(),\n\t\t\t\tcookieValue = decodeCookieValue(cookieParts.slice(1).join('='))\n\t\t\t;\n\n\t\t\tif( (cookieName !== '') && (names.has(cookieName) || (names.size === 0)) ){\n\t\t\t\tif( res === null ){\n\t\t\t\t\tres = {};\n\t\t\t\t}\n\n\t\t\t\tres[cookieName] = cookieValue;\n\t\t\t\tfoundNames.add(cookieName);\n\n\t\t\t\tif( (foundNames.size === names.size) && (names.size !== 0) ){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch(ex){\n\t\t\twarn(`${MODULE_NAME}:getCookie | decoding cookie \"${cookies[i]}\" failed with \"${ex}\"`)\n\t\t}\n\t}\n\n\tif( names.size === 1 ){\n\t\treturn res?.[name] ?? null;\n\t} else {\n\t\treturn res;\n\t}\n}\n\n\n\n/**\n * @namespace Cookies:getCookies\n */\n\n/**\n * Retrieve decoded cookie values by name. If no name is provided, all available cookie are being returned.\n * Automatically decodes the values (assumes, that, if encoded, url/percent encoding has been used).\n *\n * You can provide names as an array or as comma-separated parameters.\n *\n * @param {?String|Array<String>} [names] - the names of the cookies, if empty or not set, all available cookies are returned\n * @returns {Object} dictionary of named decoded values of the cookies, will be empty if none of the cookies were available\n *\n * @memberof Cookies:getCookies\n * @alias getCookies\n * @see getCookie\n * @see setCookie\n * @see removeCookie\n * @example\n * getCookies(['foobar', 'boofar'])\n * => {foobar : 'value', boofar : 'value'}\n * getCookies('foobar', 'boofar')\n * => {foobar : 'value', boofar : 'value'}\n * getCookie()\n * => all available cookies\n */\nexport function getCookies(names){\n\tnames = [];\n\tArray.from(arguments).forEach(argument => {\n\t\tnames = names.concat(argument);\n\t});\n\n\treturn getCookie(names);\n}\n\n\n\n/**\n * @namespace Cookies:setCookie\n */\n\n/**\n * Set a cookie value (if possible) by name. Value will automatically be encoded.\n *\n * If you set a cookie to a nullish value, the method will try to remove the cookie with the given options.\n *\n * @param {String} name - the name of the cookie to set\n * @param {?String} [value] - the value of the cookie to set\n * @param {?CookieOptions} [options] - the cookie options to apply\n * @returns {String|null} returns the set cookie value if available after setting or null if cookie not available (which would also mean, that setting the cookie did not work, or, in case of removal, that the removal worked)\n *\n * @memberof Cookies:setCookie\n * @alias setCookie\n * @see getCookie\n * @see getCookies\n * @see removeCookie\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie#write_a_new_cookie\n * @example\n * setCookie('mykittencookie', 'meow meow', {expires : 7, path : '/kittens', secure : true, samesite : 'strict'});\n */\nexport function setCookie(name, value, options){\n\tassert(hasValue(name) && (name !== ''), `${MODULE_NAME}:setCookie | no usable name`);\n\n\tname = `${name}`.trim();\n\tvalue = hasValue(value) ? encodeCookieValue(orDefault(value, '', 'str')) : null;\n\toptions = normalizeCookieOptions(options);\n\n\tlet cookieOptions = '';\n\tfor( let optionsProp in options ){\n\t\tconst option = options[optionsProp];\n\n\t\tif( !hasValue(option) || (option === false) ) continue;\n\n\t\tcookieOptions += `; ${optionsProp}`;\n\n\t\tif( option === true ) continue;\n\n\t\t// if the value itself contains a semicolon, according to RFC 6265 section 5.2,\n\t\t// we use everything that comes before the semicolon as the value and drop the rest\n\t\tcookieOptions += `=${option.split(';')[0]}`;\n\t}\n\n\tif( hasValue(value) ){\n\t\tdocument.cookie = `${encodeCookieName(name)}=${value}${cookieOptions}`;\n\t} else {\n\t\tremoveCookie(name, options);\n\t}\n\n\treturn getCookie(name);\n}\n\n\n\n/**\n * @namespace Cookies:removeCookie\n */\n\n/**\n * Removes a cookie (if possible) by name.\n *\n * @param {String} name - the name of the cookie to remove\n * @param {?CookieOptions} [options] - the cookie options to apply (needed for different paths/domains for example)\n * @returns {Boolean} true if cookie is not available anymore after removal, if this is false, cookie removal failed or another cookie of the same name is still available\n *\n * @memberof Cookies:removeCookie\n * @alias removeCookie\n * @see getCookie\n * @see getCookies\n * @see setCookie\n * @example\n * removeCookie('mykittencookie', {path : '/kittens'});\n */\nexport function removeCookie(name, options){\n\tassert(hasValue(name) && (name !== ''), `${MODULE_NAME}:removeCookie | no usable name`);\n\n\toptions = normalizeCookieOptions();\n\toptions.expires = -1;\n\n\treturn (setCookie(name, '', options) === null);\n}\n"]}
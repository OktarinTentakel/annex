{"version":3,"file":"basic.js","names":["MODULE_NAME","log","warn","assert","condition","message","orDefault","Error","attempt","closure","isA","ex","hasValue","res","Array","from","arguments","forEach","value","size","target","countStringCharacters","values","length","getType","Object","isEmpty","emptyValues","undefined","obj","__additionalEmptyValues__","concat","Set","includes","hasMembers","memberNames","verbose","memberName","info","expression","defaultValue","caster","additionalEmptyValues","toLowerCase","parseInt","parseFloat","deepType","prototype","toString","call","slice","test","match","type","isInt","intVal","isFloat","floatVal","isPlainObject","constructor","isNaN","checkForIdentity","isEventTarget","addEventListener","removeEventListener","dispatchEvent","DOCUMENT_FRAGMENT","document","createDocumentFragment","isSelector","querySelector","minMax","min","max","Deferred","STATUS_FULFILLED","STATUS_REJECTED","this","resolve","reject","status","isSettled","promise","Promise","resolution","rejection","then","f","catch","finally","Observable","initialValue","subscriptions","getValue","setValue","newValue","force","oldValue","isNewValue","s","subscribe","subscription","indexOf","unsubscribe","filter"],"sources":["basic.js"],"mappings":"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","sourcesContent":["/*!\n * Module Basic\n */\n\n/**\n * @namespace Basic\n */\n\nconst MODULE_NAME = 'Basic';\n\n\n\n//###[ IMPORTS ]########################################################################################################\n\nimport {log, warn} from './logging.js';\n\n\n\n//###[ EXPORTS ]########################################################################################################\n\n/**\n * @namespace Basic:assert\n */\n\n/**\n * Classical assert method. If condition is falsy, throw assert exception.\n *\n * @param {Boolean} condition - defines if an assertion is successful\n * @param {?String} [message='assert exception: assertion failed'] - to display if assertion fails\n * @throws assert exception\n *\n * @memberof Basic:assert\n * @alias assert\n * @example\n * function set(name, value){\n *   assert(name.length > 0);\n *   assert(isPlainObject(value), 'error: value must be plain object');\n *   ...\n * }\n */\nexport function assert(condition, message){\n\tif( !condition ){\n\t\tmessage = orDefault(message, 'assert exception: assertion failed', 'str');\n\t\tthrow new Error(message);\n\t}\n}\n\n\n\n/**\n * @namespace Basic:attempt\n */\n\n/**\n * Attempt to compute contents of closure and catch all occurring exceptions.\n * The boolean result tells you if the operation was successful or not.\n *\n * This is most helpful, when used to test value conversions or other atomic/singluar operations, where it\n * just is important if something isolated works or not.\n *\n * Do not encapsulate complex code in the closure and mind recursively occurring exceptions!\n *\n * @param {Function} closure - the code to test\n * @throws error is closure is not a function\n * @returns {Boolean} true if no exception occurred\n *\n * @memberof Basic:attempt\n * @alias attempt\n * @example\n * if( !attempt(function(){ foobar(); }) ){ console.log('foobar cannot be executed!'); }\n */\nexport function attempt(closure){\n\tassert(isA(closure, 'function'), `${MODULE_NAME}:attempt | closure is no function`);\n\n\ttry {\n\t\tclosure();\n\t} catch(ex){\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n\n\n/**\n * @namespace Basic:hasValue\n */\n\n/**\n * Check if variable(s) is set, by being neither undefined nor null.\n *\n * @param {...*} [...] - add any number of variables you wish to check\n * @returns {Boolean} variable(s) is/are set\n *\n * @memberof Basic:hasValue\n * @alias hasValue\n * @example\n * function set(name, value){\n *   if( hasValue(name, value) ){\n *     ...\n *   }\n * }\n */\nexport function hasValue(){\n\tlet res = true;\n\n\tArray.from(arguments).forEach(value => {\n\t\tres &&= ((value !== undefined) && (value !== null));\n\t});\n\n\treturn res;\n}\n\n\n\n/**\n * @namespace Basic:size\n */\n\n/**\n * Determine the (value) size of a collection.\n *\n * A collection is an object with countable values:\n * - Arrays return their length\n * - Sets and Maps return their size\n * - Strings return their (character) length\n * - Iterators return the length of their value list\n * - Objects return the length of their value list\n * - any object implementing .values() returns the length of the returned value list\n *\n * @param {Object|Array|Set|Map|String|Iterable} target - a collection to determine the (value) size of\n * @param {?Boolean} [countStringCharacters=true] - if we want to determine the length of a string, we'd normally like to count actual characters, but length normally returns the technical length counting more than one for unicode chars, set this to \"false\" to use technical length instead of characters\n * @returns {Number|null} the size of the collection or null if no size could be determined\n *\n * @memberof Basic:size\n * @alias size\n * @example\n * size('æ—¥æœ¬å›½ðŸ’©ðŸ‘»');\n * => 5\n * size('æ—¥æœ¬å›½ðŸ’©ðŸ‘»', false);\n * => 7\n * size({a : 1, b : new Date(), c : [1, 2, 3]});\n * => 3\n * size(['test', 'test', 'test']);\n * => 3\n * size(new Set(['test1', 'test2', 'test3']));\n * => 3\n * size(new Set(['test1', 'test2', 'test3']).values());\n * => 3\n * size(new Map([[1, 1], [new Date(), new Date()], ['foo', 'bar']]));\n * => 3\n * size(new Map([[1, 1], [new Date(), new Date()], ['foo', 'bar']]).values());\n * => 3\n * size(null);\n * => null\n * size(undefined);\n * => null\n */\nexport function size(target, countStringCharacters=true){\n\tif( isA(target?.values, 'function') ) return Array.from(target.values()).length;\n\n\tlet res;\n\tswitch( getType(target) ){\n\t\tcase 'array':\n\t\t\tres = target.length;\n\t\tbreak;\n\n\t\tcase 'set':\n\t\tcase 'map':\n\t\t\tres = target.size;\n\t\tbreak;\n\n\t\tcase 'iterator':\n\t\t\tres = Array.from(target).length;\n\t\tbreak;\n\n\t\tcase 'string':\n\t\t\t// see: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/length#description\n\t\t\tres = countStringCharacters ? [...target].length : target.length;\n\t\tbreak;\n\n\t\tcase 'object':\n\t\t\tres = Object.values(target).length;\n\t\tbreak;\n\n\t\tdefault:\n\t\t\tres = null;\n\t\tbreak;\n\t}\n\n\treturn res;\n}\n\n\n\n/**\n * @namespace Basic:isEmpty\n */\n\n/**\n * Check if variable(s) contain non-empty value\n * (not undefined, null, '', 0, [], {} or an empty Set/Map).\n *\n * You can supply additional non-empty values by providing an object having the key \"__additionalEmptyValues__\" as\n * any single parameter. Multiple occurrences will be merged.\n *\n * @param {...*} [...] - add any number of variables you wish to check\n * @returns {Boolean} variable(s) is/are empty\n *\n * @memberof Basic:isEmpty\n * @alias isEmpty\n * @example\n * function set(name, value){\n *   if( isEmpty(fooBar) || isEmpty({'__additionalEmptyValues__' : [false, '0']}, someArray, someSet, someString, value) ){\n *     ...\n *   }\n * }\n */\nexport function isEmpty(){\n\tlet\n\t\tres = true,\n\t\temptyValues = [undefined, null, '', 0]\n\t;\n\n\tArray.from(arguments).forEach(obj => {\n\t\tif( isA(obj?.__additionalEmptyValues__, 'array') ){\n\t\t\temptyValues = emptyValues.concat(obj.__additionalEmptyValues__);\n\t\t}\n\t});\n\temptyValues = Array.from(new Set(emptyValues));\n\n\tArray.from(arguments).forEach(obj => {\n\t\tif( res && !isA(obj?.__additionalEmptyValues__, 'array') ){\n\t\t\tres = emptyValues.includes(obj);\n\n\t\t\tif( !res ){\n\t\t\t\tres = (size(obj) === 0);\n\t\t\t}\n\t\t}\n\t});\n\n\treturn res;\n}\n\n\n\n/**\n * @namespace Basic:hasMembers\n */\n\n/**\n * \"Validates\" an object in a very basic way by checking if all given members are present and are not nullish.\n *\n * @param {Object} obj - the object to check\n * @param {String[]} memberNames - the names of the members to check\n * @param {Boolean} [verbose=false] - defines if method should output missing members to console\n * @returns {Boolean} all memberNames present and not nullish\n *\n * @memberof Basic:hasMembers\n * @alias hasMembers\n * @example\n * function pat(kitten){\n *   if( hasMembers(kitten, ['fluff', 'meow', 'scratch']) ){\n *     ...\n *   }\n * }\n */\nexport function hasMembers(obj, memberNames, verbose=false){\n\tmemberNames = orDefault(memberNames, [], 'arr');\n\tverbose = orDefault(verbose, false, 'bool');\n\n\tlet res = true;\n\n\tmemberNames.forEach(memberName => {\n\t\tif( !hasValue(obj[`${memberName}`]) ){\n\t\t\tif( verbose ){\n\t\t\t\tlog().info(`${MODULE_NAME}:hasMembers | missing member ${memberName}`);\n\t\t\t}\n\n\t\t\tres = false;\n\t\t}\n\t});\n\n\treturn res;\n}\n\n\n\n/**\n * @namespace Basic:orDefault\n */\n\n/**\n * If an expression returns a non-value (undefined or null), use the default value instead.\n * Define a caster name, to force expression result/value into certain data type.\n *\n * @param {*} expression - the expression to evaluate\n * @param {*} defaultValue - the default value to use if the expression is considered empty\n * @param {?(String|Function)} [caster=null] - either a default caster by name ('str', 'string', 'int', 'integer', 'bool', 'boolean', 'float', 'arr', 'array') or a function getting the value and returning the transformed value\n * @param {?Array} [additionalEmptyValues=null] - if set, provides a list of additional values to be considered empty, apart from undefined and null\n * @returns {*} expression of defaultValue\n *\n * @memberof Basic:orDefault\n * @alias orDefault\n * @example\n * function set(name, value){\n *   name = orDefault(name, 'kittens!', 'string', ['', 'none']);\n *   value = orDefault(value, 42, 'int');\n * }\n */\nexport function orDefault(expression, defaultValue, caster=null, additionalEmptyValues=null){\n\tif( hasValue(additionalEmptyValues) ){\n\t\tadditionalEmptyValues = [].concat(additionalEmptyValues);\n\t} else {\n\t\tadditionalEmptyValues = [];\n\t}\n\n\tif( hasValue(caster) ){\n\t\tif(\n\t\t\t!isA(caster, 'function')\n\t\t\t&& ([\n\t\t\t\t'str', 'string',\n\t\t\t\t'int', 'integer',\n\t\t\t\t'bool', 'boolean',\n\t\t\t\t'float',\n\t\t\t\t'arr', 'array'\n\t\t\t].includes(`${caster.toLowerCase()}`))\n\t\t){\n\t\t\tcaster = `${caster}`.toLowerCase();\n\n\t\t\tif( ['str', 'string'].includes(caster) ){\n\t\t\t\tcaster = function(value){ return `${value}`; };\n\t\t\t} else if( ['int', 'integer'].includes(caster) ){\n\t\t\t\tcaster = function(value){ return parseInt(value, 10); };\n\t\t\t} else if( ['bool', 'boolean'].includes(caster) ){\n\t\t\t\tcaster = function(value){ return !!value; };\n\t\t\t} else if( caster === 'float' ){\n\t\t\t\tcaster = function(value){ return parseFloat(value); };\n\t\t\t} else if( ['arr', 'array'].includes(caster) ){\n\t\t\t\tcaster = function(value){ return [].concat(value); };\n\t\t\t}\n\t\t} else if( !isA(caster, 'function') ){\n\t\t\tcaster = function(value){ return value; };\n\t\t}\n\t} else {\n\t\tcaster = function(value){ return value; };\n\t}\n\n\tif( !hasValue(expression) || (additionalEmptyValues.includes(expression)) ){\n\t\treturn defaultValue;\n\t} else {\n\t\treturn caster(expression);\n\t}\n}\n\n\n\n/**\n * @namespace Basic:getType\n */\n\n/**\n * Prod-ready type detection for values, expanding on flawed typeof functionality, roughly following\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof, but expanding on\n * useful frontend types like \"htmldocument\", \"htmlelement\" and \"nodelist\"\n *\n * Types:\n * - \"undefined\"\n * - \"null\"\n * - \"boolean\"\n * - \"number\"\n * - \"bigint\"\n * - \"string\"\n * - \"symbol\"\n * - \"function\"\n * - \"object\"\n * - \"array\"\n * - \"date\"\n * - \"error\"\n * - \"generator\"\n * - \"iterator\"\n * - \"regexp\"\n * - \"set\"\n * - \"weakset\"\n * - \"map\"\n * - \"weakmap\"\n * - \"htmldocument\"\n * - \"htmlelement\"\n * - \"nodelist\"\n * - \"window\"\n *\n * @param {*} [value] - variable to check the type of\n * @returns {String} the value type in lower case\n *\n * @memberof Basic:getType\n * @alias getType\n * @example\n * if( getType(cb) === 'function' ){\n *     ...\n * }\n */\nexport function getType(value) {\n\tif( !hasValue(value) ) return `${value}`.toLowerCase();\n\n\tconst deepType = Object.prototype.toString.call(value).slice(8,-1).toLowerCase();\n\n\tif( deepType === 'generatorfunction' ) return 'function';\n\tif( deepType === 'document' ) return 'htmldocument';\n\tif( deepType === 'element' ) return 'htmlelement';\n\tif( /^html.*element$/.test(deepType) ) return 'htmlelement';\n\tif( /^.*iterator$/.test(deepType) ) return 'iterator';\n\n\treturn deepType.match(/^(array|bigint|date|error|function|generator|regexp|symbol|set|weakset|map|weakmap|htmldocument|nodelist|window)$/)\n\t\t? deepType\n\t\t: ((typeof value === 'object') || (typeof value === 'function')) ? 'object' : typeof value\n\t;\n}\n\n\n\n/**\n * @namespace Basic:isA\n */\n\n/**\n * Short form of \"getType\"-method with a more compact syntax.\n * Can identify all types listed in getType.\n *\n * @param {*} value - variable to check the type of\n * @param {String} type - the name of the type to check for, has to be a standard JS-type, is case insensitive\n * @returns {Boolean} target has type\n *\n * @memberof Basic:isA\n * @alias isA\n * @see getType\n * @example\n * let stringBool = (isA(test, 'boolean') && test) ? 'true' : 'false';\n */\nexport function isA(value, type){\n\tif(\n\t\t[\n\t\t\t'undefined',\n\t\t\t'null',\n\t\t\t'boolean',\n\t\t\t'number',\n\t\t\t'bigint',\n\t\t\t'string',\n\t\t\t'symbol',\n\t\t\t'function',\n\t\t\t'object',\n\t\t\t'array',\n\t\t\t'date',\n\t\t\t'error',\n\t\t\t'generator',\n\t\t\t'iterator',\n\t\t\t'regexp',\n\t\t\t'set',\n\t\t\t'weakset',\n\t\t\t'map',\n\t\t\t'weakmap',\n\t\t\t'htmldocument',\n\t\t\t'htmlelement',\n\t\t\t'nodelist',\n\t\t\t'window'\n\t\t].includes(`${type}`.toLowerCase())\n\t){\n\t\treturn getType(value) === `${type}`.toLowerCase();\n\t} else {\n\t\twarn(`${MODULE_NAME}:isA | \"${type}\" is not a recognized type`);\n\t\treturn false;\n\t}\n}\n\n\n\n/**\n * @namespace Basic:isInt\n */\n\n/**\n * Returns if a value is truly a real integer value and not just an int-parsable value for example.\n * Since JS only knows the data type \"number\" all numbers are usable as floats by default, but not the\n * other way round.\n *\n * @param {*} intVal - the value the check\n * @returns {Boolean} true if intVal is a true integer value\n *\n * @memberof Basic:isInt\n * @alias isInt\n * @example\n * if( !isInt(val) ){\n *   val = parseInt(val, 10);\n * }\n */\nexport function isInt(intVal){\n\treturn parseInt(intVal, 10) === intVal;\n}\n\n\n\n/**\n * @namespace Basic:isFloat\n */\n\n/**\n * Returns if a value is a numeric value, usable as a float number in any calculation.\n * Any number that fulfills isInt, is also considered a valid float, which lies in JS's\n * nature of not differentiating ints and floats by putting them both into a \"number\"-type.\n * So ints are always floats, but not necessarily the other way round.\n *\n * @param {*} floatVal - the value to check\n * @returns {Boolean} true if floatVal is usable in a float context\n *\n * @memberof Basic:isFloat\n * @alias isFloat\n * @example\n * if( !isFloat(val) ){\n *   alert('val can not be calculated with!');\n * }\n */\nexport function isFloat(floatVal){\n\treturn parseFloat(floatVal) === floatVal;\n}\n\n\n\n/**\n * @namespace Basic:isPlainObject\n */\n\n/**\n * Returns if a value is an object literal, so so-called \"plain object.\n * A plain object is something like \"{hello : 'world'}\".\n *\n * This might especially be helpful when dealing with JSON configs, so quickly check if\n * something might even be parsed JSON (which in most cases is a plain object in js).\n *\n * Be aware that this function cannot differentiate between constructor-based simple objects and\n * plain objects declared inline. So, if someone took on the work to instantiate a base object and assign\n * properties either in a function or a constructor, we accept that as a plain object.\n *\n * @param {*} value - the value to check\n * @returns {Boolean} true if value seems to be a plain object\n *\n * @memberof Basic:isPlainObject\n * @alias isPlainObject\n * @example\n * const isParameterConfigObject = isPlainObject(param);\n */\nexport function isPlainObject(value){\n\treturn isA(value, 'object')\n\t\t&& hasValue(value)\n\t\t&& (value.constructor === Object)\n\t\t&& Object.prototype.toString.call(value) === '[object Object]'\n\t;\n}\n\n\n\n/**\n * @namespace Basic:isNaN\n */\n\n/**\n * Returns if an expression is NaN or not.\n * This method employs two different approaches:\n * By default it really checks if the expression is the _value_ NaN or not, this being a valid JS-value for something.\n * In JS this gets checked by comparing an expression with itself on identity, since NaN is the only value not being\n * identical to itself. If you set checkForIdentity to false, this method will use the standard JS-isNaN, which\n * inspects the expression, tries to cast or parse a number from it and returns the result.\n *\n * @param {*} expression - the expression to check\n * @param {Boolean} [checkForIdentity=true] - set to false if you want to use default JS-functionality\n * @returns {Boolean} true if expression is NaN\n *\n * @memberof Basic:isNaN\n * @alias isNaN\n * @example\n * if( !isNaN(suspiciousCalculatedValue) ){\n *   return suspiciousCalculatedValue * 3;\n * }\n */\nexport function isNaN(expression, checkForIdentity=true){\n\tcheckForIdentity = orDefault(checkForIdentity, true, 'bool');\n\n\tif( checkForIdentity ){\n\t\treturn expression !== expression;\n\t} else {\n\t\treturn isNaN(expression);\n\t}\n}\n\n\n\n/**\n * @namespace Basic:isEventTarget\n */\n\n/**\n * Returns if a value is an EventTarget, which means that it is able to dispatch and receive events.\n * This is determined via duck-typing and not via class inheritance check, since this method is not\n * about type-safety, but the question if we can use the target for events, which is simply determined\n * by three essential object methods: addEventListener, removeEventListener and dispatchEvent. All\n * objects supporting these are fine with us.\n *\n * @param {*} value - the value to check\n * @returns {Boolean} true if value supports event methods\n *\n * @memberof Basic:isEventTarget\n * @alias isEventTarget\n * @example\n * if( isEventTarget(target) ){\n *   target.dispatchEvent(new CustomEvent('foobar'));\n * }\n */\nexport function isEventTarget(value){\n\treturn hasValue(value)\n\t\t&& isA(value.addEventListener, 'function')\n\t\t&& isA(value.removeEventListener, 'function')\n\t\t&& isA(value.dispatchEvent, 'function')\n\t;\n}\n\n\n\n/**\n * @namespace Basic:isSelector\n */\n\nconst DOCUMENT_FRAGMENT = document.createDocumentFragment();\n\n/**\n * Returns if a value is a valid selector, usable in methods such as querySelector\n * and querySelectorAll.\n *\n * @param {*} value - the value to check\n * @returns {Boolean} true if value is a valid selector\n *\n * @memberof Basic:isSelector\n * @alias isSelector\n * @example\n * if( isSelector(selector) ){\n *   document.querySelector(selector)?.style.setProperty('color', 'red');\n * }\n */\nexport function isSelector(value){\n\t// almost all values like \"null\", \"undefined\" and \"NaN\" are accepted querySelectors, numbers are not\n\tvalue = orDefault(value, 0, 'str');\n\n\ttry {\n\t\tDOCUMENT_FRAGMENT.querySelector(value);\n\t} catch(ex){\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n\n\n/**\n * @namespace Basic:minMax\n */\n\n/**\n * Checks if a value is within bounds of a minimum and maximum and returns\n * the value or the upper or lower bound respectively.\n *\n * Accepts all values comparable with > and <.\n *\n * @param {*} min - the lower bound\n * @param {*} value - the value to check\n * @param {*} max - the upper bound\n * @throws error if min is not smaller than max\n * @returns {*} value, min or max\n *\n * @memberof Basic:minMax\n * @alias minMax\n * @example\n * let croppedVal = minMax(-100, value, 100);\n */\nexport function minMax(min, value, max){\n\tassert(min <= max, `${MODULE_NAME}:minMax | min can not be larger than max`);\n\n\treturn (value < min)\n\t\t? min\n\t\t: (\n\t\t\t(value > max)\n\t\t\t\t? max\n\t\t\t\t: value\n\t\t)\n\t;\n}\n\n\n\n/**\n * @namespace Basic:Deferred\n */\n\n/**\n * Class that wraps a Promise, to allow resolving and rejecting outside the\n * Promise's function scope. This allows for decoupled handling of states and\n * handling promises as references in a distributed context, like a class, where\n * a Deferred might then represent an async state.\n *\n * Deferreds also provide accessible status information, normal Promises do not have.\n * Accessing the \"status\" property returns the current status, being either \"pending\",\n * \"fulfilled\" or \"rejected\". You may also check if the Deferred has been settled via\n * \"isSettled()\".\n *\n * This follows ideas by jQuery and Q Promises:\n * - https://api.jquery.com/jQuery.Deferred/\n * - https://github.com/kriskowal/q/wiki/Coming-from-jQuery#deferreds-promises-resolvers\n *\n * Keep in mind, that Promises might need a polyfill such as core-js.\n *\n * @memberof Basic:Deferred\n * @name Deferred\n * @example\n * const doStuff = new Deferred();\n * doStuff\n *   .then(value => { alert(`yeah, ready with \"${value}\"!`); })\n *   .catch(error => { console.error(error); })\n *   .finally(() => { console.info('has been settled); })\n * ;\n * if( foobar === 42 ){\n *   doStuff.resolve(42);\n * } else {\n *   doStuff.reject(new Error('not 42!'));\n * }\n * console.info(doStuff.status);\n */\nexport class Deferred {\n\tconstructor(){\n\t\tconst\n\t\t\tSTATUS_PENDING = 'pending',\n\t\t\tSTATUS_FULFILLED = 'fulfilled',\n\t\t\tSTATUS_REJECTED = 'rejected'\n\t\t;\n\t\tthis.resolve = null;\n\t\tthis.reject = null;\n\t\tthis.status = STATUS_PENDING;\n\t\tthis.isSettled = () => [STATUS_FULFILLED, STATUS_REJECTED].includes(this.status);\n\t\tthis.promise = new Promise((resolve, reject) => {\n\t\t\tthis.resolve = resolution => {\n\t\t\t\tthis.status = STATUS_FULFILLED;\n\t\t\t\tresolve(resolution);\n\t\t\t};\n\t\t\tthis.reject = rejection => {\n\t\t\t\tthis.status = STATUS_REJECTED;\n\t\t\t\treject(rejection);\n\t\t\t};\n\t\t});\n\t}\n\n\tthen(f){\n\t\treturn this.promise.then(f);\n\t}\n\n\tcatch(f){\n\t\treturn this.promise.catch(f);\n\t}\n\n\tfinally(f){\n\t\treturn this.promise.finally(f);\n\t}\n}\n\n\n\n/**\n * @namespace Basic:Observable\n */\n\n/**\n * A class offering the bare minimum feature set to observe a value and subscribe to future value changes.\n * No automatic magic going on here, this simply follows a basic subscription pattern, where each subscription is\n * a function, being called with a newly set value. This closely resembles the kind of observables knockout is using.\n *\n * @memberof Basic:Observable\n * @name Observable\n * @example\n * const status = new Observable('ok');\n * const subscription = status.subscribe(s => {\n *     console.log(`status changed to: ${s}`);\n * });\n * status.setValue('oh noez');\n * status.unsubscribe(subscription);\n */\nexport class Observable {\n\tconstructor(initialValue){\n\t\tthis.value = initialValue;\n\t\tthis.subscriptions = [];\n\t}\n\n\tgetValue(){\n\t\treturn this.value;\n\t}\n\n\tsetValue(newValue, force=false){\n\t\tconst\n\t\t\toldValue = this.value,\n\t\t\tisNewValue = oldValue !== newValue\n\t\t;\n\t\tthis.value = newValue;\n\t\tif( isNewValue || force ){\n\t\t\tthis.subscriptions.forEach(s => s(newValue, oldValue));\n\t\t}\n\t}\n\n\tsubscribe(subscription){\n\t\tassert(isA(subscription, 'function'), `${MODULE_NAME}:Observable.subscribe | subscription must be function`);\n\t\tif( this.subscriptions.indexOf(subscription) < 0 ){\n\t\t\tthis.subscriptions = [...this.subscriptions, subscription];\n\t\t}\n\t\treturn subscription;\n\t}\n\n\tunsubscribe(subscription){\n\t\tthis.subscriptions = this.subscriptions.filter(s => s !== subscription);\n\t}\n}\n"]}
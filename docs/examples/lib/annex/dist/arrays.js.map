{"version":3,"sources":["arrays.js"],"names":["MODULE_NAME","assert","isA","orDefault","remove","target","from","to","Array","isArray","parseInt","rest","slice","length","concat","reduce","reducedArray","item","push","fromList","Object","values"],"mappings":";;;AAQA,MAAMA,YAAc,gBAIZC,OAAQC,IAAKC,cAAgB,oBAoD9B,SAASC,OAAOC,EAAQC,EAAMC,GAGpC,GAFAN,OAAOO,MAAMC,QAAQJ,GAAS,sCAE1BH,IAAII,EAAM,YAAqB,IAAPC,EAAe,CAC1CD,EAAOI,SAASJ,EAAM,IACtBC,EAAKJ,UAAUI,EAAI,KAAM,WAGzB,MAAMI,GADNN,EAASA,EAAOO,MAAM,IACFA,OAAOL,GAAMD,GAAQ,GAAKD,EAAOQ,QAGrD,OAFAR,EAAOQ,OAAUP,EAAO,EAAMD,EAAOQ,OAASP,EAAQA,EAE/CD,EAAOS,OAAOH,GACf,GAAIT,IAAII,EAAM,UACpB,OAAOD,EAAOU,QAAO,CAACC,EAAcC,KAC/B,GAAGA,MAAWX,GACjBU,EAAaE,KAAKD,GAEZD,IACL,IACG,CACN,MAAMG,EAAWjB,IAAII,EAAM,UAAYc,OAAOC,OAAOf,GAAQE,MAAMF,KAAKA,GAExE,OAAY,IAAPC,GAAiBY,EAASN,OAAS,EAChCM,EAASJ,QAAO,CAACC,EAAcC,IACrCD,EAAeZ,OAAOY,EAAcC,GAAM,IAExC,IAAIZ,IAEAA,EAAOU,QAAO,CAACC,EAAcC,KAC/BA,IAASX,GACZU,EAAaE,KAAKD,GAEZD,IACL","file":"arrays.js","sourcesContent":["/*!\n * Module Arrays\n */\n\n/**\n * @namespace Arrays\n */\n\nconst MODULE_NAME = 'Arrays';\n\n\n\nimport {assert, isA, orDefault} from './basic.js';\n\n\n\n/**\n * @namespace Arrays:remove\n */\n\n/**\n * Removes Elements from an Array, where to and from are inclusive.\n * If you only provide \"from\", that exact index is removed.\n *\n * Does not modify the original.\n *\n * Keep in mind, that \"from\" should normally be smaller than \"to\" to slice from left to right. This means that the elements\n * indexed by \"from\" and \"to\" should have the right order. For example: [1,2,3,4]. Here from=-1 and to=-3 are illegal since\n * \"from\" references a later element than \"to\", but there are also viable examples where \"from\" is numerically bigger. If we\n * use from=2 and to=-1, \"from\" is numerically bigger, but references an earlier element than -1 (which is the last element), which\n * is totally okay. Just make sure \"from\" comes before \"to\" in the element's order.\n *\n * If you provide a string for \"from\" everything matching that string with its string representation will be removed\n * (you can provide stringification for objects via the toString method, see:\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString).\n *\n * Everything else provided for \"from\" will determine the element(s) to remove by identity (===).\n *\n * If you want to remove several elements at once, you may provide an iterable collection (array, object) as \"from\" and\n * set \"to\" to true, to interpret \"from\" as a value range. This also makes it possible to actually remove numbers from\n * an array by identity: define the number(s) as an array, to signal, that these are no indices.\n *\n * @param {Array} target - the array to remove elements from\n * @param {*} from - numerical index to start removing from (can also be negative to start counting from back), a string to identify elements to remove by their string representation or any other value identifying elements to remove by identity\n * @param {?Number|Boolean} [to=null] - index to end removing (can also be negative to end counting from back), if true, \"from\" defines several values to be removed as a collection (iterable) instead of a memory reference to check, in this case, each item in the collection defines elements to remove either by string or reference identity\n * @throws error if target is not an array\n * @returns {Array} new array without index/range/matches\n *\n * @memberof Arrays:remove\n * @alias remove\n * @example\n * remove([1, 2, 3, 4, 5], 0, 2);\n * => [4, 5]\n * remove([1, 2, 3, 4, 5], -3, -1);\n * => [1, 2]\n * remove([{a : 'b', toString(){ return 'b'; }}, 'b', b, 1], 'b');\n * => [b, 1]\n * remove([{a : 'b', toString(){ return 'b'; }}, 'b', b, 1], b);\n * => [{a : 'b', toString(){ return 'b'; }}, 'b', 1]\n * remove([true, true, false, true, true], true)\n * => [false]\n * remove([{a : 'b', toString(){ return 'b'; }}, 'b', b, 1, 2], ['b', b, 2], true);\n * => [1]\n */\nexport function remove(target, from, to){\n\tassert(Array.isArray(target), `${MODULE_NAME}:remove | target is no array`);\n\n\tif( isA(from, 'number') && (to !== false) ){\n\t\tfrom = parseInt(from, 10);\n\t\tto = orDefault(to, null, 'integer');\n\n\t\ttarget = target.slice(0);\n\t\tconst rest = target.slice((to || from) + 1 || target.length);\n\t\ttarget.length = (from < 0) ? (target.length + from) : from;\n\n\t\treturn target.concat(rest);\n\t} else if( isA(from, 'string') ){\n\t\treturn target.reduce((reducedArray, item) => {\n\t\t\tif( `${item}` !== from ){\n\t\t\t\treducedArray.push(item);\n\t\t\t}\n\t\t\treturn reducedArray;\n\t\t}, []);\n\t} else {\n\t\tconst fromList = isA(from, 'object') ? Object.values(from) : Array.from(from);\n\n\t\tif( (to === true) && (fromList.length > 0) ){\n\t\t\treturn fromList.reduce((reducedArray, item) => {\n\t\t\t\treducedArray = remove(reducedArray, item, false);\n\t\t\t\treturn reducedArray;\n\t\t\t}, [...target]);\n\t\t} else {\n\t\t\treturn target.reduce((reducedArray, item) => {\n\t\t\t\tif( item !== from ){\n\t\t\t\t\treducedArray.push(item);\n\t\t\t\t}\n\t\t\t\treturn reducedArray;\n\t\t\t}, []);\n\t\t}\n\t}\n}\n"]}
{"version":3,"sources":["objects.js"],"names":["MODULE_NAME","getType","isA","orDefault","clone","target","deep","seenReferences","Array","from","arguments","seenCopies","indexOf","targetType","arrayCopy","push","i","length","setCopy","WeakSet","Set","forEach","value","add","mapCopy","WeakMap","Map","key","set","objectCopy","Object","create","getPrototypeOf","__proto__","prop","hasOwnProperty","fragment","document","createDocumentFragment","element","appendChild","item","childNodes","Date","getTime","RegExp","cloneNode"],"mappings":";;;AAQA,MAAMA,YAAc,iBAIZC,QAASC,IAAKC,cAAgB,oBA2C/B,SAASC,MAAMC,EAAQC,GAAK,GAGlC,GAFAA,EAAOH,UAAUG,GAAM,EAAM,QAEzBJ,IAAIG,EAAOD,MAAO,YACrB,OAAOC,EAAOD,MAAME,GAGrB,MACCC,EAAiBC,MAAMC,KAAKC,WAAW,IAAM,GAC7CC,EAAaH,MAAMC,KAAKC,WAAW,IAAM,GAG1C,GAAIH,EAAeK,QAAQP,IAAW,EACrC,OAAOM,EAAWJ,EAAeK,QAAQP,IAG1C,MAAMQ,EAAaZ,QAAQI,GAC3B,OAAQQ,GACP,IAAK,QACJ,MAAMC,EAAY,IAAIT,GAKtB,GAHAE,EAAeQ,KAAKV,GACpBM,EAAWI,KAAKD,GAEZR,EAAM,CACT,IAAIU,EAAIF,EAAUG,OAClB,KAAOD,KACNF,EAAUE,GAAKZ,MAAMU,EAAUE,GAAIV,EAAMC,EAAgBI,GAI3D,OAAOG,EAER,IAAK,MACL,IAAK,UACJ,MAAMI,EAA0B,YAAfL,EACd,IAAIM,QACJ,IAAIC,IAcP,OAXAb,EAAeQ,KAAKV,GACpBM,EAAWI,KAAKG,GAEhBb,EAAOgB,SAAQC,IACVhB,EACHY,EAAQK,IAAInB,MAAMkB,EAAOhB,EAAMC,EAAgBI,IAE/CO,EAAQK,IAAID,MAIPJ,EAER,IAAK,MACL,IAAK,UACJ,MAAMM,EAA0B,YAAfX,EACd,IAAIY,QACJ,IAAIC,IAcP,OAXAnB,EAAeQ,KAAKV,GACpBM,EAAWI,KAAKS,GAEhBnB,EAAOgB,SAAQ,CAACC,EAAOK,KAClBrB,EACHkB,EAAQI,IAAID,EAAKvB,MAAMkB,EAAOhB,EAAMC,EAAgBI,IAEpDa,EAAQI,IAAID,EAAKL,MAIZE,EAER,IAAK,SACJ,MAAMK,EAAaC,OAAOC,OAAOD,OAAOE,eAAiBF,OAAOE,eAAe3B,GAAUA,EAAO4B,WAEhG1B,EAAeQ,KAAKV,GACpBM,EAAWI,KAAKc,GAEhB,IAAK,IAAIK,KAAQ7B,EACZA,EAAO8B,eAAeD,KAExBL,EAAWK,GADR5B,EACgBF,MAAMC,EAAO6B,GAAO5B,EAAMC,EAAgBI,GAE1CN,EAAO6B,IAK7B,OAAOL,EAER,IAAK,WACJ,MAAMO,EAAWC,SAASC,yBAE1B,GAAIhC,EACHD,EAAOgB,SAAQkB,IACVjC,GACH8B,EAASI,YAAYpC,MAAMmC,EAASjC,EAAMC,EAAgBI,YAM5D,KAAON,EAAOY,QACbmB,EAASI,YAAYnC,EAAOoC,KAAK,IAInC,OAAOL,EAASM,WAEjB,IAAK,OAAQ,OAAO,IAAIC,KAAKtC,EAAOuC,WACpC,IAAK,SAAU,OAAO,IAAIC,OAAOxC,GACjC,IAAK,cAAe,OAAOA,EAAOyC,UAAUxC,GAC5C,QAAS,OAAOD","file":"objects.js","sourcesContent":["/*!\n * Module Objects\n */\n\n/**\n * @namespace Objects\n */\n\nconst MODULE_NAME = 'Objects';\n\n\n\nimport {getType, isA, orDefault} from './basic.js';\n\n\n\n/**\n * @namespace Objects:clone\n */\n\n/**\n * Cloning arbitrary objects, values and structured values is no trivial task in JavaScript.\n * For basic values this can easily achieved by serializing/deserializing via JSON.parse(JSON.stringify(value)), but\n * for everything not included in the JSON standard, such as nodes, sets, maps, functions and objects with constructors\n * this gets hairy pretty quickly.\n *\n * This function implements a fairly robust recursive cloning algorithm with circular dependency detection and should\n * be sufficient for 90% of your cloning needs. It can create deep and shallow copies, although I generally presume\n * that you need a deep copy if you are in need of a clone method to begin with. This method handles ordinal values,\n * regexes, dates and htmlelements/nodes, as well as nested structures consisting of arrays, plain objects,\n * simple constructed objects with settable properties, sets, maps and even nodelists.\n *\n * Be aware of these restrictions:\n * - map keys are not cloned since, if you would, you'd lose all access to values,\n *   because you would have no valid references\n * - cloning a nodelist in a shallow manner results in the original list being empty afterwards, since moving a node\n *   reference from one nodelist to another automatically removes the reference from the first, because a node may\n *   only appear at exactly one place in a dom tree\n *\n * If this function does not suffice, have a look at lodash's cloneDeep method, which is a very robust and complete\n * (but large and complex) solution: https://www.npmjs.com/package/lodash.clonedeep\n *\n * @param {*} target - the object/value to clone\n * @param {?Boolean} [deep=true] - define if nested objects/values are to be cloned as well or just referenced in a shallow way\n * @returns {*} the cloned object/value\n *\n * @memberof Objects:clone\n * @alias clone\n * @example\n * const foo = {foo : 'bar', bar : [new Foobar(1, 2, 3), new Set([new Date('2021-03-09'), new RegExp('^foobar$')])]};\n * const allNewFoo = clone(foo);\n * const shallowNewFoo = clone(foo, false);\n * const thatOneTextAgain = clone(document.querySelector('p.that-one-text'));\n * thatOneTextAgain.classList.add('hooray');\n */\nexport function clone(target, deep=true){\n\tdeep = orDefault(deep, true, 'bool');\n\n\tif( isA(target.clone, 'function') ){\n\t\treturn target.clone(deep);\n\t}\n\n\tconst\n\t\tseenReferences = Array.from(arguments)[2] ?? [],\n\t\tseenCopies = Array.from(arguments)[3] ?? []\n\t;\n\n\tif( seenReferences.indexOf(target) >= 0 ){\n\t\treturn seenCopies[seenReferences.indexOf(target)];\n\t}\n\n\tconst targetType = getType(target);\n\tswitch( targetType ){\n\t\tcase 'array':\n\t\t\tconst arrayCopy = [...target];\n\n\t\t\tseenReferences.push(target);\n\t\t\tseenCopies.push(arrayCopy);\n\n\t\t\tif( deep ){\n\t\t\t\tlet i = arrayCopy.length;\n\t\t\t\twhile( i-- ){\n\t\t\t\t\tarrayCopy[i] = clone(arrayCopy[i], deep, seenReferences, seenCopies);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn arrayCopy;\n\n\t\tcase 'set':\n\t\tcase 'weakset':\n\t\t\tconst setCopy = (targetType === 'weakset')\n\t\t\t\t? new WeakSet()\n\t\t\t\t: new Set()\n\t\t\t;\n\n\t\t\tseenReferences.push(target);\n\t\t\tseenCopies.push(setCopy);\n\n\t\t\ttarget.forEach(value => {\n\t\t\t\tif( deep ){\n\t\t\t\t\tsetCopy.add(clone(value, deep, seenReferences, seenCopies));\n\t\t\t\t} else {\n\t\t\t\t\tsetCopy.add(value);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn setCopy;\n\n\t\tcase 'map':\n\t\tcase 'weakmap':\n\t\t\tconst mapCopy = (targetType === 'weakmap')\n\t\t\t\t? new WeakMap()\n\t\t\t\t: new Map()\n\t\t\t;\n\n\t\t\tseenReferences.push(target);\n\t\t\tseenCopies.push(mapCopy);\n\n\t\t\ttarget.forEach((value, key) => {\n\t\t\t\tif( deep ){\n\t\t\t\t\tmapCopy.set(key, clone(value, deep, seenReferences, seenCopies));\n\t\t\t\t} else {\n\t\t\t\t\tmapCopy.set(key, value);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn mapCopy;\n\n\t\tcase 'object':\n\t\t\tconst objectCopy = Object.create(Object.getPrototypeOf ? Object.getPrototypeOf(target) : target.__proto__);\n\n\t\t\tseenReferences.push(target);\n\t\t\tseenCopies.push(objectCopy);\n\n\t\t\tfor( let prop in target ){\n\t\t\t\tif( target.hasOwnProperty(prop) ){\n\t\t\t\t\tif( deep ){\n\t\t\t\t\t\tobjectCopy[prop] = clone(target[prop], deep, seenReferences, seenCopies);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tobjectCopy[prop] = target[prop];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn objectCopy;\n\n\t\tcase 'nodelist':\n\t\t\tconst fragment = document.createDocumentFragment();\n\n\t\t\tif( deep ){\n\t\t\t\ttarget.forEach(element => {\n\t\t\t\t\tif( deep ){\n\t\t\t\t\t\tfragment.appendChild(clone(element, deep, seenReferences, seenCopies));\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t// shallow copying a nodelist is destructive, since appending the original element, empties the original\n\t\t\t// list, since every node may only exists once inside a dom\n\t\t\t} else {\n\t\t\t\twhile( target.length ){\n\t\t\t\t\tfragment.appendChild(target.item(0));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn fragment.childNodes;\n\n\t\tcase 'date': return new Date(target.getTime());\n\t\tcase 'regexp': return new RegExp(target);\n\t\tcase 'htmlelement': return target.cloneNode(deep);\n\t\tdefault: return target;\n\t}\n}\n"]}
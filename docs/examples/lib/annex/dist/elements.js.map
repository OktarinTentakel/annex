{"version":3,"file":"elements.js","names":["MODULE_NAME","orDefault","isA","isPlainObject","hasValue","assert","createNode","tag","attributes","content","trim","outerNode","document","createElement","test","innerHTML","appendChild","node","firstChild","removeChild","attribute","setAttribute","textContent","insertNode","target","position","insertAdjacentElement","replaceNode","__methodName__","parentNode","getTextContent","onlyFirstLevel","childNodes","forEach","nodeType"],"sources":["elements.js"],"mappings":";;;AAQA,MAAMA,YAAc,kBAMZC,UAAWC,IAAKC,cAAeC,SAAUC,WAAa,oBA0CvD,SAASC,WAAWC,EAAKC,EAAW,KAAMC,EAAQ,MACxDF,EAAMN,UAAUM,EAAK,OAAQ,OAAOG,OACpCF,EAAaL,cAAcK,GAAcA,EAAa,KACtDC,EAAUR,UAAUQ,EAAS,KAAM,OAInC,MAAME,EAAYC,SAASC,cAAc,OAGxC,iBAAiBC,KAAKP,IACnB,gBAAgBO,KAAKP,GAIxBI,EAAUI,UAAYR,EAEtBI,EAAUK,YAAYJ,SAASC,cAAcN,IAG9C,MAAMU,EAAON,EAAUO,WAGvB,GAFAP,EAAUQ,YAAYF,GAElBb,SAASI,GACZ,IAAK,IAAIY,KAAaZ,EACrBS,EAAKI,aAAaD,EAAW,GAAGZ,EAAWY,MAQ7C,OAJIhB,SAASK,KACZQ,EAAKK,YAAcb,GAGbQ,CACR,QAmCO,SAASM,WAAWC,EAAQP,EAAMQ,EAAS,aASjD,OANApB,OAAOH,IAAIsB,EAAQ,eAAgB,4DAE9BtB,IAAIe,EAAM,iBACdA,EAAOX,WAAW,GAAGW,MAGdQ,GACP,IAAK,cACL,IAAK,SACJA,EAAW,cACZ,MACA,IAAK,WACL,IAAK,QACJA,EAAW,WACZ,MACA,IAAK,aACL,IAAK,UACJA,EAAW,aACZ,MAKA,QACCA,EAAW,YAMb,OAFAD,EAAOE,sBAAsBD,EAAUR,GAEhCA,CACR,QA2BO,SAASU,YAAYH,EAAQP,GACnC,MAAMW,EAAiB,cAavB,OAXAvB,OAAOH,IAAIsB,EAAQ,eAAgB,YAAkBI,0CAEhD1B,IAAIe,EAAM,iBACdA,EAAOX,WAAW,GAAGW,MAGtBZ,OAAOH,IAAIsB,EAAOK,WAAY,eAAgB,YAAkBD,4CAEhEL,WAAWC,EAAQP,EAAM,SACzBO,EAAOK,WAAWV,YAAYK,GAEvBP,CACR,QAuBO,SAASa,eAAeN,EAAQO,GAAe,GASrD,GARAA,EAAiB9B,UAAU8B,GAAgB,EAAO,QAE9C7B,IAAIsB,EAAQ,YACfA,EAASlB,WAAWkB,IAGrBnB,OAAOH,IAAIsB,EAAQ,eAAgB,+DAE/BO,EAAgB,CACnB,IAAIT,EAAc,GAQlB,OANAE,EAAOQ,WAAWC,SAAQhB,IACH,IAAlBA,EAAKiB,WACRZ,GAAeL,EAAKK,YACrB,IAGMA,CACR,CACC,OAAOE,EAAOF,WAEhB","sourcesContent":["/*!\n * Module Elements\n */\n\n/**\n * @namespace Elements\n */\n\nconst MODULE_NAME = 'Elements';\n\n\n\n//###[ IMPORTS ]########################################################################################################\n\nimport {orDefault, isA, isPlainObject, hasValue, assert} from './basic.js'\n\n\n\n//###[ EXPORTS ]########################################################################################################\n\n/**\n * @namespace Elements:createNode\n */\n\n/**\n * Creates an element on the fly programmatically, based on provided name, attributes and content or markup,\n * without inserting it into the DOM.\n *\n * If you provide markup as \"tag\", make sure that there is one single root element, this method returns exactly one\n * element, not a NodeList. Also be sure to _not_ just pass HTML source from an unsecure source, since this\n * method does not deal with potential security risks.\n *\n * One thing about dynamically creating script tags with this: if you want the script is javascript and you want to\n * actually execute the script upon adding it to the dom, you cannot provide the complete tag as a source string,\n * since scripts created with innerHTML will not execute.\n * (see: https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML#security_considerations)\n * Instead, just provide the tag name and define attributes and source via the parameters instead.\n *\n * @param {?String} [tag='span'] - tag of the element to create or markup for root element\n * @param {?Object} [attributes=null] - tag attributes as key/value-pairs, will also be added to provided markup\n * @param {?String} [content=null] - content to insert into the element as textContent, be aware, that this will replace other content in provided markup\n * @returns {HTMLElement} the created DOM-node\n *\n * @memberof Elements:createNode\n * @alias createNode\n * @example\n * document.body.appendChild(\n *   createNode('div', {id : 'content', style : 'display:none;'}, 'loading...')\n * );\n * document.body.appendChild(\n *   createNode('<div id=\"content\" style=\"display:none;\">loading...</div>')\n * );\n * document.body.appendChild(\n *   createNode('script', {type : 'text/javascript'}, 'alert(\"Hello World\");');\n * );\n */\nexport function createNode(tag, attributes=null, content=null){\n\ttag = orDefault(tag, 'span', 'str').trim();\n\tattributes = isPlainObject(attributes) ? attributes : null;\n\tcontent = orDefault(content, null, 'str');\n\n\t// using anything more generic like template results in non-standard nodes like\n\t// <script type=\"text/json\"> not being creatable\n\tconst outerNode = document.createElement('div');\n\n\tif(\n\t\t/^<[^\\/][^<>]*>/.test(tag)\n\t\t&& /<\\/[^<>\\/]+>$/.test(tag)\n\t){\n\t\t// using DOMParser results in non-standard nodes like\n\t\t// <script type=\"text/json\"> not being creatable\n\t\touterNode.innerHTML = tag;\n\t} else {\n\t\touterNode.appendChild(document.createElement(tag));\n\t}\n\n\tconst node = outerNode.firstChild;\n\touterNode.removeChild(node);\n\n\tif( hasValue(attributes) ){\n\t\tfor( let attribute in attributes ){\n\t\t\tnode.setAttribute(attribute, `${attributes[attribute]}`);\n\t\t}\n\t}\n\n\tif( hasValue(content) ){\n\t\tnode.textContent = content;\n\t}\n\n\treturn node;\n}\n\n\n\n/**\n * @namespace Elements:insertNode\n */\n\n/**\n * Inserts a node into the DOM in relation to a target element.\n *\n * If the node is not an element, the parameter is treated as source and a node is created\n * automatically based on that.\n *\n * The position can be determined with the same values as in \"insertAdjacentElement\"\n * (see: https://developer.mozilla.org/en-US/docs/Web/API/Element/insertAdjacentElement),\n * but we also added the more intuitive jQuery aliases for positions:\n *\n * - \"beforebegin\" can also be described as \"before\"\n * - \"afterbegin\" can also be described as \"prepend\"\n * - \"beforeend\" can also be described as \"append\"\n * - \"afterend\" can also be descrived as \"after\"\n *\n * @param {HTMLElement} target - the element to which the node will be inserted in relation to\n * @param {HTMLElement|String} node - the node to insert, either as element or source string\n * @param {?String} [position='beforeend'] - the position to insert the node in relation to target, the default value appends the node as the last child in target\n * @throws error if target is not a node\n * @returns {HTMLElement} the inserted DOM-node\n *\n * @memberof Elements:insertNode\n * @alias insertNode\n * @example\n * insertNode(document.querySelector('.list-container'), listItemElement);\n * insertNode(document.querySelector('.list-container'), '<li>Item 42</li>', 'prepend');\n */\nexport function insertNode(target, node, position='beforeend'){\n\tconst __methodName__ = 'insertNode';\n\n\tassert(isA(target, 'htmlelement'), `${MODULE_NAME}.${__methodName__} | given target is not an HTMLElement`);\n\n\tif( !isA(node, 'htmlelement') ){\n\t\tnode = createNode(`${node}`);\n\t}\n\n\tswitch( position ){\n\t\tcase 'beforebegin':\n\t\tcase 'before':\n\t\t\tposition = 'beforebegin';\n\t\tbreak;\n\t\tcase 'afterend':\n\t\tcase 'after':\n\t\t\tposition = 'afterend';\n\t\tbreak;\n\t\tcase 'afterbegin':\n\t\tcase 'prepend':\n\t\t\tposition = 'afterbegin';\n\t\tbreak;\n\t\tcase 'beforeend':\n\t\tcase 'append':\n\t\t\tposition = 'beforeend';\n\t\tbreak;\n\t\tdefault:\n\t\t\tposition = 'beforeend';\n\t\tbreak;\n\t}\n\n\ttarget.insertAdjacentElement(position, node);\n\n\treturn node;\n}\n\n\n\n/**\n * @namespace Elements:replaceNode\n */\n\n/**\n * Replaces a node with another one.\n *\n * If the node is not an element, the parameter is treated as source and a node is created\n * automatically based on that.\n *\n * The target node needs a parent node for this function to work.\n *\n * @param {HTMLElement} target - the element to replace\n * @param {HTMLElement|String} node - the node to replace the target with\n * @throws error if target is not a node or does not have a parent node\n * @returns {HTMLElement} the replacement node\n *\n * @memberof Elements:replaceNode\n * @alias replaceNode\n * @example\n * replaceNode(document.querySelector('.hint'), newHintElement);\n * replaceNode(document.querySelector('.hint'), '<p class=\"hint\">Sale tomorrow!</p>');\n */\nexport function replaceNode(target, node){\n\tconst __methodName__ = 'replaceNode';\n\n\tassert(isA(target, 'htmlelement'), `${MODULE_NAME}.${__methodName__} | given target is not an HTMLElement`);\n\n\tif( !isA(node, 'htmlelement') ){\n\t\tnode = createNode(`${node}`);\n\t}\n\n\tassert(isA(target.parentNode, 'htmlelement'), `${MODULE_NAME}.${__methodName__} | given target does not have a parent)`);\n\n\tinsertNode(target, node, 'after');\n\ttarget.parentNode.removeChild(target);\n\n\treturn node;\n}\n\n\n\n/**\n * @namespace Elements:getTextContent\n */\n\n/**\n * Return the de-nodified text content of a node-ridden string or a DOM-node.\n * Returns the raw text content, with all markup cleanly removed.\n * Can also be used to return only the concatenated child text nodes.\n *\n * @param {(String|Node)} target - the node-ridden string or DOM-node to \"clean\"\n * @param {?Boolean} [onlyFirstLevel=false] - true if only the text of direct child text nodes is to be returned\n * @throws error if target is neither markup nor node\n * @returns {String} the text content of the provided markup or node\n *\n * @memberof Elements:getTextContent\n * @alias getTextContent\n * @example\n * someElement.textContent = getTextContent('<p onlick=\"destroyWorld();\">red button <a>meow<span>woof</span></a></p>');\n */\nexport function getTextContent(target, onlyFirstLevel=false){\n\tonlyFirstLevel = orDefault(onlyFirstLevel, false, 'bool');\n\n\tif( isA(target, 'string') ){\n\t\ttarget = createNode(target);\n\t}\n\n\tassert(isA(target, 'htmlelement'), `${MODULE_NAME}:getTextContent | target is neither node nor markup`);\n\n\tif( onlyFirstLevel ){\n\t\tlet textContent = '';\n\n\t\ttarget.childNodes.forEach(node => {\n\t\t\tif( node.nodeType === 3 ){\n\t\t\t\ttextContent += node.textContent;\n\t\t\t}\n\t\t});\n\n\t\treturn textContent;\n\t} else {\n\t\treturn target.textContent;\n\t}\n}\n"]}
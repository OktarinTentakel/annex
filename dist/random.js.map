{"version":3,"file":"random.js","names":["MODULE_NAME","orDefault","assert","hasValue","isFunction","pad","toBaseX","RANDOM_UUIDS_USED_SINCE_RELOAD","Set","DEFAULT_USER_CODE_ALPHABET","randomNumber","floor","ceiling","float","precision","power","Math","pow","res","random","round","parseFloat","randomUuid","withDashes","uuid","collisions","has","window","crypto","getRandomValues","msCrypto","replace","c","Uint8Array","toString","r","add","randomUserCode","alphabet","paddingCharacter","minLength","maxLength","randomValue","__methodName__","Uint16Array","reduce","sum","v","Error","code","Number","Date","toISOString","split","length"],"sources":["random.js"],"mappings":";;;AAQA,MAAMA,YAAc,gBAMZC,UAAWC,OAAQC,SAAUC,eAAiB,oBAC9CC,QAAU,sBACVC,YAAc,kBAMtB,MACCC,+BAAiC,IAAIC,IACrCC,2BAA6B,uCA+BvB,SAASC,aAAaC,EAAM,EAAGC,EAAQ,GAAIC,GAAM,EAAOC,EAAU,GACxEH,EAAQV,UAAUU,EAAO,EAAG,SAC5BC,EAAUX,UAAUW,EAAS,GAAI,SACjCC,EAAQZ,UAAUY,GAAO,EAAO,QAChCC,EAAYb,UAAUa,EAAW,EAAG,OAEpCZ,OAAQU,GAAWD,EAAQ,iDAE3B,MAAMI,EAAQC,KAAKC,IAAI,GAAIH,GAEvBD,IACHF,GAASI,EACTH,GAAWG,GAGZ,MAAMG,EAAMF,KAAKL,MAAMK,KAAKG,UAAYP,EAAUD,EAAQ,GAAKA,GAE/D,OAAOE,EAAUG,KAAKI,MAAMC,WAAWH,GAAOH,GAASA,EAASA,EAASG,CAC1E,QA0BO,SAASI,WAAWC,GAAW,GACrCA,EAAatB,UAAUsB,GAAY,EAAM,QAEzC,IACCC,EAAO,KACPC,EAAa,EAGd,MAAQtB,SAASqB,IAASjB,+BAA+BmB,IAAIF,IAQ3DA,EAHApB,WAAWuB,OAAOC,QAAQC,kBACvBzB,WAAWuB,OAAOG,UAAUD,kBAEvB,CAAC,MAAM,KAAK,KAAK,KAAK,MAAME,QAAQ,UAAUC,IACrDA,GAEC5B,WAAWuB,OAAOC,QAAQC,iBACxBF,OAAOC,OAAOC,gBAAgB,IAAII,WAAW,IAC7CN,OAAOG,UAAUD,gBAAgB,IAAII,WAAW,KACjD,GACA,IAAMD,EAAI,GACXE,SAAS,MAEJ,uCAAuCH,QAAQ,SAASC,IAC9D,MACCG,EAAoB,GAAhBnB,KAAKG,SAAgB,EAG1B,OAFW,MAANa,EAAYG,EAAS,EAAJA,EAAU,GAEvBD,SAAS,GAAG,IAInB3B,+BAA+BmB,IAAIF,KACtCC,IAEIA,EAAa,KAChBvB,OAAOuB,GAAc,IAAK,qFAO7B,OAFAlB,+BAA+B6B,IAAIZ,GAE5BD,EAAaC,EAAOA,EAAKO,QAAQ,KAAM,GAC/C,QAyCO,SAASM,eACfC,EAAS7B,2BACT8B,EAAiB,IACjBC,EAAU,EACVC,EAAU,GACVC,EAAY,MAEZ,MAAMC,EAAiB,iBAevB,GAbAL,EAAWrC,UAAUqC,EAAU7B,2BAA4B,OAC3D8B,EAAmBtC,UAAUsC,EAAkB,IAAK,OAAO,GAC3DC,EAAYvC,UAAUuC,EAAW,EAAG,OACpCC,EAAYxC,UAAUwC,EAAW,GAAI,OACrCC,EAAczC,UACbyC,EACAf,OAAOC,QAAQC,kBAAkB,IAAIe,YAAY,KAAKC,QAAO,CAACC,EAAKC,IAAMD,EAAMC,GAAG,IAC9EpB,OAAOG,UAAUD,kBAAkB,IAAIe,YAAY,KAAKC,QAAO,CAACC,EAAKC,IAAMD,EAAMC,GAAG,IACpFrC,aAAa,EAAG,QAEpB,OAGG+B,EAAYD,EACf,MAAMQ,MAAM,UAAkBL,kDAG/B,IAAIM,EAAO,GAAG3C,QAAQ4C,OACrB,GAAGR,KACF,IAAKS,MAAQC,cAAcrB,QAAQ,YAAa,KAC9CsB,MAAM,KACNR,QAAO,CAACC,EAAKC,IAAMD,EAAMI,OAAOH,IAAI,MAErCT,GAEH,GAAIW,EAAKK,OAASb,EACjB,MAAMO,MACL,UAAkBL,6DAMpB,OAJWM,EAAKK,OAASd,IACxBS,EAAO5C,IAAI4C,EAAMV,EAAkBC,EAAW,UAGxCS,CACR","sourcesContent":["/*!\n * Module Random\n */\n\n/**\n * @namespace Random\n */\n\nconst MODULE_NAME = 'Random';\n\n\n\n//###[ IMPORTS ]########################################################################################################\n\nimport {orDefault, assert, hasValue, isFunction} from './basic.js';\nimport {pad} from './strings.js';\nimport {toBaseX} from './conversion.js';\n\n\n\n//###[ DATA ]###########################################################################################################\n\nconst\n\tRANDOM_UUIDS_USED_SINCE_RELOAD = new Set(),\n\tDEFAULT_USER_CODE_ALPHABET = 'ACDEFGHKLMNPQRSTUVWXYZ2345679'\n;\n\n\n\n//###[ EXPORTS ]########################################################################################################\n\n/**\n * @namespace Random:randomNumber\n */\n\n/**\n * Special form of Math.random, returning a value in a defined range,\n * where floor and ceiling are included in the range.\n *\n * By default, this method return an integer, but by setting \"float\" to true and\n * optionally providing a float precision you can also work with floating point numbers.\n *\n * @param {?Number} [floor=0] - the lower end of random range, can either be integer or float\n * @param {?Number} [ceiling=10] - the upper end of random range, can either be integer or float\n * @param {?Boolean} [float=false] - define if we are working with floating point numbers\n * @param {?Number} [precision=2] - if we are working with floats, what precision are we working with, considering floor, ceiling and result?\n * @throws error if ceiling is smaller than floor\n * @returns {Number} random integer or float between floor and ceiling\n *\n * @memberof Random:randomNumber\n * @alias randomNumber\n * @example\n * let randomInt = randomNumber(23, 42);\n * let randomFloat = randomNumber(23.5, 42.123, true, 3);\n */\nexport function randomNumber(floor=0, ceiling=10, float=false, precision=2){\n\tfloor = orDefault(floor, 0, 'float');\n\tceiling = orDefault(ceiling, 10, 'float');\n\tfloat = orDefault(float, false, 'bool');\n\tprecision = orDefault(precision, 2, 'int');\n\n\tassert((ceiling >= floor), `${MODULE_NAME}:randomInt | ceiling smaller than floor`);\n\n\tconst power = Math.pow(10, precision);\n\n\tif( float ){\n\t\tfloor *= power;\n\t\tceiling *= power;\n\t}\n\n\tconst res = Math.floor(Math.random() * (ceiling - floor + 1) + floor);\n\n\treturn float ? ((Math.round(parseFloat(res) * power) / power) / power) : res;\n}\n\n\n\n/**\n * @namespace Random:randomUuid\n */\n\n/**\n * Generate a RFC4122-compliant random UUID, as far as possible with JS.\n * Generation is heavily dependent on the quality of randomization, which in some JS-engines is weak using\n * Math.random. Therefore, we are using the specific crypto api if available and only fall back to random if necessary.\n * Additionally, we track used UUIDs to never return the same id twice per reload.\n *\n * For a detailed discussion, see: https://stackoverflow.com/a/2117523\n *\n * @param {?Boolean} [withDashes=true] - defines if UUID shall include dashes or not\n * @throws error if too many collisions happen and the random implementation seems to be broken\n * @returns {String} a \"UUID\"\n *\n * @memberof Random:randomUuid\n * @alias randomUuid\n * @example\n * const uuidWithDashes = randomUuid();\n * const uuidWithoutDashes = randomUuid(false);\n */\nexport function randomUuid(withDashes=true){\n\twithDashes = orDefault(withDashes, true, 'bool');\n\n\tlet\n\t\tuuid = null,\n\t\tcollisions = 0\n\t;\n\n\twhile( !hasValue(uuid) || RANDOM_UUIDS_USED_SINCE_RELOAD.has(uuid) ){\n\t\t// we have to do this highly convoluted check, because we have to call getRandomValues\n\t\t// explicitly from either window.crypto or window.msCrypto, since invoking it from another\n\t\t// context will trigger an \"illegal invocation\" of the method :(\n\t\tif(\n\t\t\tisFunction(window.crypto?.getRandomValues)\n\t\t\t|| isFunction(window.msCrypto?.getRandomValues)\n\t\t){\n\t\t\tuuid = ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c => (\n\t\t\t\tc\n\t\t\t\t^ (\n\t\t\t\t\tisFunction(window.crypto?.getRandomValues)\n\t\t\t\t\t? window.crypto.getRandomValues(new Uint8Array(1))\n\t\t\t\t\t: window.msCrypto?.getRandomValues(new Uint8Array(1))\n\t\t\t\t)[0]\n\t\t\t\t& 15 >> c / 4\n\t\t\t).toString(16));\n\t\t} else {\n\t\t\tuuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {\n\t\t\t\tconst\n\t\t\t\t\tr = Math.random() * 16 | 0,\n\t\t\t\t\tv = c === 'x' ? r : (r & 0x3 | 0x8)\n\t\t\t\t;\n\t\t\t\treturn v.toString(16);\n\t\t\t});\n\t\t}\n\n\t\tif( RANDOM_UUIDS_USED_SINCE_RELOAD.has(uuid) ){\n\t\t\tcollisions++;\n\n\t\t\tif( collisions > 100 ){\n\t\t\t\tassert(collisions <= 100, `${MODULE_NAME}:randomUuid | too many collisions, there seems to be randomization problem`)\n\t\t\t}\n\t\t}\n\t}\n\n\tRANDOM_UUIDS_USED_SINCE_RELOAD.add(uuid);\n\n\treturn withDashes ? uuid : uuid.replace(/-/g, '');\n}\n\n\n\n/**\n * @namespace Random:randomUserCode\n */\n\n/**\n * Generates a random code, to be presented to the user, being easily readable and concise.\n * Use this for things like, coupon codes, session IDs and everything, that might be transcribed by hand.\n *\n * The algorithm used is using time-based information in combination with a larger random number, so, there should not\n * be any collisions, but build in a fail-safe, if you persist this code to a database, to make absolutely sure, that\n * the code is unique.\n *\n * The used method here is formulated, to result in a short, concise highly readable code, while keeping the value\n * highly random and as collision-free as possible. The basis for this is a combination of a compressed ISO-datetime\n * string and a crypto-random-based combination of several random Uint8-values.\n *\n * Hint: if you need a general implementation to convert a value to a certain alphabet/base, have a look at\n * `Conversion:toBaseX`.\n *\n * @param {?String} [alphabet='ACDEFGHKLMNPQRSTUVWXYZ2345679'] - the character pool to use for code generation\n * @param {?String} [paddingCharacter='8'] - the character to use for value padding if generated code is too short\n * @param {?Number} [minLength=8] - the min length, the code has to have at least, will be padded if too short\n * @param {?Number} [maxLength=12] - the max length, the code can have at most, a code longer than this, will result in an error\n * @param {?Number} [randomValue=null] - random integer to include in the code's base value, should be ~6 digits, will automatically be generated if missing\n * @throws error if maxLength is smaller than minLength\n * @throws error if the generated code is longer than maxLength\n * @returns {String} the generated user code\n *\n * @memberof Random:randomUserCode\n * @alias randomUserCode\n * @see Conversion:toBaseX\n * @example\n * randomUserCode()\n * => 'GVK6RNQ8'\n * randomUserCode('0123456789ABCDEF', 10, 10, '=')\n * => 'A03CF25D7='\n */\nexport function randomUserCode(\n\talphabet=DEFAULT_USER_CODE_ALPHABET,\n\tpaddingCharacter='8',\n\tminLength=8,\n\tmaxLength=12,\n\trandomValue=null\n){\n\tconst __methodName__ = 'randomUserCode';\n\n\talphabet = orDefault(alphabet, DEFAULT_USER_CODE_ALPHABET, 'str');\n\tpaddingCharacter = orDefault(paddingCharacter, '8', 'str')[0];\n\tminLength = orDefault(minLength, 8, 'int');\n\tmaxLength = orDefault(maxLength, 12, 'int');\n\trandomValue = orDefault(\n\t\trandomValue,\n\t\twindow.crypto?.getRandomValues?.(new Uint16Array(15)).reduce((sum, v) => sum + v, 0)\n\t\t\t?? window.msCrypto?.getRandomValues?.(new Uint16Array(15)).reduce((sum, v) => sum + v, 0)\n\t\t\t?? randomNumber(1, 999999)\n\t\t,\n\t\t'int'\n\t);\n\n\tif( maxLength < minLength ){\n\t\tthrow Error(`${MODULE_NAME}:${__methodName__} | minLength cannot be smaller than maxLength`);\n\t}\n\n\tlet code = ''+toBaseX(Number(\n\t\t`${randomValue}${\n\t\t\t(new Date()).toISOString().replace(/[\\-T:.Z]/g, '?')\n\t\t\t\t.split('?')\n\t\t\t\t.reduce((sum, v) => sum + Number(v), 0)\n\t\t}`\n\t), alphabet);\n\n\tif( code.length > maxLength ){\n\t\tthrow Error(\n\t\t\t`${MODULE_NAME}:${__methodName__} | code too long, check maxLength and custom randomValue`\n\t\t);\n\t} else if( code.length < minLength ){\n\t\tcode = pad(code, paddingCharacter, minLength, 'right');\n\t}\n\n\treturn code;\n}\n"]}
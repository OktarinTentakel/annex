{"version":3,"sources":["basic.js"],"names":["log","warn","assert","condition","message","orDefault","Error","attempt","closure","isA","ex","hasValue","res","Array","from","arguments","forEach","value","isEmpty","emptyValues","undefined","obj","isArray","__additionalEmptyValues__","concat","Set","includes","length","Object","keys","size","hasMembers","memberNames","verbose","memberName","info","expression","defaultValue","caster","additionalEmptyValues","toLowerCase","parseInt","parseFloat","getType","deepType","prototype","toString","call","slice","match","type","isInt","intVal","isFloat","floatVal","isNaN","checkForIdentity","minMax","min","max","Deferred","[object Object]","this","resolve","reject","promise","Promise","rej","f","then","catch"],"mappings":"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","file":"basic.js","sourcesContent":["/*!\n * Module Basic\n */\n\n/**\n * @namespace Basic\n */\n\n\n\nimport {log, warn} from './logging.js';\n\n\n\n/**\n * @namespace Basic:assert\n */\n\n/**\n * Classical assert method. If condition is falsy, throw assert exception.\n *\n * @param {Boolean} condition - defines if an assertion is successful\n * @param {?String} [message='assert exception: assertion failed'] - to display if assertion fails\n * @throws assert exception\n *\n * @memberof Basic:assert\n * @alias assert\n * @example\n * function set(name, value){\n *   assert(name.length > 0);\n *   assert(isPlainObject(value), 'error: value must be plain object');\n *   ...\n * }\n */\nexport function assert(condition, message){\n\tif( !condition ){\n\t\tmessage = orDefault(message, 'assert exception: assertion failed', 'string');\n\t\tthrow new Error(message);\n\t}\n}\n\n\n\n/**\n * @namespace Basic:attempt\n */\n\n/**\n * Attempt to compute contents of closure and catch all occurring exceptions.\n * The boolean result tells you if the operation was successful or not.\n *\n * This is most helpful, when used to test value conversions or other atomic/singluar operations, where it\n * just is important if something isolated works or not.\n *\n * Do not encapsulate complex code in the closure and mind recursively occurring exceptions!\n *\n * @param {Function} closure - the code to test\n * @returns {Boolean} true if no exception occurred\n *\n * @memberof Basic:attempt\n * @alias attempt\n * @example\n * if( !attempt(function(){ foobar(); }) ){ log('foobar cannot be executed!'); }\n */\nexport function attempt(closure){\n\tassert(isA(closure, 'function'), 'attempt | closure is not a function');\n\n\ttry {\n\t\tclosure();\n\t} catch(ex){\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n\n\n/**\n * @namespace Basic:hasValue\n */\n\n/**\n * Check if variable(s) is set, by being neither undefined nor null.\n *\n * @param {...*} [...] - add any number of variables you wish to check\n * @returns {Boolean} variable(s) is/are set\n *\n * @memberof Basic:hasValue\n * @alias hasValue\n * @example\n * function set(name, value){\n *   if( hasValue(name, value) ){\n *     ...\n *   }\n * }\n */\nexport function hasValue(){\n\tlet res = true;\n\n\tArray.from(arguments).forEach(value => {\n\t\tres = res && ((value !== undefined) && (value !== null));\n\t});\n\n\treturn res;\n}\n\n\n\n/**\n * @namespace Basic:isEmpty\n */\n\n/**\n * Check if variable(s) contain non-empty value\n * (not undefined, null, '', 0, [], {} or an empty Set/Map).\n *\n * You can supply additional non-empty values by providing an object having the key \"__additionalEmptyValues__\" as\n * any single parameter. Multiple occurrences will be merged.\n *\n * @param {...*} [...] - add any number of variables you wish to check\n * @returns {Boolean} variable(s) is/are non-empty\n *\n * @memberof Basic:isEmpty\n * @alias isEmpty\n * @example\n * function set(name, value){\n *   if( isEmpty(fooBar) || isEmpty({'__additionalEmptyValues__' : [false, '0']}, someArray, someSet, someString, value) ){\n *     ...\n *   }\n * }\n */\nexport function isEmpty(){\n\tlet\n\t\tres = true,\n\t\temptyValues = [undefined, null, '', 0]\n\t;\n\n\tArray.from(arguments).forEach(obj => {\n\t\tif( Array.isArray(obj?.__additionalEmptyValues__) ){\n\t\t\temptyValues = emptyValues.concat(obj.__additionalEmptyValues__);\n\t\t}\n\t});\n\temptyValues = Array.from(new Set(emptyValues));\n\n\tArray.from(arguments).forEach(obj => {\n\t\tif( res && !Array.isArray(obj?.__additionalEmptyValues__) ){\n\t\t\tres = emptyValues.includes(obj);\n\n\t\t\tif( !res ){\n\t\t\t\tif( Array.isArray(obj) ){\n\t\t\t\t\tres = (obj.length === 0);\n\t\t\t\t} else if( isA(obj, 'object') ){\n\t\t\t\t\tres = Object.keys(obj).length === 0;\n\t\t\t\t} else if( isA(obj, 'set') || isA(obj, 'map') ){\n\t\t\t\t\tres = (obj.size === 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\treturn res;\n}\n\n\n\n/**\n * @namespace Basic:hasMembers\n */\n\n/**\n * \"Validates\" an object in a very basic way by checking if all given members are present and are not nullish.\n *\n * @param {Object} obj - the object to check\n * @param {String[]} memberNames - the names of the members to check\n * @param {Boolean} [verbose=false] - defines if method should output missing members to console\n * @returns {Boolean} all memberNames present and not nullish\n *\n * @memberof Basic:hasMembers\n * @alias hasMembers\n * @example\n * function pat(kitten){\n *   if( hasMembers(kitten, ['fluff', 'meow', 'scratch']) ){\n *     ...\n *   }\n * }\n */\nexport function hasMembers(obj, memberNames, verbose){\n\tverbose = orDefault(verbose, false, 'boolean');\n\n\tlet res = true;\n\n\tmemberNames.forEach(memberName => {\n\t\tif( !hasValue(obj[memberName]) ){\n\t\t\tif( verbose ){\n\t\t\t\tlog().info(`hasMembers | missing member ${memberName}`);\n\t\t\t}\n\n\t\t\tres = false;\n\t\t}\n\t});\n\n\treturn res;\n}\n\n\n\n/**\n * @namespace Basic:orDefault\n */\n\n/**\n * If an expression returns an \"empty\" value, use the default value instead.\n * Define a caster name, to force expression result/value into certain data type.\n *\n * @param {*} expression - the expression to evaluate\n * @param {*} defaultValue - the default value to use if the expression is considered empty\n * @param {?(String|Function)} [caster=null] - either a default caster by name ('str', 'string', 'int', 'integer', 'bool', 'boolean', 'float', 'arr', 'array') or a function getting the value and returning the transformed value\n * @param {?Array} [additionalEmptyValues=null] - if set, provides a list of additional values to be considered empty, apart from undefined and null\n * @returns {*} expression of defaultValue\n *\n * @memberof Basic:orDefault\n * @alias orDefault\n * @example\n * function set(name, value){\n *   name = orDefault(name, 'kittens!', 'string', ['', 'none']);\n *   value = orDefault(value, 42, 'int');\n * }\n */\nexport function orDefault(expression, defaultValue, caster=null, additionalEmptyValues=null){\n\tif( hasValue(additionalEmptyValues) ){\n\t\tadditionalEmptyValues = [].concat(additionalEmptyValues);\n\t} else {\n\t\tadditionalEmptyValues = [];\n\t}\n\n\tif( hasValue(caster) ){\n\t\tif(\n\t\t\t!isA(caster, 'function')\n\t\t\t&& ([\n\t\t\t\t'str', 'string',\n\t\t\t\t'int', 'integer',\n\t\t\t\t'bool', 'boolean',\n\t\t\t\t'float',\n\t\t\t\t'arr', 'array'\n\t\t\t].includes(`${caster.toLowerCase()}`))\n\t\t){\n\t\t\tcaster = `${caster}`.toLowerCase();\n\n\t\t\tif( ['str', 'string'].includes(caster) ){\n\t\t\t\tcaster = function(value){ return `${value}`; };\n\t\t\t} else if( ['int', 'integer'].includes(caster) ){\n\t\t\t\tcaster = function(value){ return parseInt(value, 10); };\n\t\t\t} else if( ['bool', 'boolean'].includes(caster) ){\n\t\t\t\tcaster = function(value){ return !!value; };\n\t\t\t} else if( caster === 'float' ){\n\t\t\t\tcaster = function(value){ return parseFloat(value); };\n\t\t\t} else if( ['arr', 'array'].includes(caster) ){\n\t\t\t\tcaster = function(value){ return [].concat(value); };\n\t\t\t}\n\t\t} else if( !isA(caster, 'function') ){\n\t\t\tcaster = function(value){ return value; };\n\t\t}\n\t} else {\n\t\tcaster = function(value){ return value; };\n\t}\n\n\tif( !hasValue(expression) || (additionalEmptyValues.includes(expression)) ){\n\t\treturn defaultValue;\n\t} else {\n\t\treturn caster(expression);\n\t}\n}\n\n\n\n/**\n * @namespace Basic:getType\n */\n\n/**\n * Prod-ready type detection for values, expanding on flawed typeof functionality, following\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof\n *\n * Types:\n * - \"undefined\"\n * - \"null\"\n * - \"boolean\"\n * - \"number\"\n * - \"bigint\"\n * - \"string\"\n * - \"symbol\"\n * - \"function\"\n * - \"object\"\n * - \"array\"\n * - \"date\"\n * - \"error\"\n * - \"generator\"\n * - \"regexp\"\n * - \"set\"\n * - \"weakset\"\n * - \"map\"\n * - \"weakmap\"\n *\n * @param {*} [value] - variable to check the type of\n * @returns {String} the value type in lower case\n *\n * @memberof Basic:getType\n * @alias getType\n * @example\n * if( getType(cb) === 'function' ){\n *     ...\n * }\n */\nexport function getType(value) {\n\tif( !hasValue(value) ) return `${value}`.toLowerCase();\n\n\tconst deepType = Object.prototype.toString.call(value).slice(8,-1).toLowerCase();\n\n\tif( deepType === 'generatorfunction' ) return 'function';\n\n\treturn deepType.match(/^(array|bigint|date|error|function|generator|regexp|symbol|set|weakset|map|weakmap)$/)\n\t\t? deepType\n\t\t: ((typeof value === 'object') || (typeof value === 'function')) ? 'object' : typeof value\n\t;\n}\n\n\n\n/**\n * @namespace Basic:isA\n */\n\n/**\n * Short form of \"getType\"-method with a more compact syntax.\n * Can identify all types listed in getType.\n *\n * @param {*} value - variable to check the type of\n * @param {String} type - the name of the type to check for, has to be a standard JS-type, is case insensitive\n * @returns {Boolean} target has type\n *\n * @memberof Basic:isA\n * @alias isA\n * @see getType\n * @example\n * let stringBool = (isA(test, 'boolean') && test) ? 'true' : 'false';\n */\nexport function isA(value, type){\n\tif(\n\t\t[\n\t\t\t'undefined',\n\t\t\t'null',\n\t\t\t'boolean',\n\t\t\t'number',\n\t\t\t'bigint',\n\t\t\t'string',\n\t\t\t'symbol',\n\t\t\t'function',\n\t\t\t'object',\n\t\t\t'array',\n\t\t\t'date',\n\t\t\t'error',\n\t\t\t'generator',\n\t\t\t'regexp',\n\t\t\t'set',\n\t\t\t'weakset',\n\t\t\t'map',\n\t\t\t'weakmap'\n\t\t].includes(`${type}`.toLowerCase())\n\t){\n\t\treturn getType(value) === `${type}`.toLowerCase();\n\t} else {\n\t\twarn(`isA | \"${type}\" is not a recognized type for this function`);\n\t\treturn false;\n\t}\n}\n\n\n\n/**\n * @namespace Basic:isInt\n */\n\n/**\n * Returns if a value is truly a real integer value and not just an int-parsable value for example.\n * Since JS only knows the data type \"number\" all numbers are usable as floats by default, but not the\n * other way round.\n *\n * @param {*} intVal - the value the check\n * @returns {Boolean} true if intVal is a true integer value\n *\n * @memberof Basic:isInt\n * @alias isInt\n * @example\n * if( !isInt(val) ){\n *   val = parseInt(val, 10);\n * }\n */\nexport function isInt(intVal){\n\treturn parseInt(intVal, 10) === intVal;\n}\n\n\n\n/**\n * @namespace Basic:isFloat\n */\n\n/**\n * Returns if a value is a numeric value, usable as a float number in any calculation.\n * Any number that fulfills isInt, is also considered a valid float, which lies in JS's\n * nature of not differentiating ints and floats by putting them both into a \"number\"-type.\n * So ints are always floats, but not necessarily the other way round.\n *\n * @param {*} floatVal - the value to check\n * @returns {Boolean} true if floatVal is usable in a float context\n *\n * @memberof Basic:isFloat\n * @alias isFloat\n * @example\n * if( !isFloat(val) ){\n *   alert('val can not be calculated with!');\n * }\n */\nexport function isFloat(floatVal){\n\treturn parseFloat(floatVal) === floatVal;\n}\n\n\n\n/**\n * @namespace Basic:isNaN\n */\n\n/**\n * Returns if an expression is NaN or not.\n * This method employs two different approaches:\n * By default it really checks if the expression is the _value_ NaN or not, this being a valid JS-value for something.\n * In JS this gets checked by comparing an expression with itself on identity, since NaN is the only value not being\n * identical to itself. If you set checkForIdentity to false, this method will use the standard JS-isNaN, which\n * inspects the expression, tries to cast or parse a number from it and returns the result.\n *\n * @param {*} expression - the expression to check\n * @param {Boolean} [checkForIdentity=true] - set to false if you want to use default JS-functionality\n * @returns {Boolean} true if expression is NaN\n *\n * @memberof Basic:isNaN\n * @alias isNaN\n * @example\n * if( !isNaN(suspiciousCalculatedValue) ){\n *   return suspiciousCalculatedValue * 3;\n * }\n */\nexport function isNaN(expression, checkForIdentity){\n\tcheckForIdentity = orDefault(checkForIdentity, true, 'boolean');\n\n\tif( checkForIdentity ){\n\t\treturn expression !== expression;\n\t} else {\n\t\treturn isNaN(expression);\n\t}\n}\n\n\n\n/**\n * @namespace Basic:minMax\n */\n\n/**\n * Checks if a value is within bounds of a minimum and maximum and returns\n * the value or the upper or lower bound respectively.\n *\n * Accepts all values comparable with > and <.\n *\n * @param {*} min - the lower bound\n * @param {*} value - the value to check\n * @param {*} max - the upper bound\n * @throws error if min is not smaller than max\n * @returns {*} value, min or max\n *\n * @memberof Basic:minMax\n * @alias minMax\n * @example\n * let croppedVal = minMax(-100, value, 100);\n */\nexport function minMax(min, value, max){\n\tassert(min <= max, 'minMax | min can not be larger than max');\n\n\treturn (value < min)\n\t\t? min\n\t\t: (\n\t\t\t(value > max)\n\t\t\t\t? max\n\t\t\t\t: value\n\t\t)\n\t;\n}\n\n\n\n/**\n * @namespace Basic:Deferred\n */\n\n/**\n * Class that wraps a Promise, to allow resolving and rejecting outside of the\n * Promise's function scope. This allows for decoupled handling of states and\n * handling promises as references in a distributed context, like a class, where\n * a Deferred might then represent an async state.\n *\n * This follows ideas by jQuery and Q Promises:\n * - https://api.jquery.com/jQuery.Deferred/\n * - https://github.com/kriskowal/q/wiki/Coming-from-jQuery#deferreds-promises-resolvers\n *\n * Keep in mind, that Promises might need a polyfill such as core-js.\n *\n * @memberof Basic:Deferred\n * @name Deferred\n * @example\n * const doStuff = new Deferred();\n * doStuff.then(value => { alert(`yeah, ready with \"${value}\"!`); }).catch(err => { console.error(err); });\n * ...\n * if( foobar === 42 ){\n *   doStuff.resolve(42);\n * } else {\n *   doStuff.reject(new Error('not 42!'));\n * }\n */\nexport class Deferred {\n\tconstructor(){\n\t\tthis.resolve = null;\n\t\tthis.reject = null;\n\t\tthis.promise = new Promise((res, rej) => {\n\t\t\tthis.resolve = res;\n\t\t\tthis.reject = rej;\n\t\t});\n\t}\n\n\tthen(f){\n\t\treturn this.promise.then(f);\n\t}\n\n\tcatch(f){\n\t\treturn this.promise.catch(f);\n\t}\n}\n"]}
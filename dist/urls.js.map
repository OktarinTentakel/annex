{"version":3,"file":"urls.js","names":["MODULE_NAME","hasValue","orDefault","size","urlParameter","url","parameter","searchParams","startsWith","URLSearchParams","protocol","window","location","URL","Error","fMapParameterValue","parameterValue","parameterValues","getAll","length","Array","from","Set","map","parameters","keys","forEach","parameterName","urlParameters","urlAnchor","withCaret","urlParts","split","anchor","decodeURIComponent","trim"],"sources":["urls.js"],"mappings":";;;AAQA,MAAMA,YAAc,cAMZC,SAAUC,UAAWC,SAAW,oBAwCjC,SAASC,aAAaC,EAAKC,EAAU,MAM3C,IAAIC,EACJ,GAJAF,EAAMH,UAAUG,EAAK,GAAI,OACzBC,EAAYJ,UAAUI,EAAW,KAAM,OAGlCD,EAAIG,WAAW,KAYnBD,EAAe,IAAIE,gBAAgBJ,OAZV,CACzB,IAAKA,EAAIG,WAAW,aAAeH,EAAIG,WAAW,YAAa,CAC9D,MAAME,EAAWC,OAAOC,SAASF,SACjCL,EAAM,GAAGA,EAAIG,WAAW,MAAQE,EAAWA,EAAS,OAAOL,GAC5D,CAEA,IACCE,EAAe,IAAIM,IAAIR,GAAKE,YAG7B,CAFE,MACD,MAAM,IAAIO,MAAM,oCAAmDT,KACpE,CACD,CAIA,MAAMU,EAAqBC,GAAuC,KAAnBA,GAAgCA,EAE/E,GAAIf,SAASK,GAAY,CACxB,MAAMW,EAAkBV,EAAaW,OAAOZ,GAC5C,OAA+B,IAA3BW,EAAgBE,OACZ,KAC8B,IAA3BF,EAAgBE,OACnBJ,EAAmBE,EAAgB,IAEnCG,MAAMC,KAAK,IAAIC,IAAIL,EAAgBM,IAAIR,IAEhD,CAAO,CACN,MAAMS,EAAa,CAAC,EAWpB,OAVAJ,MAAMC,KAAKd,EAAakB,QAAQC,SAAQC,IACvC,MAAMV,EAAkBV,EAAaW,OAAOS,GACxCV,EAAgBE,OAAS,IAC5BK,EAAWG,GACkB,IAA3BV,EAAgBE,OACfJ,EAAmBE,EAAgB,IACnCG,MAAMC,KAAK,IAAIC,IAAIL,EAAgBM,IAAIR,KAE3C,IAEOZ,KAAKqB,GAAc,EAAKA,EAAa,IAC9C,CACD,QAwBO,SAASI,cAAcvB,GAC7B,OAAOD,aAAaC,EACrB,QA6BO,SAASwB,UAAUxB,EAAKyB,GAAU,GACxCzB,EAAMH,UAAUG,EAAK,GAAI,OACzByB,EAAY5B,UAAU4B,GAAW,EAAO,QAExC,MAAMC,EAAW1B,EAAI2B,MAAM,KAE3B,IAAIC,EAAUF,EAASZ,OAAS,EAAKe,mBAAmBH,EAAS,GAAGI,QAAU,KAQ9E,MAPe,KAAXF,IACHA,EAAS,MAENH,GAAa7B,SAASgC,KACzBA,EAAS,IAAIA,KAGPA,CACR","sourcesContent":["/*!\n * Module Urls\n */\n\n/**\n * @namespace Urls\n */\n\nconst MODULE_NAME = 'Urls';\n\n\n\n//###[ IMPORTS ]########################################################################################################\n\nimport {hasValue, orDefault, size} from './basic.js';\n\n\n\n//###[ EXPORTS ]########################################################################################################\n\n/**\n * @namespace Urls:urlParameter\n */\n\n/**\n * Searches for and returns parameters embedded in the provided url containing a query string\n * (make sure all values are url encoded).\n *\n * You may also just provide the query string.\n *\n * Returns a single parameter's value if a parameter name is given, otherwise returns dictionary with all parameters\n * as keys and the associated parameter value.\n *\n * If a parameter has more than one value the values are returned as an array, whether being requested by name\n * or in the dictionary containing all params.\n *\n * If a parameter is set, but has no defined value (name present, but no = before next param)\n * the value is returned as boolean true.\n *\n * @param {String} url - the url containing the parameter string, is expected to be url-encoded (at least stuff like [+?&=]), may also be only the query string (_must_ begin with ?)\n * @param {?String} [parameter=null] - the name of the parameter to extract\n * @throws error if given url is not usable\n * @returns {null|true|String|Array|Object} null in case the parameter doesn't exist, true in case it exists but has no value, a string in case the parameter has one value, or an array of values, or a dictionary object of all available parameters with corresponding values\n *\n * @memberof Urls:urlParameter\n * @alias urlParameter\n * @example\n * const hasKittens = urlParameter('//foobar.com/bar?has_kittens', 'has_kittens');\n * => true\n * const hasDoggies = urlParameter('has_doggies=yes&has_doggies', 'has_doggies');\n * => ['yes', true]\n * const allTheData = urlParameter('?foo=foo&bar=bar&bar=barbar&bar');\n * => {foo : 'foo', bar : ['bar', 'barbar', true]}\n */\nexport function urlParameter(url, parameter=null){\n\tconst __methodName__ = 'urlParameter';\n\n\turl = orDefault(url, '', 'str');\n\tparameter = orDefault(parameter, null, 'str');\n\n\tlet searchParams;\n\tif( !url.startsWith('?') ){\n\t\tif(\t!url.startsWith('http://') && !url.startsWith('https://') ){\n\t\t\tconst protocol = window.location.protocol;\n\t\t\turl = `${url.startsWith('//') ? protocol : protocol+'//'}${url}`;\n\t\t}\n\n\t\ttry {\n\t\t\tsearchParams = new URL(url).searchParams;\n\t\t} catch {\n\t\t\tthrow new Error(`${MODULE_NAME}:${__methodName__} | invalid url \"${url}\"`);\n\t\t}\n\t} else {\n\t\tsearchParams = new URLSearchParams(url);\n\t}\n\n\tconst fMapParameterValue = parameterValue => ((parameterValue === '') ? true : parameterValue);\n\n\tif( hasValue(parameter) ){\n\t\tconst parameterValues = searchParams.getAll(parameter);\n\t\tif( parameterValues.length === 0 ){\n\t\t\treturn null;\n\t\t} else if( parameterValues.length === 1 ){\n\t\t\treturn fMapParameterValue(parameterValues[0]);\n\t\t} else {\n\t\t\treturn Array.from(new Set(parameterValues.map(fMapParameterValue)));\n\t\t}\n\t} else {\n\t\tconst parameters = {};\n\t\tArray.from(searchParams.keys()).forEach(parameterName => {\n\t\t\tconst parameterValues = searchParams.getAll(parameterName);\n\t\t\tif( parameterValues.length > 0 ){\n\t\t\t\tparameters[parameterName] =\n\t\t\t\t\t(parameterValues.length === 1)\n\t\t\t\t\t? fMapParameterValue(parameterValues[0])\n\t\t\t\t\t: Array.from(new Set(parameterValues.map(fMapParameterValue)))\n\t\t\t\t;\n\t\t\t}\n\t\t});\n\t\treturn (size(parameters) > 0) ? parameters : null;\n\t}\n}\n\n\n\n/**\n * @namespace Urls:urlParameters\n */\n\n/**\n * Searches for and returns parameters embedded in provided url with a parameter string.\n *\n * Semantic shortcut version of urlParameter without any given parameter.\n *\n * @param {String} url - the url containing the parameter string, is expected to be url-encoded (at least stuff like [+?&=]), may also be only the query string (_must_ begin with ?)\n * @throws error if given url is not usable\n * @returns {Object|null} dictionary object of all parameters or null if url has no parameters\n *\n * @memberof Urls:urlParameters\n * @alias urlParameters\n * @see urlParameter\n * @example\n * const allParams = urlParameters('http://www.foobar.com?foo=foo&bar=bar&bar=barbar&bar');\n * => {foo : 'foo', bar : ['bar', 'barbar', true]}\n */\nexport function urlParameters(url){\n\treturn urlParameter(url);\n}\n\n\n\n/**\n * @namespace Urls:urlAnchor\n */\n\n/**\n * Returns the currently set URL-Anchor on given URL.\n *\n * Theoretically, this function also works with any other string containing a hash (as long as there is \"#\" included),\n * since this implementation does not lean on \"new URL()\", but is a simple string operation.\n *\n * In comparison to \"location.hash\", this function actually decodes the hash automatically.\n *\n * @param {String} url - the url, in which to search for a hash\n * @param {?Boolean} [withCaret=false] - defines if the returned anchor value should contain leading \"#\"\n * @returns {String|null} current anchor value or null if no anchor was found\n *\n * @memberof Urls:urlAnchor\n * @alias urlAnchor\n * @example\n * const anchorWithoutCaret = urlAnchor('https://foobar.com#test');\n * => 'test'\n * const hrefAnchorWithCaret = urlAnchor(linkElement.getAttribute('href'), true);\n * => '#test'\n * const decodedAnchorFromLocation = urlAnchor(window.location.hash);\n */\nexport function urlAnchor(url, withCaret=false){\n\turl = orDefault(url, '', 'str');\n\twithCaret = orDefault(withCaret, false, 'bool');\n\n\tconst urlParts = url.split('#');\n\n\tlet anchor = (urlParts.length > 1) ? decodeURIComponent(urlParts[1].trim()) : null;\n\tif( anchor === '' ){\n\t\tanchor = null;\n\t}\n\tif( withCaret && hasValue(anchor) ){\n\t\tanchor = `#${anchor}`;\n\t}\n\n\treturn anchor;\n}\n"]}
{"version":3,"sources":["navigation.js"],"names":["MODULE_NAME","warn","hasValue","orDefault","isPlainObject","isEmpty","isA","assert","createNode","browserSupportsHistoryManipulation","HISTORY","current","state","title","host","window","location","path","pathname","popState","listening","callbacks","[object Object]","e","historyNew","forEach","cb","stateful","redirect","url","params","anchor","target","postParams","anchorFromUrlParts","split","length","replace","href","hash","urlParts","presentParamString","presentParams","paramArray","presentParam","paramName","push","encodeURIComponent","decodeURIComponent","finalUrl","indexOf","join","formAttributes","method","action","data-ajax","redirectForm","val","appendChild","type","name","value","document","body","submit","removeChild","parsedUrl","URL","ex","origin","eLink","createElement","rel","click","parentNode","open","assign","openTab","openWindow","options","parentWindow","tryAsPopup","windowName","optionArray","prop","includes","reload","cached","postUsable","form","changeCurrentUrl","usePushState","history","pushState","replaceState","bindHistoryChange","callback","clearOld","usePreviousState","statefulCallback","original","addEventListener","handler","unbindHistoryChange","oldCallbackCount","reduce","cbs","newCallbackCount","removeEventListener"],"mappings":"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","file":"navigation.js","sourcesContent":["/*!\n * Module Navigation\n */\n\n/**\n * @namespace Navigation\n */\n\nconst MODULE_NAME = 'Navigation';\n\n\n\nimport {warn} from './logging.js';\nimport {hasValue, orDefault, isPlainObject, isEmpty, isA, assert} from './basic.js';\nimport {createNode} from './elements.js';\nimport {browserSupportsHistoryManipulation} from './context.js';\n\n\n\n//###( MODULE DATA )###\n\nexport const HISTORY = {\n\tcurrent : {\n\t\tstate : null,\n\t\ttitle : '',\n\t\thost : window.location.host,\n\t\tpath : window.location.pathname\n\t},\n\tpopState : {\n\t\tlistening : false,\n\t\tcallbacks : [],\n\t\thandler(e){\n\t\t\tconst historyNew = {\n\t\t\t\tstate : e.state,\n\t\t\t\ttitle : e.title,\n\t\t\t\thost : window.location.host,\n\t\t\t\tpath : window.location.pathname\n\t\t\t};\n\n\t\t\tHISTORY.popState.callbacks.forEach(cb => {\n\t\t\t\tcb.stateful(e, historyNew);\n\t\t\t});\n\n\t\t\tHISTORY.current = historyNew;\n\t\t}\n\t}\n};\n\n\n\n/**\n * @namespace Navigation:redirect\n */\n\n/**\n * Everything you need to do basic navigation without history API.\n * Provide a URL to navigate to or leave the URL out, to use the current full URL.\n * Add GET-parameters (adding to those already present in the URL), define an anchor (or automatically get the one\n * defined in the URL), set a target to define a window to navigate to (or open a new one) and even\n * define POST-parameters to navigate while providing POST-data.\n *\n * If you define POST-params to navigate to a URL providing POST-data we internally build a custom form element,\n * with type \"post\", filled with hidden fields adding the form data, which we submit to navigate to the action, which\n * contains our url. Even the target carries over.\n *\n * If you define a target window and therefore open a new tab/window this function adds \"noopener,noreferrer\"\n * automatically if the origins do not match to increase security. If you need the opener, have a look at\n * \"openWindow\", which gives you more manual control in that regard.\n *\n * If you define a target and open an external URL, repeated calls to the same target will open multiple windows\n * due to the security settings.\n *\n * @param {?String} [url] - the location to load, if null current location is reloaded/used\n * @param {?Object} [params=null] - plain object of GET-parameters to add to the url, adds to existing ones in the URL and overwrites existing ones with same name\n * @param {?String} [anchor=null] - anchor/hash to set for called url, has precedence over URL hash\n * @param {?String} [target=null] - name of the window to perform the redirect to/in, use \"_blank\" to open a new window/tab\n * @param {?Object} [postParams=null] - plain object of postParameters to send with the redirect, solved with a hidden form\n *\n * @memberof Navigation:redirect\n * @alias redirect\n * @example\n * redirect('https://test.com', {search : 'kittens', order : 'asc'}, 'fluffykittens');\n * redirect(null, {order : 'desc'});\n */\nexport function redirect(url, params=null, anchor=null, target=null, postParams=null){\n\turl = orDefault(url, null, 'str');\n\tparams = isPlainObject(params) ? params : null;\n\tanchor = orDefault(anchor, null, 'str');\n\tpostParams = isPlainObject(postParams) ? postParams : null;\n\ttarget = orDefault(target, null, 'str');\n\n\tif( !hasValue(url) ){\n\t\turl = window.location.href;\n\n\t\tif( !isEmpty(window.location.hash) ){\n\t\t\tanchor = orDefault(anchor, window.location.hash.replace('#', ''), 'str');\n\t\t\turl = url.replace(/#.+$/, '');\n\t\t}\n\t} else {\n\t\tconst anchorFromUrlParts = url.split('#', 2);\n\n\t\tif( anchorFromUrlParts.length > 1 ){\n\t\t\tanchor = orDefault(anchor, anchorFromUrlParts[1], 'str');\n\t\t\turl = url.replace(/#.+$/, '');\n\t\t}\n\t}\n\n\tconst urlParts = url.split('?', 2);\n\turl = urlParts[0];\n\n\tconst\n\t\tpresentParamString = orDefault(urlParts[1], ''),\n\t\tpresentParams = {},\n\t\tparamArray = []\n\t;\n\n\tif( presentParamString.length > 0 ){\n\t\tpresentParamString.split('&').forEach(presentParam => {\n\t\t\tpresentParam = presentParam.split('=', 2);\n\t\t\tif( presentParam.length === 2 ){\n\t\t\t\tpresentParams[presentParam[0]] = presentParam[1];\n\t\t\t} else {\n\t\t\t\tpresentParams[presentParam[0]] = null;\n\t\t\t}\n\t\t});\n\t}\n\n\tparams = hasValue(params) ? {...presentParams, ...params} : presentParams;\n\n\tfor( let paramName in params ){\n\t\tif( hasValue(params[paramName]) ){\n\t\t\tparamArray.push(`${paramName}=${encodeURIComponent(decodeURIComponent(params[paramName]))}`);\n\t\t} else {\n\t\t\tparamArray.push(paramName);\n\t\t}\n\t}\n\n\tconst finalUrl = `${url}${\n\t\t\t(paramArray.length > 0)\n\t\t\t? `${(url.indexOf('?') === -1) ? '?' : '&'}${paramArray.join('&')}`\n\t\t\t: ''\n\t\t}${hasValue(anchor) ? `#${anchor}` : ''}`\n\t;\n\n\tif( hasValue(postParams) ){\n\t\tconst formAttributes = {method : 'post', action : finalUrl, 'data-ajax' : 'false'};\n\t\tif( hasValue(target) ){\n\t\t\tformAttributes.target = target;\n\t\t}\n\n\t\tconst redirectForm = createNode('form', formAttributes);\n\t\tfor( let paramName in postParams ){\n\t\t\tif( isA(postParams[paramName], 'array') ){\n\t\t\t\tpostParams[paramName].forEach(val => {\n\t\t\t\t\tredirectForm.appendChild(createNode(\n\t\t\t\t\t\t'input',\n\t\t\t\t\t\t{type : 'hidden', name : `${paramName}[]`, value : `${val}`}\n\t\t\t\t\t));\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tredirectForm.appendChild(createNode(\n\t\t\t\t\t'input',\n\t\t\t\t\t{type : 'hidden', name : paramName, value : `${postParams[paramName]}`}\n\t\t\t\t));\n\t\t\t}\n\t\t}\n\n\t\tdocument.body.appendChild(redirectForm);\n\t\tredirectForm.submit();\n\t\tdocument.body.removeChild(redirectForm);\n\t} else if( hasValue(target) ){\n\t\tlet parsedUrl;\n\n\t\ttry {\n\t\t\tparsedUrl = new URL(url);\n\t\t} catch(ex) {\n\t\t\tparsedUrl = new URL(url, window.location);\n\t\t}\n\n\t\tif( parsedUrl.origin !== window.location.origin ){\n\t\t\t// we have to jump through hoops here, since adding security features to window.open\n\t\t\t// forces popup windows in some browsers and although we can set opener via the created\n\t\t\t// window, we cannot reliably set the referrer that way\n\t\t\tconst eLink = document.createElement('a');\n\t\t\teLink.href = finalUrl;\n\t\t\teLink.target = target;\n\t\t\teLink.rel = 'noopener noreferrer';\n\t\t\tdocument.body.appendChild(eLink);\n\t\t\teLink.click();\n\t\t\teLink.parentNode.removeChild(eLink);\n\t\t} else {\n\t\t\twindow.open(finalUrl, target);\n\t\t}\n\t} else {\n\t\twindow.location.assign(finalUrl);\n\t}\n}\n\n\n\n/**\n * @namespace Navigation:openTab\n */\n\n/**\n * Opens a sub-window for the current window as _blank, which should result in a new tab in most browsers.\n *\n * This method is just a shortcut for \"redirect\" with a set target and reasonable parameters.\n *\n * By using \"redirect\", this method also automatically takes care of adding \"noopener,noreferrer\" to external\n * links, which are determined by not having the same origin as the current location. For more manual control\n * over such parameters, have a look at \"openWindow\" instead.\n *\n * @param {?String} [url] - the location to load, if null current location is reloaded/used\n * @param {?Object} [params=null] - plain object of GET-parameters to add to the url, adds to existing ones in the URL and overwrites existing ones with same name\n * @param {?String} [anchor=null] - anchor/hash to set for called url, has precedence over URL hash\n * @param {?Object} [postParams=null] - plain object of postParameters to send with the redirect, solved with a hidden form\n *\n * @memberof Navigation:openTab\n * @alias openTab\n * @see redirect\n * @example\n * openTab('/misc/faq.html');\n */\nexport function openTab(url, params=null, anchor=null, postParams=null){\n\tredirect(url, params, anchor, '_blank', postParams);\n}\n\n\n\n/**\n * @namespace Navigation:openWindow\n */\n\n/**\n * Opens a sub-window for the current window or another defined parent window.\n * Be aware that most browsers open new windows as a tab by default, have a look at the \"tryAsPopup\"-parameter\n * if you need to open a new standalone window and your configuration results in new tabs instead.\n *\n * For window options (in this implementation, we consider \"name\" to be an option as well), see:\n * https://developer.mozilla.org/en-US/docs/Web/API/Window/open#window_features\n *\n * Keep in mind to set \"noopener\" and/or \"noreferrer\" for external URLs in options, to improve security and privacy.\n * Hint for older MS browsers: if you set these security options, these will most likely open the URL in a popup\n * window. If you want to circumvent this, you'll have to drop the \"noreferrer\" and settle for \"noopener\", by\n * setting opener to null on the returned window like this: `openWindow('url').opener = null;`\n *\n * @param {String} url - the URL to load in the new window\n * @param {?Object} [options=null] - parameters for the new window according to the definitions of window.open & \"name\" for the window name\n * @param {?Window} [parentWindow=null] - parent window for the new window, current if not defined\n * @param {?Boolean} [tryAsPopup=false] - defines if it should be tried to force a real new window instead of a tab\n * @returns {Window} the newly opened window/tab\n *\n * @memberof Navigation:openWindow\n * @alias openWindow\n * @example\n * openWindow('/img/gallery.html');\n * openWindow('http://www.kittens.com', {name : 'kitten_popup'}, parent);\n */\nexport function openWindow(url, options=null, parentWindow=null, tryAsPopup=false){\n\turl = `${url}`;\n\toptions = isPlainObject(options) ? options : null;\n\tparentWindow = isA(parentWindow, 'window') ? parentWindow : window;\n\ttryAsPopup = orDefault(tryAsPopup, false, 'bool');\n\n\tlet\twindowName = '';\n\tconst optionArray = [];\n\n\tif( hasValue(options) ){\n\t\tfor( let prop in options ){\n\t\t\tif( prop === 'name' ){\n\t\t\t\twindowName = options[prop];\n\t\t\t}\n\n\t\t\tif( (prop !== 'name') || tryAsPopup ){\n\t\t\t\tif( [true, 1, 'yes'].includes(options[prop]) ){\n\t\t\t\t\toptionArray.push(`${prop}`);\n\t\t\t\t} else {\n\t\t\t\t\toptionArray.push(`${prop}=${options[prop]}`);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn parentWindow.open(url, windowName, optionArray.join(','));\n}\n\n\n\n/**\n * @namespace Navigation:reload\n */\n\n/**\n * Reloads the current window-location. Differentiates between cached and cache-refreshing reload.\n * Hint: the forcedReload param in window.location.reload is deprecated and not supported anymore in all browsers,\n * so, in order to do a cache busting reload we have to use a trick, by using a POST-reload, since POST never\n * gets cached. If, for some reason, you cannot POST to a URL, I also provided a second, less effective fallback,\n * using \"replace\".\n *\n * Hint: depending on your browser a cached reload may keep the current scrolling position in the document, while\n * the uncached variants won't\n *\n * @param {?Boolean} [cached=true] - should we use the cache on reload?\n * @param {?Boolean} [postUsable=true] - if set to false, we try to replace URL instead of POSTing to it\n *\n * @memberof Navigation:reload\n * @alias reload\n * @example\n * // with cache\n * reload();\n * // without cache via POST\n * reload(false);\n * // without cache via \"replace\"\n * reload(false, false);\n */\nexport function reload(cached=true, postUsable=true){\n\tcached = orDefault(cached, true, 'bool');\n\tpostUsable = orDefault(postUsable, true, 'bool');\n\n\tif( !cached && postUsable ){\n\t\tconst form = document.createElement('form');\n\t\tform.method = 'post';\n\t\tform.action = window.location.href;\n\t\tdocument.body.appendChild(form);\n\t\tform.submit();\n\t\tdocument.body.removeChild(form);\n\t} else if( !cached && !postUsable ){\n\t\twindow.location.replace(window.location.href);\n\t} else {\n\t\twindow.location.reload();\n\t}\n}\n\n\n\n/**\n * @namespace Navigation:changeCurrentUrl\n */\n\n/**\n * Changes the current URL by using the history API (this means, we can only change to a path on the same origin).\n * Be aware that this replaces the current URL in the history _without_ any normal navigation or reload.\n * This method only works if the history API is supported by the browser, otherwise no navigation will occur\n * (but a warning will be shown in console).\n * For more details on the history API see:\n * https://developer.mozilla.org/en-US/docs/Web/API/History\n *\n * @param {String} url - an absolute or relative url to change the current address to on the same origin\n * @param {?Boolean} [usePushState=false] - push new state instead of replacing current\n * @param {?*} [state=null] - a serializable object to append to the history state (gets retrieved on popState-event)\n * @param {?String} [title=null] - a name/title for the new state (as of yet, only Safari uses this, other browser will return undefined)\n * @throws error if state is not serializable by browser\n *\n * @memberof Navigation:changeCurrentUrl\n * @alias changeCurrentUrl\n * @see onHistoryChange\n * @example\n * changeCurrentUrl('/article/important-stuff', false, {id : 666});\n */\nexport function changeCurrentUrl(url, usePushState=false, state=null, title=null){\n\turl = orDefault(url, '', 'str');\n\tusePushState = orDefault(usePushState, false, 'bool');\n\ttitle = orDefault(title, '', 'str');\n\n\tif ( browserSupportsHistoryManipulation() ) {\n\t\tif( usePushState ){\n\t\t\twindow.history.pushState(state, title, url);\n\t\t} else {\n\t\t\twindow.history.replaceState(state, title, url);\n\t\t}\n\n\t\tHISTORY.current = {\n\t\t\tstate,\n\t\t\ttitle,\n\t\t\thost : window.location.host,\n\t\t\tpath : window.location.pathname\n\t\t};\n\t} else {\n\t\twarn(`${MODULE_NAME}:changeCurrentUrl | this browser does not support history api, skipping`);\n\t}\n}\n\n\n\n/**\n * @namespace Navigation:bindHistoryChange\n */\n\n/**\n * Registers an onpopstate event if history API is available (does nothing and warns if not available).\n * Takes a callback, which is provided with states as plain objects like: {state, title, host, path}.\n * Hint: do not rely on title, since that property may only be supported by browsers like Safari,\n * serialize everything important into state and use title as orientation only.\n *\n * In case of a regular binding all callbacks get the current state, so the state that is being changed to, but\n * if you set \"usePreviousState\" to true and prior navigation was done with \"changeCurrentUrl\", all callbacks\n * get two states: \"from\" and \"to\". With this you can define rules an behaviour depending on the state you are\n * coming from. Keep in mind: this only works if you use \"changeCurrentUrl\" for navigation in tandem with this method.\n *\n * @param {Function} callback - function to execute on popstate\n * @param {?Boolean} [clearOld=false] - defines if old handlers should be removed before setting new one\n * @param {?Boolean} [usePreviousState=false] - defines if callbacks should be provided with previous state as well (in that case, changeCurrentUrl must have been used for prior navigation)\n * @throws error if callback is no function\n *\n * @memberof Navigation:bindHistoryChange\n * @alias bindHistoryChange\n * @see changeCurrentUrl\n * @see unbindHistoryChange\n * @example\n * bindHistoryChange(function(){ alert('Hey, don\\'t do this!'); }, true);\n */\nexport function bindHistoryChange(callback, clearOld=false, usePreviousState=false){\n\tclearOld = orDefault(clearOld, false, 'bool');\n\tusePreviousState = orDefault(usePreviousState, false, 'bool');\n\n\tassert(isA(callback, 'function'), `${MODULE_NAME}:bindHistoryChange | callback is no function`);\n\n\tif ( browserSupportsHistoryManipulation() ) {\n\t\tif( clearOld ){\n\t\t\tHISTORY.popState.callbacks = [];\n\t\t}\n\n\t\tconst statefulCallback = function(e, historyNew){\n\t\t\tif( usePreviousState ){\n\t\t\t\tcallback(HISTORY.current, historyNew);\n\t\t\t} else {\n\t\t\t\tcallback(historyNew);\n\t\t\t}\n\t\t};\n\n\t\tHISTORY.popState.callbacks.push({\n\t\t\toriginal : callback,\n\t\t\tstateful : statefulCallback\n\t\t});\n\n\t\tif( !HISTORY.popState.listening ){\n\t\t\tHISTORY.popState.listening = true;\n\n\t\t\twindow.addEventListener('popstate',\tHISTORY.popState.handler);\n\t\t}\n\t} else {\n\t\twarn(`${MODULE_NAME}:bindHistoryChange | this browser does not support history api, skipping`);\n\t}\n}\n\n\n\n/**\n * @namespace Navigation:unbindHistoryChange\n */\n\n/**\n * Removes registered history change handlers, that have been created with \"bindHistoryChange\".\n * If a callback is provided, that callback is removed from callbacks, if the function is called\n * without parameters all callbacks are removed and the event listener for the callbacks is removed.\n *\n * @param {?Function} [callback=true] - reference to the callback to be removed, if missing all callbacks are removed\n * @throws error if callback is no function\n * @return {Boolean} true if callback(s) are/were removed, false if nothing was done\n *\n * @memberof Navigation:unbindHistoryChange\n * @alias unbindHistoryChange\n * @see changeCurrentUrl\n * @see bindHistoryChange\n * @example\n * unbindHistoryChange(thatOneCallback);\n * unbindHistoryChange();\n */\nexport function unbindHistoryChange(callback=null){\n\tif( hasValue(callback) ){\n\t\tassert(isA(callback, 'function'), `${MODULE_NAME}:unbindHistoryChange | callback is no function`);\n\n\t\tconst oldCallbackCount = HISTORY.popState.callbacks.length;\n\t\tHISTORY.popState.callbacks = HISTORY.popState.callbacks.reduce((cbs, cb) => {\n\t\t\tif( cb.original !== callback ){\n\t\t\t\tcbs.push(cb);\n\t\t\t}\n\n\t\t\treturn cbs;\n\t\t}, []);\n\t\tconst newCallbackCount = HISTORY.popState.callbacks.length;\n\n\t\tif( newCallbackCount === 0 ){\n\t\t\twindow.removeEventListener('popstate', HISTORY.popState.handler);\n\t\t\tHISTORY.popState.listening = false;\n\t\t}\n\n\t\treturn oldCallbackCount > newCallbackCount;\n\t} else {\n\t\tHISTORY.popState.callbacks = [];\n\t\twindow.removeEventListener('popstate', HISTORY.popState.handler);\n\t\tHISTORY.popState.listening = false;\n\n\t\treturn true;\n\t}\n}\n"]}
{"version":3,"sources":["basic.js"],"names":["MODULE_NAME","log","warn","assert","condition","message","orDefault","Error","attempt","closure","isA","ex","hasValue","res","Array","from","arguments","forEach","value","isEmpty","emptyValues","undefined","obj","__additionalEmptyValues__","concat","Set","includes","length","Object","keys","size","hasMembers","memberNames","verbose","memberName","info","expression","defaultValue","caster","additionalEmptyValues","toLowerCase","parseInt","parseFloat","getType","deepType","prototype","toString","call","slice","test","match","type","isInt","intVal","isFloat","floatVal","isPlainObject","constructor","isNaN","checkForIdentity","minMax","min","max","Deferred","[object Object]","STATUS_FULFILLED","STATUS_REJECTED","this","resolve","reject","status","isSettled","promise","Promise","resolution","rejection","f","then","catch","finally","Observable","initialValue","subscriptions","newValue","force","oldValue","isNewValue","s","subscription","indexOf","filter"],"mappings":"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","file":"basic.js","sourcesContent":["/*!\n * Module Basic\n */\n\n/**\n * @namespace Basic\n */\n\nconst MODULE_NAME = 'Basic';\n\n\n\nimport {log, warn} from './logging.js';\n\n\n\n/**\n * @namespace Basic:assert\n */\n\n/**\n * Classical assert method. If condition is falsy, throw assert exception.\n *\n * @param {Boolean} condition - defines if an assertion is successful\n * @param {?String} [message='assert exception: assertion failed'] - to display if assertion fails\n * @throws assert exception\n *\n * @memberof Basic:assert\n * @alias assert\n * @example\n * function set(name, value){\n *   assert(name.length > 0);\n *   assert(isPlainObject(value), 'error: value must be plain object');\n *   ...\n * }\n */\nexport function assert(condition, message){\n\tif( !condition ){\n\t\tmessage = orDefault(message, 'assert exception: assertion failed', 'str');\n\t\tthrow new Error(message);\n\t}\n}\n\n\n\n/**\n * @namespace Basic:attempt\n */\n\n/**\n * Attempt to compute contents of closure and catch all occurring exceptions.\n * The boolean result tells you if the operation was successful or not.\n *\n * This is most helpful, when used to test value conversions or other atomic/singluar operations, where it\n * just is important if something isolated works or not.\n *\n * Do not encapsulate complex code in the closure and mind recursively occurring exceptions!\n *\n * @param {Function} closure - the code to test\n * @throws error is closure is not a function\n * @returns {Boolean} true if no exception occurred\n *\n * @memberof Basic:attempt\n * @alias attempt\n * @example\n * if( !attempt(function(){ foobar(); }) ){ console.log('foobar cannot be executed!'); }\n */\nexport function attempt(closure){\n\tassert(isA(closure, 'function'), `${MODULE_NAME}:attempt | closure is no function`);\n\n\ttry {\n\t\tclosure();\n\t} catch(ex){\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n\n\n/**\n * @namespace Basic:hasValue\n */\n\n/**\n * Check if variable(s) is set, by being neither undefined nor null.\n *\n * @param {...*} [...] - add any number of variables you wish to check\n * @returns {Boolean} variable(s) is/are set\n *\n * @memberof Basic:hasValue\n * @alias hasValue\n * @example\n * function set(name, value){\n *   if( hasValue(name, value) ){\n *     ...\n *   }\n * }\n */\nexport function hasValue(){\n\tlet res = true;\n\n\tArray.from(arguments).forEach(value => {\n\t\tres = res && ((value !== undefined) && (value !== null));\n\t});\n\n\treturn res;\n}\n\n\n\n/**\n * @namespace Basic:isEmpty\n */\n\n/**\n * Check if variable(s) contain non-empty value\n * (not undefined, null, '', 0, [], {} or an empty Set/Map).\n *\n * You can supply additional non-empty values by providing an object having the key \"__additionalEmptyValues__\" as\n * any single parameter. Multiple occurrences will be merged.\n *\n * @param {...*} [...] - add any number of variables you wish to check\n * @returns {Boolean} variable(s) is/are non-empty\n *\n * @memberof Basic:isEmpty\n * @alias isEmpty\n * @example\n * function set(name, value){\n *   if( isEmpty(fooBar) || isEmpty({'__additionalEmptyValues__' : [false, '0']}, someArray, someSet, someString, value) ){\n *     ...\n *   }\n * }\n */\nexport function isEmpty(){\n\tlet\n\t\tres = true,\n\t\temptyValues = [undefined, null, '', 0]\n\t;\n\n\tArray.from(arguments).forEach(obj => {\n\t\tif( isA(obj?.__additionalEmptyValues__, 'array') ){\n\t\t\temptyValues = emptyValues.concat(obj.__additionalEmptyValues__);\n\t\t}\n\t});\n\temptyValues = Array.from(new Set(emptyValues));\n\n\tArray.from(arguments).forEach(obj => {\n\t\tif( res && !isA(obj?.__additionalEmptyValues__, 'array') ){\n\t\t\tres = emptyValues.includes(obj);\n\n\t\t\tif( !res ){\n\t\t\t\tif( isA(obj, 'array') ){\n\t\t\t\t\tres = (obj.length === 0);\n\t\t\t\t} else if( isA(obj, 'object') ){\n\t\t\t\t\tres = Object.keys(obj).length === 0;\n\t\t\t\t} else if( isA(obj, 'set') || isA(obj, 'map') ){\n\t\t\t\t\tres = (obj.size === 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\treturn res;\n}\n\n\n\n/**\n * @namespace Basic:hasMembers\n */\n\n/**\n * \"Validates\" an object in a very basic way by checking if all given members are present and are not nullish.\n *\n * @param {Object} obj - the object to check\n * @param {String[]} memberNames - the names of the members to check\n * @param {Boolean} [verbose=false] - defines if method should output missing members to console\n * @returns {Boolean} all memberNames present and not nullish\n *\n * @memberof Basic:hasMembers\n * @alias hasMembers\n * @example\n * function pat(kitten){\n *   if( hasMembers(kitten, ['fluff', 'meow', 'scratch']) ){\n *     ...\n *   }\n * }\n */\nexport function hasMembers(obj, memberNames, verbose=false){\n\tmemberNames = orDefault(memberNames, [], 'arr');\n\tverbose = orDefault(verbose, false, 'bool');\n\n\tlet res = true;\n\n\tmemberNames.forEach(memberName => {\n\t\tif( !hasValue(obj[`${memberName}`]) ){\n\t\t\tif( verbose ){\n\t\t\t\tlog().info(`${MODULE_NAME}:hasMembers | missing member ${memberName}`);\n\t\t\t}\n\n\t\t\tres = false;\n\t\t}\n\t});\n\n\treturn res;\n}\n\n\n\n/**\n * @namespace Basic:orDefault\n */\n\n/**\n * If an expression returns a non-value (undefined or null), use the default value instead.\n * Define a caster name, to force expression result/value into certain data type.\n *\n * @param {*} expression - the expression to evaluate\n * @param {*} defaultValue - the default value to use if the expression is considered empty\n * @param {?(String|Function)} [caster=null] - either a default caster by name ('str', 'string', 'int', 'integer', 'bool', 'boolean', 'float', 'arr', 'array') or a function getting the value and returning the transformed value\n * @param {?Array} [additionalEmptyValues=null] - if set, provides a list of additional values to be considered empty, apart from undefined and null\n * @returns {*} expression of defaultValue\n *\n * @memberof Basic:orDefault\n * @alias orDefault\n * @example\n * function set(name, value){\n *   name = orDefault(name, 'kittens!', 'string', ['', 'none']);\n *   value = orDefault(value, 42, 'int');\n * }\n */\nexport function orDefault(expression, defaultValue, caster=null, additionalEmptyValues=null){\n\tif( hasValue(additionalEmptyValues) ){\n\t\tadditionalEmptyValues = [].concat(additionalEmptyValues);\n\t} else {\n\t\tadditionalEmptyValues = [];\n\t}\n\n\tif( hasValue(caster) ){\n\t\tif(\n\t\t\t!isA(caster, 'function')\n\t\t\t&& ([\n\t\t\t\t'str', 'string',\n\t\t\t\t'int', 'integer',\n\t\t\t\t'bool', 'boolean',\n\t\t\t\t'float',\n\t\t\t\t'arr', 'array'\n\t\t\t].includes(`${caster.toLowerCase()}`))\n\t\t){\n\t\t\tcaster = `${caster}`.toLowerCase();\n\n\t\t\tif( ['str', 'string'].includes(caster) ){\n\t\t\t\tcaster = function(value){ return `${value}`; };\n\t\t\t} else if( ['int', 'integer'].includes(caster) ){\n\t\t\t\tcaster = function(value){ return parseInt(value, 10); };\n\t\t\t} else if( ['bool', 'boolean'].includes(caster) ){\n\t\t\t\tcaster = function(value){ return !!value; };\n\t\t\t} else if( caster === 'float' ){\n\t\t\t\tcaster = function(value){ return parseFloat(value); };\n\t\t\t} else if( ['arr', 'array'].includes(caster) ){\n\t\t\t\tcaster = function(value){ return [].concat(value); };\n\t\t\t}\n\t\t} else if( !isA(caster, 'function') ){\n\t\t\tcaster = function(value){ return value; };\n\t\t}\n\t} else {\n\t\tcaster = function(value){ return value; };\n\t}\n\n\tif( !hasValue(expression) || (additionalEmptyValues.includes(expression)) ){\n\t\treturn defaultValue;\n\t} else {\n\t\treturn caster(expression);\n\t}\n}\n\n\n\n/**\n * @namespace Basic:getType\n */\n\n/**\n * Prod-ready type detection for values, expanding on flawed typeof functionality, roughly following\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof, but expanding on\n * useful frontend types like \"htmldocument\", \"htmlelement\" and \"nodelist\"\n *\n * Types:\n * - \"undefined\"\n * - \"null\"\n * - \"boolean\"\n * - \"number\"\n * - \"bigint\"\n * - \"string\"\n * - \"symbol\"\n * - \"function\"\n * - \"object\"\n * - \"array\"\n * - \"date\"\n * - \"error\"\n * - \"generator\"\n * - \"regexp\"\n * - \"set\"\n * - \"weakset\"\n * - \"map\"\n * - \"weakmap\"\n * - \"htmldocument\"\n * - \"htmlelement\"\n * - \"nodelist\"\n * - \"window\"\n *\n * @param {*} [value] - variable to check the type of\n * @returns {String} the value type in lower case\n *\n * @memberof Basic:getType\n * @alias getType\n * @example\n * if( getType(cb) === 'function' ){\n *     ...\n * }\n */\nexport function getType(value) {\n\tif( !hasValue(value) ) return `${value}`.toLowerCase();\n\n\tconst deepType = Object.prototype.toString.call(value).slice(8,-1).toLowerCase();\n\n\tif( deepType === 'generatorfunction' ) return 'function';\n\tif( deepType === 'document' ) return 'htmldocument';\n\tif( deepType === 'element' ) return 'htmlelement';\n\tif( /^html.*element$/.test(deepType) ) return 'htmlelement';\n\n\treturn deepType.match(/^(array|bigint|date|error|function|generator|regexp|symbol|set|weakset|map|weakmap|htmldocument|nodelist|window)$/)\n\t\t? deepType\n\t\t: ((typeof value === 'object') || (typeof value === 'function')) ? 'object' : typeof value\n\t;\n}\n\n\n\n/**\n * @namespace Basic:isA\n */\n\n/**\n * Short form of \"getType\"-method with a more compact syntax.\n * Can identify all types listed in getType.\n *\n * @param {*} value - variable to check the type of\n * @param {String} type - the name of the type to check for, has to be a standard JS-type, is case insensitive\n * @returns {Boolean} target has type\n *\n * @memberof Basic:isA\n * @alias isA\n * @see getType\n * @example\n * let stringBool = (isA(test, 'boolean') && test) ? 'true' : 'false';\n */\nexport function isA(value, type){\n\tif(\n\t\t[\n\t\t\t'undefined',\n\t\t\t'null',\n\t\t\t'boolean',\n\t\t\t'number',\n\t\t\t'bigint',\n\t\t\t'string',\n\t\t\t'symbol',\n\t\t\t'function',\n\t\t\t'object',\n\t\t\t'array',\n\t\t\t'date',\n\t\t\t'error',\n\t\t\t'generator',\n\t\t\t'regexp',\n\t\t\t'set',\n\t\t\t'weakset',\n\t\t\t'map',\n\t\t\t'weakmap',\n\t\t\t'htmldocument',\n\t\t\t'htmlelement',\n\t\t\t'nodelist',\n\t\t\t'window'\n\t\t].includes(`${type}`.toLowerCase())\n\t){\n\t\treturn getType(value) === `${type}`.toLowerCase();\n\t} else {\n\t\twarn(`${MODULE_NAME}:isA | \"${type}\" is not a recognized type`);\n\t\treturn false;\n\t}\n}\n\n\n\n/**\n * @namespace Basic:isInt\n */\n\n/**\n * Returns if a value is truly a real integer value and not just an int-parsable value for example.\n * Since JS only knows the data type \"number\" all numbers are usable as floats by default, but not the\n * other way round.\n *\n * @param {*} intVal - the value the check\n * @returns {Boolean} true if intVal is a true integer value\n *\n * @memberof Basic:isInt\n * @alias isInt\n * @example\n * if( !isInt(val) ){\n *   val = parseInt(val, 10);\n * }\n */\nexport function isInt(intVal){\n\treturn parseInt(intVal, 10) === intVal;\n}\n\n\n\n/**\n * @namespace Basic:isFloat\n */\n\n/**\n * Returns if a value is a numeric value, usable as a float number in any calculation.\n * Any number that fulfills isInt, is also considered a valid float, which lies in JS's\n * nature of not differentiating ints and floats by putting them both into a \"number\"-type.\n * So ints are always floats, but not necessarily the other way round.\n *\n * @param {*} floatVal - the value to check\n * @returns {Boolean} true if floatVal is usable in a float context\n *\n * @memberof Basic:isFloat\n * @alias isFloat\n * @example\n * if( !isFloat(val) ){\n *   alert('val can not be calculated with!');\n * }\n */\nexport function isFloat(floatVal){\n\treturn parseFloat(floatVal) === floatVal;\n}\n\n\n\n/**\n * @namespace Basic:isPlainObject\n */\n\n/**\n * Returns if a value is an object literal, so so-called \"plain object.\n * A plain object is something like \"{hello : 'world'}\".\n *\n * This might especially be helpful when dealing with JSON configs, so quickly check if\n * something might even be parsed JSON (which in most cases is a plain object in js).\n *\n * Be aware that this function cannot differentiate between constructor-based simple objects and\n * plain objects declared inline. So, if someone took on the work to instantiate a base object and assign\n * properties either in a function or a constructor, we accept that as a plain object.\n *\n * @param {*} value - the value to check\n * @returns {Boolean} true if value seems to be a plain object\n *\n * @memberof Basic:isPlainObject\n * @alias isPlainObject\n * @example\n * const isParameterConfigObject = isPlainObject(param);\n */\nexport function isPlainObject(value){\n\treturn isA(value, 'object')\n\t\t&& hasValue(value)\n\t\t&& (value.constructor === Object)\n\t\t&& Object.prototype.toString.call(value) === '[object Object]'\n\t;\n}\n\n\n\n/**\n * @namespace Basic:isNaN\n */\n\n/**\n * Returns if an expression is NaN or not.\n * This method employs two different approaches:\n * By default it really checks if the expression is the _value_ NaN or not, this being a valid JS-value for something.\n * In JS this gets checked by comparing an expression with itself on identity, since NaN is the only value not being\n * identical to itself. If you set checkForIdentity to false, this method will use the standard JS-isNaN, which\n * inspects the expression, tries to cast or parse a number from it and returns the result.\n *\n * @param {*} expression - the expression to check\n * @param {Boolean} [checkForIdentity=true] - set to false if you want to use default JS-functionality\n * @returns {Boolean} true if expression is NaN\n *\n * @memberof Basic:isNaN\n * @alias isNaN\n * @example\n * if( !isNaN(suspiciousCalculatedValue) ){\n *   return suspiciousCalculatedValue * 3;\n * }\n */\nexport function isNaN(expression, checkForIdentity=true){\n\tcheckForIdentity = orDefault(checkForIdentity, true, 'bool');\n\n\tif( checkForIdentity ){\n\t\treturn expression !== expression;\n\t} else {\n\t\treturn isNaN(expression);\n\t}\n}\n\n\n\n/**\n * @namespace Basic:minMax\n */\n\n/**\n * Checks if a value is within bounds of a minimum and maximum and returns\n * the value or the upper or lower bound respectively.\n *\n * Accepts all values comparable with > and <.\n *\n * @param {*} min - the lower bound\n * @param {*} value - the value to check\n * @param {*} max - the upper bound\n * @throws error if min is not smaller than max\n * @returns {*} value, min or max\n *\n * @memberof Basic:minMax\n * @alias minMax\n * @example\n * let croppedVal = minMax(-100, value, 100);\n */\nexport function minMax(min, value, max){\n\tassert(min <= max, `${MODULE_NAME}:minMax | min can not be larger than max`);\n\n\treturn (value < min)\n\t\t? min\n\t\t: (\n\t\t\t(value > max)\n\t\t\t\t? max\n\t\t\t\t: value\n\t\t)\n\t;\n}\n\n\n\n/**\n * @namespace Basic:Deferred\n */\n\n/**\n * Class that wraps a Promise, to allow resolving and rejecting outside the\n * Promise's function scope. This allows for decoupled handling of states and\n * handling promises as references in a distributed context, like a class, where\n * a Deferred might then represent an async state.\n *\n * Deferreds also provide accessible status information, normal Promises do not have.\n * Accessing the \"status\" property returns the current status, being either \"pending\",\n * \"fulfilled\" or \"rejected\". You may also check if the Deferred has been settled via\n * \"isSettled()\".\n *\n * This follows ideas by jQuery and Q Promises:\n * - https://api.jquery.com/jQuery.Deferred/\n * - https://github.com/kriskowal/q/wiki/Coming-from-jQuery#deferreds-promises-resolvers\n *\n * Keep in mind, that Promises might need a polyfill such as core-js.\n *\n * @memberof Basic:Deferred\n * @name Deferred\n * @example\n * const doStuff = new Deferred();\n * doStuff\n *   .then(value => { alert(`yeah, ready with \"${value}\"!`); })\n *   .catch(error => { console.error(error); })\n *   .finally(() => { console.info('has been settled); })\n * ;\n * if( foobar === 42 ){\n *   doStuff.resolve(42);\n * } else {\n *   doStuff.reject(new Error('not 42!'));\n * }\n * console.info(doStuff.status);\n */\nexport class Deferred {\n\tconstructor(){\n\t\tconst\n\t\t\tSTATUS_PENDING = 'pending',\n\t\t\tSTATUS_FULFILLED = 'fulfilled',\n\t\t\tSTATUS_REJECTED = 'rejected'\n\t\t;\n\t\tthis.resolve = null;\n\t\tthis.reject = null;\n\t\tthis.status = STATUS_PENDING;\n\t\tthis.isSettled = () => [STATUS_FULFILLED, STATUS_REJECTED].includes(this.status);\n\t\tthis.promise = new Promise((resolve, reject) => {\n\t\t\tthis.resolve = resolution => {\n\t\t\t\tthis.status = STATUS_FULFILLED;\n\t\t\t\tresolve(resolution);\n\t\t\t};\n\t\t\tthis.reject = rejection => {\n\t\t\t\tthis.status = STATUS_REJECTED;\n\t\t\t\treject(rejection);\n\t\t\t};\n\t\t});\n\t}\n\n\tthen(f){\n\t\treturn this.promise.then(f);\n\t}\n\n\tcatch(f){\n\t\treturn this.promise.catch(f);\n\t}\n\n\tfinally(f){\n\t\treturn this.promise.finally(f);\n\t}\n}\n\n\n\n/**\n * @namespace Basic:Observable\n */\n\n/**\n * A class offering the bare minimum feature set to observe a value and subscribe to future value changes.\n * No automatic magic going on here, this simply follows a basic subscription pattern, where each subscription is\n * a function, being called with a newly set value. This closely resembles the kind of observables knockout is using.\n *\n * @memberof Basic:Observable\n * @name Observable\n * @example\n * const status = new Observable('ok');\n * const subscription = status.subscribe(s => {\n *     console.log(`status changed to: ${s}`);\n * });\n * status.setValue('oh noez');\n * status.unsubscribe(subscription);\n */\nexport class Observable {\n\tconstructor(initialValue){\n\t\tthis.value = initialValue;\n\t\tthis.subscriptions = [];\n\t}\n\n\tgetValue(){\n\t\treturn this.value;\n\t}\n\n\tsetValue(newValue, force=false){\n\t\tconst\n\t\t\toldValue = this.value,\n\t\t\tisNewValue = oldValue !== newValue\n\t\t;\n\t\tthis.value = newValue;\n\t\tif( isNewValue || force ){\n\t\t\tthis.subscriptions.forEach(s => s(newValue, oldValue));\n\t\t}\n\t}\n\n\tsubscribe(subscription){\n\t\tassert(isA(subscription, 'function'), `${MODULE_NAME}:Observable.subscribe | subscription must be function`);\n\t\tif( this.subscriptions.indexOf(subscription) < 0 ){\n\t\t\tthis.subscriptions = [...this.subscriptions, subscription];\n\t\t}\n\t\treturn subscription;\n\t}\n\n\tunsubscribe(subscription){\n\t\tthis.subscriptions = this.subscriptions.filter(s => s !== subscription);\n\t}\n}\n"]}
{"version":3,"sources":["timers.js"],"names":["MODULE_NAME","orDefault","isA","assert","hasValue","hasMembers","schedule","ms","callback","oldTimer","countermand","id","window","setTimeout","type","pschedule","precise","waitStart","Date","getTime","waitMilliSecs","fAdjustWait","reschedule","timer","loop","oldLoop","setInterval","ploop","isInterval","clearInterval","clearTimeout","requestAnimationFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","msRequestAnimationFrame","raf","cancelAnimationFrame","caf","mozCancelAnimationFrame","waitForRepaint","ids","outer","inner"],"mappings":"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","file":"timers.js","sourcesContent":["/*!\n * Module Timers\n */\n\n/**\n * @namespace Timers\n */\n\nconst MODULE_NAME = 'Timers';\n\n\n\nimport {orDefault, isA, assert, hasValue, hasMembers} from './basic.js';\n\n\n\n/**\n * @namespace Timers:schedule\n */\n\n/**\n * Setup a timer for one-time execution of a callback, kills old timer if given\n * to prevent overlapping timers.\n *\n * @param {Number} ms - time in milliseconds until execution\n * @param {Function} callback - callback function to execute after ms\n * @param {?(Object|Number)} [oldTimer] - if set, kills the timer before setting up new one\n * @throws error if callback is not a function\n * @returns {Object} new timer\n *\n * @memberof Timers:schedule\n * @alias schedule\n * @see pschedule\n * @see countermand\n * @example\n * const timer = schedule(1000, function(){ alert('time for tea'); });\n * const timer = schedule(2000, function(){ alert('traffic jam, tea has to wait'); }, timer);\n */\nexport function schedule(ms, callback, oldTimer){\n\tms = orDefault(ms, 1, 'int');\n\n\tassert(isA(callback, 'function'), `${MODULE_NAME}:schedule | callback must be a function`);\n\n\tif( hasValue(oldTimer) ){\n\t\tcountermand(oldTimer);\n\t}\n\n\treturn {id : window.setTimeout(callback, ms), type : 'timeout'};\n}\n\n\n\n/**\n * @namespace Timers:pschedule\n */\n\n/**\n * Setup a timer for one-time execution of a callback, kills old timer if given\n * to prevent overlapping timers.\n * This implementation uses Date.getTime() to improve on timer precision for long\n * running timers. The timers of this method can also be used in countermand().\n *\n * Warning: these timers are more precise than normal timer for _long_ time spans and less precise for short ones,\n * if you are dealing with times at least above 30s (or minutes and hours) this the right choice, if you look to\n * use precise timers in the second and millisecond range, definitely use schedule/loop instead!\n *\n * @param {Number} ms - time in milliseconds until execution\n * @param {Function} callback - callback function to execute after ms\n * @param {?(Object|Number)} [oldTimer] - if set, kills the timer before setting up new one\n * @throws error if callback is not a function\n * @returns {Object} timer (does not create new timer object if oldTimer given, but returns old one)\n *\n * @memberof Timers:pschedule\n * @alias pschedule\n * @see schedule\n * @see countermand\n * @example\n * const timer = pschedule(1000, function(){ alert('time for tea'); });\n * const timer = pschedule(2000, function(){ alert('traffic jam, tea has to wait'); }, timer);\n */\nexport function pschedule(ms, callback, oldTimer){\n\tms = orDefault(ms, 1, 'int');\n\n\tassert(isA(callback, 'function'), `${MODULE_NAME}:pschedule | callback must be a function`);\n\n\tif(\n\t\thasValue(oldTimer)\n\t\t&& hasMembers(oldTimer, ['id', 'type'])\n\t){\n\t\tcountermand(oldTimer);\n\t\toldTimer.precise = true;\n\t} else {\n\t\toldTimer = {id : -1, type : 'timeout', precise : true};\n\t}\n\n\tconst waitStart = new Date().getTime();\n\tlet waitMilliSecs = ms;\n\n\tconst fAdjustWait = function(){\n\t\tif( waitMilliSecs > 0 ){\n\t\t\twaitMilliSecs -= (new Date().getTime() - waitStart);\n\t\t\toldTimer.id = window.setTimeout(fAdjustWait, (waitMilliSecs > 10) ? waitMilliSecs : 10);\n\t\t} else {\n\t\t\tcallback();\n\t\t}\n\t};\n\n\toldTimer.id = window.setTimeout(fAdjustWait, waitMilliSecs);\n\n\treturn oldTimer;\n}\n\n\n\n/**\n * @namespace Timers:reschedule\n */\n\n/**\n * Alias for schedule() with more natural param-order for rescheduling.\n *\n * @param {(Object|Number)} timer - the timer to refresh/reset\n * @param {Number} ms - time in milliseconds until execution\n * @param {Function} callback - callback function to execute after ms\n * @throws error if callback is not a function\n * @returns {Object} timer (may be the original timer, if given timer is precise from pschedule or ploop)\n *\n * @memberof Timers:reschedule\n * @alias reschedule\n * @see schedule\n * @example\n * const timer = reschedule(timer, 3000, function(){ alert('taking even more time'); });\n */\nexport function reschedule(timer, ms, callback){\n\tms = orDefault(ms, 1, 'int');\n\n\tassert(isA(callback, 'function'), `${MODULE_NAME}:reschedule | callback must be a function`);\n\n\tif( hasValue(timer) && hasValue(timer.precise) && !!timer.precise ){\n\t\treturn pschedule(ms, callback, timer);\n\t} else {\n\t\treturn schedule(ms, callback, timer);\n\t}\n}\n\n\n\n/**\n * @namespace Timers:loop\n */\n\n/**\n * Setup a loop for repeated execution of a callback, kills old loop if wished\n * to prevent overlapping loops.\n *\n * @param {Number} ms - time in milliseconds until execution\n * @param {Function} callback - callback function to execute after ms\n * @param {?(Object|Number)} [oldLoop] - if set, kills the loop before setting up new one\n * @throws error if callback is not a function\n * @returns {Object} new loop\n *\n * @memberof Timers:loop\n * @alias loop\n * @see ploop\n * @see countermand\n * @example\n * const loop = loop(250, function(){ document.body.classList.add('brightred'); });\n * const loop = loop(100, function(){ document.body.classList.add('brightgreen'); }, loop);\n */\nexport function loop(ms, callback, oldLoop){\n\tms = orDefault(ms, 1, 'int');\n\n\tassert(isA(callback, 'function'), `${MODULE_NAME}:loop | callback must be a function`);\n\n\tif( hasValue(oldLoop) ){\n\t\tcountermand(oldLoop, true);\n\t}\n\n\treturn {id : window.setInterval(callback, ms), type : 'interval'};\n}\n\n\n\n/**\n * @namespace Timers:ploop\n */\n\n/**\n * Setup a loop for repeated execution of a callback, kills old loop if wished\n * to prevent overlapping loops.\n * This implementation uses Date.getTime() to improve on timer precision for long running loops.\n *\n * Warning: these timers are more precise than normal timer for _long_ time spans and less precise for short ones,\n * if you are dealing with times at least above 30s (or minutes and hours) this the right choice, if you look to\n * use precise timers in the second and millisecond range, definitely use schedule/loop instead!\n *\n * The loops of this method can also be used in countermand().\n * This method does not actually use intervals internally but timeouts,\n * so don't wonder if you can't find the ids in JS.\n *\n * @param {Number} ms - time in milliseconds until execution\n * @param {Function} callback - callback function to execute after ms\n * @param {?(Object|Number)} [oldLoop] - if set, kills the loop before setting up new one\n * @throws error if callback is not a function\n * @returns {Object} loop (if you give an old loop into the function the same reference will be returned)\n *\n * @memberof Timers:ploop\n * @alias ploop\n * @see loop\n * @see countermand\n * @example\n * const loop = ploop(250, function(){ document.body.classList.add('brightred'); });\n * const loop = ploop(100, function(){ document.body.classList.add('brightgreen'); }, loop);\n */\nexport function ploop(ms, callback, oldLoop){\n\tms = orDefault(ms, 1, 'int');\n\n\tassert(isA(callback, 'function'), `${MODULE_NAME}:ploop | callback must be a function`);\n\n\tif(\n\t\thasValue(oldLoop)\n\t\t&& hasMembers(oldLoop, ['id', 'type'])\n\t){\n\t\tcountermand(oldLoop, true);\n\t\toldLoop.precise = true;\n\t} else {\n\t\toldLoop = {id : -1, type : 'interval', precise : true};\n\t}\n\n\tlet\n\t\twaitStart = new Date().getTime(),\n\t\twaitMilliSecs = ms\n\t;\n\n\tconst fAdjustWait = function(){\n\t\tif( waitMilliSecs > 0 ){\n\t\t\twaitMilliSecs -= (new Date().getTime() - waitStart);\n\t\t\toldLoop.id = window.setTimeout(fAdjustWait, (waitMilliSecs > 10) ? waitMilliSecs : 10);\n\t\t} else {\n\t\t\tcallback();\n\t\t\twaitStart = new Date().getTime();\n\t\t\twaitMilliSecs = ms;\n\t\t\toldLoop.id = window.setTimeout(fAdjustWait, waitMilliSecs);\n\t\t}\n\t};\n\n\toldLoop.id = window.setTimeout(fAdjustWait, waitMilliSecs);\n\n\treturn oldLoop;\n}\n\n\n\n/**\n * @namespace Timers:countermand\n */\n\n/**\n * Cancel a timer or loop immediately.\n *\n * @param {(Object|Number)} timer - the timer or loop to end\n * @param {?Boolean} [isInterval] - defines if a timer or a loop is to be stopped, set in case timer is a GUID\n *\n * @memberof Timers:countermand\n * @alias countermand\n * @see schedule\n * @see pschedule\n * @see loop\n * @see ploop\n * @example\n * countermand(timer);\n * countermand(loop);\n */\nexport function countermand(timer, isInterval){\n\tif( hasValue(timer) ){\n\t\tif( hasMembers(timer, ['id', 'type']) ){\n\t\t\tif( timer.type === 'interval' ){\n\t\t\t\twindow.clearInterval(timer.id);\n\t\t\t} else {\n\t\t\t\twindow.clearTimeout(timer.id);\n\t\t\t}\n\t\t} else {\n\t\t\tif( !hasValue(isInterval) || !isInterval ){\n\t\t\t\twindow.clearTimeout(timer);\n\t\t\t} else {\n\t\t\t\twindow.clearInterval(timer);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n\n/**\n * @namespace Timers:requestAnimationFrame\n */\n\n/**\n * This is a simple streamlined, vendor-cascading version of window.requestAnimationFrame with a timeout fallback in\n * case the functionality is missing from the browser.\n *\n * @param {Function} callback - the code to execute once the browser has assigned an execution slot for it\n * @return {Number} either the id of the requestAnimationFrame or the internal timeout, both are cancellable via cancelAnimationFrame\n *\n * @memberof Timers:requestAnimationFrame\n * @alias requestAnimationFrame\n * @see raf\n * @see cancelAnimationFrame\n * @see caf\n * @example\n * const requestId = requestAnimationFrame(function(){ window.body.style.opacity = 0; });\n */\nexport function requestAnimationFrame(callback){\n\tconst raf = window.requestAnimationFrame\n\t\t?? window.webkitRequestAnimationFrame\n\t\t?? window.mozRequestAnimationFrame\n\t\t?? window.msRequestAnimationFrame\n\t\t?? function(callback){ return schedule(16, callback); }\n\t;\n\n\treturn raf(callback);\n}\n\n\n\n/**\n * @namespace Timers:raf\n */\n\n/**\n * This is just an alternate name for requestAnimationFrame.\n *\n * @param {Function} callback - the code to execute once the browser has assigned an execution slot for it\n * @return {Number} either the id of the requestAnimationFrame or the internal timeout, both are cancellable via cancelAnimationFrame\n *\n * @memberof Timers:raf\n * @alias raf\n * @see requestAnimationFrame\n * @see cancelAnimationFrame\n * @see caf\n * @example\n * const requestId = raf(function(){ window.body.style.opacity = 0; });\n */\nexport function raf(callback){\n\treturn requestAnimationFrame(callback);\n}\n\n\n\n/**\n * @namespace Timers:cancelAnimationFrame\n */\n\n/**\n * This is a simple streamlined, vendor-cascading version of window.cancelAnimationFrame.\n *\n * @param {Number} id - either the id of the requestAnimationFrame or its timeout fallback\n *\n * @memberof Timers:cancelAnimationFrame\n * @alias cancelAnimationFrame\n * @see requestAnimationFrame\n * @see raf\n * @see caf\n * @example\n * cancelAnimationFrame(requestAnimationFrame(function(){ window.body.style.opacity = 0; }));\n */\nexport function cancelAnimationFrame(id){\n\tconst raf = window.requestAnimationFrame\n\t\t?? window.webkitRequestAnimationFrame\n\t\t?? window.mozRequestAnimationFrame\n\t\t?? window.msRequestAnimationFrame\n\t;\n\n\tlet caf = window.cancelAnimationFrame\n\t\t?? window.mozCancelAnimationFrame\n\t;\n\n\tif( !hasValue(raf) ){\n\t\tcaf = countermand;\n\t}\n\n\treturn caf(id);\n}\n\n\n\n/**\n * @namespace Timers:caf\n */\n\n/**\n * This is just an alternate name for cancelAnimationFrame.\n *\n * @param {Number} id - either the id of the requestAnimationFrame or its timeout fallback\n *\n * @memberof Timers:caf\n * @alias caf\n * @see requestAnimationFrame\n * @see raf\n * @see cancelAnimationFrame\n * @example\n * caf(raf(function(){ window.body.style.opacity = 0; }));\n */\nexport function caf(id){\n\treturn cancelAnimationFrame(id);\n}\n\n\n\n/**\n * @namespace Timers:waitForRepaint\n */\n\n/**\n * This function has the purpose to offer a safe execution slot for code depending on an up-to-date rendering state of\n * the DOM after a change to styles for example. Let's say you add a class to an element and right in the next line\n * you'll want to read a layout attribute like width or height from it. This might fail, because there is no guarantee\n * the browser actually already applied the new styles to be read from the DOM.\n *\n * To wait safely for the new DOM state this method works with two stacked requestAnimationFrame calls.\n *\n * Since requestAnimationFrame always happens _before_ a repaint, two stacked calls ensure, that there has to be a\n * repaint between them.\n *\n * @param {Function} callback - the code to execute once the browser performed a repaint\n * @return {Object} dictionary of ids for the inner and outer request ids, outer gets assigned right away, while inner gets assigned after first callback => {outer : 1, inner : 2}\n *\n * @memberof Timers:waitForRepaint\n * @alias waitForRepaint\n * @see requestAnimationFrame\n * @see raf\n * @example\n * element.classList.add('special-stuff');\n * waitForRepaint(function(){ alert(`the new dimensions after class change are: ${element.offsetWidth}x${element.offsetHeight}`); });\n */\nexport function waitForRepaint(callback){\n\tconst ids = {};\n\n\tids.outer = requestAnimationFrame(function(){\n\t\tids.inner = requestAnimationFrame(callback);\n\t});\n\n\treturn ids;\n}\n"]}
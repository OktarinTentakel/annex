{"version":3,"file":"timers.js","names":["MODULE_NAME","orDefault","isFunction","assert","hasValue","hasMembers","schedule","ms","callback","oldTimer","countermand","id","window","setTimeout","type","pschedule","precise","waitStart","Date","now","waitMilliSecs","fAdjustWait","reschedule","timer","loop","oldLoop","setInterval","ploop","isInterval","clearInterval","clearTimeout","requestAnimationFrame","raf","webkitRequestAnimationFrame","mozRequestAnimationFrame","msRequestAnimationFrame","cancelAnimationFrame","caf","mozCancelAnimationFrame","waitForRepaint","ids","outer","inner"],"sources":["timers.js"],"mappings":"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","ignoreList":[],"sourcesContent":["/*!\n * Module Timers\n */\n\n/**\n * @namespace Timers\n */\n\nconst MODULE_NAME = 'Timers';\n\n\n\n//###[ IMPORTS ]########################################################################################################\n\nimport {orDefault, isFunction, assert, hasValue, hasMembers} from './basic.js';\n\n\n\n//###[ EXPORTS ]########################################################################################################\n\n/**\n * @namespace Timers:schedule\n */\n\n/**\n * Setup a timer for one-time execution of a callback, kills old timer if given\n * to prevent overlapping timers.\n *\n * @param {Number} ms - time in milliseconds until execution\n * @param {Function} callback - callback function to execute after ms\n * @param {?(Object|Number)} [oldTimer=null] - if set, kills the timer before setting up new one\n * @throws error if ms is negative or callback is not a function\n * @returns {Object} new timer\n *\n * @memberof Timers:schedule\n * @alias schedule\n * @see pschedule\n * @see countermand\n * @example\n * const timer = schedule(1000, function(){ alert('time for tea'); });\n * const timer = schedule(2000, function(){ alert('traffic jam, tea has to wait'); }, timer);\n */\nexport function schedule(ms, callback, oldTimer=null){\n\tms = orDefault(ms, 1, 'int');\n\n\tassert(ms >= 0, `${MODULE_NAME}:schedule | ms must be positive`);\n\tassert(isFunction(callback), `${MODULE_NAME}:schedule | callback must be a function`);\n\n\tif( hasValue(oldTimer) ){\n\t\tcountermand(oldTimer);\n\t}\n\n\treturn {id : window.setTimeout(callback, ms), type : 'timeout'};\n}\n\n\n\n/**\n * @namespace Timers:pschedule\n */\n\n/**\n * Setup a timer for one-time execution of a callback, kills old timer if given\n * to prevent overlapping timers.\n * This implementation uses Date.now()/Date.getTime() to improve on timer precision for long\n * running timers. The timers of this method can also be used in countermand().\n *\n * Warning: these timers are more precise than normal timer for _long_ time spans and less precise for short ones,\n * if you are dealing with times at least above 30s (or minutes and hours) this the right choice, if you look to\n * use precise timers in the second and millisecond range, definitely use schedule/loop instead!\n *\n * @param {Number} ms - time in milliseconds until execution\n * @param {Function} callback - callback function to execute after ms\n * @param {?(Object|Number)} [oldTimer=null] - if set, kills the timer before setting up new one\n * @throws error if ms is not positive or if callback is not a function\n * @returns {Object} timer (does not create new timer object if oldTimer given, but returns old one)\n *\n * @memberof Timers:pschedule\n * @alias pschedule\n * @see schedule\n * @see countermand\n * @example\n * const timer = pschedule(1000, function(){ alert('time for tea'); });\n * const timer = pschedule(2000, function(){ alert('traffic jam, tea has to wait'); }, timer);\n */\nexport function pschedule(ms, callback, oldTimer=null){\n\tms = orDefault(ms, 1, 'int');\n\n\tassert(ms >= 0, `${MODULE_NAME}:pschedule | ms must be positive`);\n\tassert(isFunction(callback), `${MODULE_NAME}:pschedule | callback must be a function`);\n\n\tif(\n\t\thasValue(oldTimer)\n\t\t&& hasMembers(oldTimer, ['id', 'type'])\n\t){\n\t\tcountermand(oldTimer);\n\t\toldTimer.precise = true;\n\t} else {\n\t\toldTimer = {id : -1, type : 'timeout', precise : true};\n\t}\n\n\tconst waitStart = Date.now();\n\tlet waitMilliSecs = ms;\n\n\tconst fAdjustWait = function(){\n\t\tif( waitMilliSecs > 0 ){\n\t\t\twaitMilliSecs -= (Date.now() - waitStart);\n\t\t\toldTimer.id = window.setTimeout(fAdjustWait, (waitMilliSecs > 10) ? waitMilliSecs : 10);\n\t\t} else {\n\t\t\tcallback();\n\t\t}\n\t};\n\n\toldTimer.id = window.setTimeout(fAdjustWait, waitMilliSecs);\n\n\treturn oldTimer;\n}\n\n\n\n/**\n * @namespace Timers:reschedule\n */\n\n/**\n * Alias for schedule() with more natural param-order for rescheduling.\n *\n * @param {(Object|Number)} timer - the timer to refresh/reset\n * @param {Number} ms - time in milliseconds until execution\n * @param {Function} callback - callback function to execute after ms\n * @throws error if ms is not positive or if callback is not a function\n * @returns {Object} timer (may be the original timer, if given timer is precise from pschedule or ploop)\n *\n * @memberof Timers:reschedule\n * @alias reschedule\n * @see schedule\n * @example\n * const timer = reschedule(timer, 3000, function(){ alert('taking even more time'); });\n */\nexport function reschedule(timer, ms, callback){\n\tms = orDefault(ms, 1, 'int');\n\n\tassert(ms >= 0, `${MODULE_NAME}:reschedule | ms must be positive`);\n\tassert(isFunction(callback), `${MODULE_NAME}:reschedule | callback must be a function`);\n\n\tif( hasValue(timer) && hasValue(timer.precise) && !!timer.precise ){\n\t\treturn pschedule(ms, callback, timer);\n\t} else {\n\t\treturn schedule(ms, callback, timer);\n\t}\n}\n\n\n\n/**\n * @namespace Timers:loop\n */\n\n/**\n * Setup a loop for repeated execution of a callback, kills old loop if wished\n * to prevent overlapping loops.\n *\n * @param {Number} ms - time in milliseconds until execution\n * @param {Function} callback - callback function to execute after ms\n * @param {?(Object|Number)} [oldLoop=null] - if set, kills the loop before setting up new one\n * @throws error if ms is not positive or if callback is not a function\n * @returns {Object} new loop\n *\n * @memberof Timers:loop\n * @alias loop\n * @see ploop\n * @see countermand\n * @example\n * const loop = loop(250, function(){ document.body.classList.add('brightred'); });\n * const loop = loop(100, function(){ document.body.classList.add('brightgreen'); }, loop);\n */\nexport function loop(ms, callback, oldLoop=null){\n\tms = orDefault(ms, 1, 'int');\n\n\tassert(ms >= 0, `${MODULE_NAME}:loop | ms must be positive`);\n\tassert(isFunction(callback), `${MODULE_NAME}:loop | callback must be a function`);\n\n\tif( hasValue(oldLoop) ){\n\t\tcountermand(oldLoop, true);\n\t}\n\n\treturn {id : window.setInterval(callback, ms), type : 'interval'};\n}\n\n\n\n/**\n * @namespace Timers:ploop\n */\n\n/**\n * Setup a loop for repeated execution of a callback, kills old loop if wished\n * to prevent overlapping loops.\n * This implementation uses Date.now()/Date.getTime() to improve on timer precision for long running loops.\n *\n * Warning: these timers are more precise than normal timer for _long_ time spans and less precise for short ones,\n * if you are dealing with times at least above 30s (or minutes and hours) this the right choice, if you look to\n * use precise timers in the second and millisecond range, definitely use schedule/loop instead!\n *\n * The loops of this method can also be used in countermand().\n * This method does not actually use intervals internally but timeouts,\n * so don't wonder if you can't find the ids in JS.\n *\n * @param {Number} ms - time in milliseconds until execution\n * @param {Function} callback - callback function to execute after ms\n * @param {?(Object|Number)} [oldLoop=null] - if set, kills the loop before setting up new one\n * @throws error if ms is not positive or if callback is not a function\n * @returns {Object} loop (if you give an old loop into the function the same reference will be returned)\n *\n * @memberof Timers:ploop\n * @alias ploop\n * @see loop\n * @see countermand\n * @example\n * const loop = ploop(250, function(){ document.body.classList.add('brightred'); });\n * const loop = ploop(100, function(){ document.body.classList.add('brightgreen'); }, loop);\n */\nexport function ploop(ms, callback, oldLoop=null){\n\tms = orDefault(ms, 1, 'int');\n\n\tassert(ms >= 0, `${MODULE_NAME}:ploop | ms must be positive`);\n\tassert(isFunction(callback), `${MODULE_NAME}:ploop | callback must be a function`);\n\n\tif(\n\t\thasValue(oldLoop)\n\t\t&& hasMembers(oldLoop, ['id', 'type'])\n\t){\n\t\tcountermand(oldLoop, true);\n\t\toldLoop.precise = true;\n\t} else {\n\t\toldLoop = {id : -1, type : 'interval', precise : true};\n\t}\n\n\tlet\n\t\twaitStart = Date.now(),\n\t\twaitMilliSecs = ms\n\t;\n\n\tconst fAdjustWait = function(){\n\t\tif( waitMilliSecs > 0 ){\n\t\t\twaitMilliSecs -= (Date.now() - waitStart);\n\t\t\toldLoop.id = window.setTimeout(fAdjustWait, (waitMilliSecs > 10) ? waitMilliSecs : 10);\n\t\t} else {\n\t\t\tcallback();\n\t\t\twaitStart = Date.now();\n\t\t\twaitMilliSecs = ms;\n\t\t\toldLoop.id = window.setTimeout(fAdjustWait, waitMilliSecs);\n\t\t}\n\t};\n\n\toldLoop.id = window.setTimeout(fAdjustWait, waitMilliSecs);\n\n\treturn oldLoop;\n}\n\n\n\n/**\n * @namespace Timers:countermand\n */\n\n/**\n * Cancel a timer or loop immediately.\n *\n * @param {(Object|Number)} timer - the timer or loop to end\n * @param {?Boolean} [isInterval=false] - defines if a timer or a loop is to be stopped, set in case timer is a GUID\n *\n * @memberof Timers:countermand\n * @alias countermand\n * @see schedule\n * @see pschedule\n * @see loop\n * @see ploop\n * @example\n * countermand(timer);\n * countermand(loop);\n */\nexport function countermand(timer, isInterval=false){\n\tisInterval = orDefault(isInterval, false, 'bool');\n\n\tif( hasValue(timer) ){\n\t\tif( hasMembers(timer, ['id', 'type']) ){\n\t\t\tif( timer.type === 'interval' ){\n\t\t\t\twindow.clearInterval(timer.id);\n\t\t\t} else {\n\t\t\t\twindow.clearTimeout(timer.id);\n\t\t\t}\n\t\t} else {\n\t\t\tif( !isInterval ){\n\t\t\t\twindow.clearTimeout(timer);\n\t\t\t} else {\n\t\t\t\twindow.clearInterval(timer);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n\n/**\n * @namespace Timers:requestAnimationFrame\n */\n\n/**\n * This is a simple streamlined, vendor-cascading version of window.requestAnimationFrame with a timeout fallback in\n * case the functionality is missing from the browser.\n *\n * @param {Function} callback - the code to execute once the browser has assigned an execution slot for it\n * @throws error if callback is not a function\n * @return {Number} either the id of the requestAnimationFrame or the internal timeout, both are cancellable via cancelAnimationFrame\n *\n * @memberof Timers:requestAnimationFrame\n * @alias requestAnimationFrame\n * @see raf\n * @see cancelAnimationFrame\n * @see caf\n * @example\n * const requestId = requestAnimationFrame(function(){ window.body.style.opacity = 0; });\n */\nexport function requestAnimationFrame(callback){\n\tassert(isFunction(callback), `${MODULE_NAME}:requestAnimationFrame | callback is no function`);\n\n\tconst raf = window.requestAnimationFrame\n\t\t?? window.webkitRequestAnimationFrame\n\t\t?? window.mozRequestAnimationFrame\n\t\t?? window.msRequestAnimationFrame\n\t\t?? function(callback){ return schedule(16, callback); }\n\t;\n\n\treturn raf(callback);\n}\n\n\n\n/**\n * @namespace Timers:cancelAnimationFrame\n */\n\n/**\n * This is a simple streamlined, vendor-cascading version of window.cancelAnimationFrame.\n *\n * @param {Number} id - either the id of the requestAnimationFrame or its timeout fallback\n *\n * @memberof Timers:cancelAnimationFrame\n * @alias cancelAnimationFrame\n * @see requestAnimationFrame\n * @see raf\n * @see caf\n * @example\n * cancelAnimationFrame(requestAnimationFrame(function(){ window.body.style.opacity = 0; }));\n */\nexport function cancelAnimationFrame(id){\n\tconst raf = window.requestAnimationFrame\n\t\t?? window.webkitRequestAnimationFrame\n\t\t?? window.mozRequestAnimationFrame\n\t\t?? window.msRequestAnimationFrame\n\t;\n\n\tlet caf = window.cancelAnimationFrame\n\t\t?? window.mozCancelAnimationFrame\n\t;\n\n\tif( !hasValue(raf) ){\n\t\tcaf = countermand;\n\t}\n\n\treturn caf(id);\n}\n\n\n\n/**\n * @namespace Timers:waitForRepaint\n */\n\n/**\n * This function has the purpose to offer a safe execution slot for code depending on an up-to-date rendering state of\n * the DOM after a change to styles for example. Let's say you add a class to an element and right in the next line\n * you'll want to read a layout attribute like width or height from it. This might fail, because there is no guarantee\n * the browser actually already applied the new styles to be read from the DOM.\n *\n * To wait safely for the new DOM state this method works with two stacked requestAnimationFrame calls.\n *\n * Since requestAnimationFrame always happens _before_ a repaint, two stacked calls ensure, that there has to be a\n * repaint between them.\n *\n * @param {Function} callback - the code to execute once the browser performed a repaint\n * @throws error if callback is not a function\n * @return {Object} dictionary of ids for the inner and outer request ids, outer gets assigned right away, while inner gets assigned after first callback => {outer : 1, inner : 2}\n *\n * @memberof Timers:waitForRepaint\n * @alias waitForRepaint\n * @see requestAnimationFrame\n * @see raf\n * @example\n * element.classList.add('special-stuff');\n * waitForRepaint(function(){ alert(`the new dimensions after class change are: ${element.offsetWidth}x${element.offsetHeight}`); });\n */\nexport function waitForRepaint(callback){\n\tassert(isFunction(callback), `${MODULE_NAME}:waitForRepaint | callback is no function`);\n\n\tconst ids = {};\n\n\tids.outer = requestAnimationFrame(function(){\n\t\tids.inner = requestAnimationFrame(callback);\n\t});\n\n\treturn ids;\n}\n"]}
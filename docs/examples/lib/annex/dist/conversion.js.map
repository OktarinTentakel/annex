{"version":3,"file":"conversion.js","names":["MODULE_NAME","isInt","isArray","orDefault","pad","trim","UPPER_CHARS","LOWER_CHARS","NUMBERS","BASE_ALPHABETS","slice","BASE64_ALPHABET","buildAlphabet","__methodName__","baseOrAlphabet","useChunks","alphabet","Error","baseAlphabetKey","Object","keys","sort","Number","split","forEach","char","concat","Array","from","Set","a","b","aBase64Index","indexOf","bBase64Index","join","length","calculateNeededPages","base","availablePages","Math","floor","neededPages","charPoolSize","combinations","buildPageMap","pageMap","remainder","quotient","i","ceil","push","buildCharMap","pagedAlphabet","min","pagedBase","charMap","stringToBase64","value","btoa","String","fromCodePoint","TextEncoder","encode","replaceAll","base64ToString","res","TextDecoder","decode","Uint8Array","atob","codePointAt","ex","base10toBaseX","baseXValue","baseXToBase10","reverse","base10Value","pow","toBaseX","useCharacterMap","chunkSize","valueIsNumber","valueIsNegativeNumber","abs","includes","base64Value","chunks","chunkAlphabet","chunkSeparator","chunkStart","chunk","decodedValue","fromBaseX","startsWith","endsWith","inverseCharMap","fromEntries","entries","map","key","tokensByLength","tokenFound","token"],"sources":["conversion.js"],"mappings":"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","sourcesContent":["/*!\n * Module Conversion\n */\n\n/**\n * @namespace Conversion\n */\n\nconst MODULE_NAME = 'Conversion';\n\n\n\n//###[ IMPORTS ]########################################################################################################\n\nimport {isInt, isArray, orDefault} from './basic.js';\nimport {pad, trim} from './strings.js';\n\n\n\n//###[ DATA ]###########################################################################################################\n\nconst\n\tUPPER_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ',\n\tLOWER_CHARS = 'abcdefghijklmnopqrstuvwxyz',\n\tNUMBERS = '0123456789',\n\tBASE_ALPHABETS = {\n\t\t'64' : `${UPPER_CHARS}${LOWER_CHARS}${NUMBERS}+/`,\n\t\t'63' : `${NUMBERS}${UPPER_CHARS}${LOWER_CHARS}_`,\n\t\t'36' : `${NUMBERS}${UPPER_CHARS}`,\n\t\t'26' : UPPER_CHARS,\n\t\t'16' : `${NUMBERS}${UPPER_CHARS.slice(0, 6)}`,\n\t\t'10' : NUMBERS,\n\t\t'8' : NUMBERS.slice(0, 8),\n\t\t'2' : NUMBERS.slice(0, 2)\n\t},\n\tBASE64_ALPHABET = BASE_ALPHABETS['64']\n;\n\n\n\n//###[ HELPERS ]########################################################################################################\n\n/**\n * Builds an alphabet string, based on an integer, an alphabet string or an array of strings containing the alphabet's\n * chars. An integer uses BASE_ALPHABETS to select a base alphabet to slice the alphabet from. The first base alphabet\n * having enough chars is going be used. The configurations of the base alphabets are according to current base\n * practices.\n *\n * Characters in custom alphabets are sorted according to base64 definition, with additional chars appended at the end,\n * sorted ascending based on char value.\n *\n * @private\n */\nfunction buildAlphabet(__methodName__='buildAlphabet', baseOrAlphabet=64, useChunks=false){\n\tbaseOrAlphabet = orDefault(baseOrAlphabet, 64);\n\n\tlet alphabet;\n\n\tif( isInt(baseOrAlphabet) ){\n\t\tif( (baseOrAlphabet < 2) || (baseOrAlphabet > 64) ){\n\t\t\tthrow new Error(`${MODULE_NAME}:${__methodName__} | base not usable, smaller than 2 or larger than 64`);\n\t\t}\n\n\t\tif( useChunks && (baseOrAlphabet < 3) ){\n\t\t\tthrow new Error(`${MODULE_NAME}:${__methodName__} | base not usable for chunks, smaller than 3`);\n\t\t}\n\n\t\tfor( let baseAlphabetKey of Object.keys(BASE_ALPHABETS).sort() ){\n\t\t\tif( Number(baseAlphabetKey) >= baseOrAlphabet ){\n\t\t\t\talphabet = BASE_ALPHABETS[baseAlphabetKey].slice(0, baseOrAlphabet);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\talphabet = [];\n\n\t\tif( !isArray(baseOrAlphabet) ){\n\t\t\tbaseOrAlphabet = `${baseOrAlphabet}`.split('');\n\t\t}\n\n\t\tbaseOrAlphabet.forEach(char => {\n\t\t\talphabet = alphabet.concat(`${char}`.split(''));\n\t\t});\n\n\t\talphabet = Array.from(new Set(alphabet));\n\t\talphabet.sort((a, b) => {\n\t\t\tconst\n\t\t\t\taBase64Index = BASE64_ALPHABET.indexOf(a),\n\t\t\t\tbBase64Index = BASE64_ALPHABET.indexOf(b)\n\t\t\t;\n\n\t\t\tif( (aBase64Index < 0) && (bBase64Index < 0) ){\n\t\t\t\treturn (a === b) ? 0 : ((a < b) ? -1 : 1);\n\t\t\t} else if( aBase64Index < 0 ){\n\t\t\t\treturn 1;\n\t\t\t} else if( bBase64Index < 0 ){\n\t\t\t\treturn -1;\n\t\t\t} else {\n\t\t\t\treturn (aBase64Index === bBase64Index) ? 0 : ((aBase64Index < bBase64Index) ? -1 : 1);\n\t\t\t}\n\t\t});\n\n\t\talphabet = alphabet.join('');\n\t}\n\n\tif( (alphabet.length < 2) || (alphabet.length > 64) ){\n\t\tthrow new Error(`${MODULE_NAME}:${__methodName__} | alphabet not usable, must have between two and 64 chars`);\n\t}\n\n\tif( useChunks && (alphabet.length < 3) ){\n\t\tthrow new Error(`${MODULE_NAME}:${__methodName__} | alphabet not usable for chunks, less than 3 chars`);\n\t}\n\n\treturn alphabet;\n}\n\n\n\n/**\n * Calculates how many character mapping pages/page characters we need for a specific alphabet,\n * defined by its length/base.\n *\n * @private\n */\nfunction calculateNeededPages(base){\n\tconst availablePages = Math.floor(base / 2);\n\tlet\n\t\tneededPages = 0,\n\t\tcharPoolSize = base,\n\t\tcombinations = charPoolSize\n\t;\n\n\twhile( combinations < 64 ){\n\t\tneededPages++;\n\t\tif( neededPages <= availablePages ){\n\t\t\tcharPoolSize--;\n\t\t}\n\t\tcombinations = (neededPages + 1) * charPoolSize;\n\t}\n\n\treturn neededPages;\n}\n\n\n\n/**\n * Returns an array of value prefixes used to map characters to different code pages, in cases where we need to encode\n * a base64 character above the base of our target alphabet, which means, that we have to repeat character usage, but\n * with a page prefix to multiply the value set by reducing the base alphabet for that purpose.\n *\n * @private\n */\nfunction buildPageMap(alphabet){\n\tconst\n\t\tbase = alphabet.length,\n\t\tneededPages = calculateNeededPages(base),\n\t\tavailablePages = Math.floor(base / 2),\n\t\tpageMap = ['']\n\t;\n\n\tlet remainder, quotient;\n\tfor( let i = 1; i <= neededPages; i++ ){\n\t\tremainder = i % availablePages;\n\t\tquotient = Math.ceil(i / availablePages);\n\t\tpageMap.push(pad('', alphabet[(remainder > 0) ? (remainder - 1) : (availablePages - 1)], quotient));\n\t}\n\n\treturn pageMap;\n}\n\n\n\n/**\n * Returns a dictionary, mapping each base64 character to one or more characters of the target alphabet.\n * In cases, where the character to encode is beyond the target alphabet, page prefixes are prepended to\n * cover all characters by increasing length.\n *\n * @private\n */\nfunction buildCharMap(pageMap, alphabet){\n\tconst\n\t\tbase = alphabet.length,\n\t\tneededPages = calculateNeededPages(base),\n\t\tavailablePages = Math.floor(base / 2),\n\t\tpagedAlphabet = alphabet.slice(Math.min(neededPages, availablePages)),\n\t\tpagedBase = pagedAlphabet.length,\n\t\tcharMap = {}\n\t;\n\n\tlet remainder, quotient;\n\tfor( let i in BASE64_ALPHABET.split('') ){\n\t\tremainder = i % pagedBase;\n\t\tquotient = Math.floor(i / pagedBase);\n\t\tcharMap[BASE64_ALPHABET[i]] = `${pageMap[quotient]}${pagedAlphabet[remainder]}`\n\t}\n\n\treturn charMap;\n}\n\n\n\n/**\n * Converts a string to base64, while handling unicode characters correctly.\n * Be advised, that the result needs to be decoded with base64ToString() again, since\n * we also need to correctly handle unicode on the way back.\n *\n * @private\n */\nfunction stringToBase64(value){\n\treturn btoa(String.fromCodePoint(...((new TextEncoder()).encode(`${value}`)))).replaceAll('=', '');\n}\n\n\n\n/**\n * Decodes a base64-encoded string to its original value.\n * Be advised, that the base64 value has to be encoded using stringToBase64(), since unicode characters need\n * special handling during en/decoding.\n *\n * This function will fail with an error, if the given value is not actually decodable with base64.\n *\n * @private\n */\nfunction base64ToString(value, __methodName__='base64ToString'){\n\tlet res = null;\n\n\ttry {\n\t\tres = (new TextDecoder()).decode(Uint8Array.from(atob(`${value}`), char => char.codePointAt(0)))\n\t} catch(ex){\n\t\tthrow new Error(`${MODULE_NAME}:${__methodName__} | cannot decode \"${value}\"`);\n\t}\n\n\treturn res;\n}\n\n\n\n/**\n * Converts a decimal/base10 value to a different base numerically.\n * Be aware that this needs the value to be a safe integer.\n * This function does not deal with negative numbers by itself.\n *\n * @private\n */\nfunction base10toBaseX(value, alphabet){\n\tconst base = alphabet.length;\n\tlet\n\t\tbaseXValue = '',\n\t\tquotient = value,\n\t\tremainder\n\t;\n\n\tif( quotient !== 0){\n\t\twhile( quotient !== 0 ){\n\t\t\tremainder = quotient % base;\n\t\t\tquotient = Math.floor(quotient / base);\n\t\t\tbaseXValue = `${alphabet[remainder]}${baseXValue}`;\n\t\t}\n\t} else {\n\t\tbaseXValue = `${alphabet[0]}`;\n\t}\n\n\treturn baseXValue;\n}\n\n\n\n/**\n * Converts a value, based on a defined alphabet, to its decimal/base10 representation.\n * Be aware that this needs the result to be a safe integer.\n * This function does not deal with negative numbers by itself.\n *\n * @private\n */\nfunction baseXToBase10(value, alphabet){\n\tvalue = `${value}`.split('').reverse().join('');\n\n\tconst base = alphabet.length;\n\tlet base10Value = 0;\n\n\tfor( let i = 0; i < value.length; i++ ){\n\t\tbase10Value += Math.pow(base, i) * alphabet.indexOf(value[i]);\n\t}\n\n\treturn base10Value;\n}\n\n\n\n//###[ EXPORTS ]########################################################################################################\n\n/**\n * @namespace Conversion:toBaseX\n */\n\n/**\n * This function converts a value to a representation in a defined base between 2 and 64.\n * So this covers common use cases like binary, octal, hexadecimal, alphabetical, alphanumeric and of course base64.\n *\n * The result of this function is always either a decimal number or a string, just as the input value. All numbers\n * apart from decimal ones are returned as strings without prefix. So, decimal 5 will be the number 5, but the binary\n * version will be the string \"101\". Positive and negative decimal integers are valid numbers here, but this\n * implementation does not support floats (multiply and divide if needed). Only numerical bases above 36 contain\n * lower case characters, so decimal 255 is \"FF\" in base 16 and not \"ff\".\n *\n * This function is unicode safe, by using byte conversion\n * (see: https://developer.mozilla.org/en-US/docs/Glossary/Base64#the_unicode_problem).\n * Be aware, that this also means, that results of `btoa/atob()` and `toBaseX/fromBaseX()` are _not_ interchangeable,\n * since they work with different values internally.\n *\n * There are three approaches to changing the base of a value in JavaScript:\n *\n * 1. Either you are taking the numerical/mathematical road, treating a value as a number in its alphabet being\n * interpreted as a number, where each character, counting from the back is the base to the power of the\n * character index. This is the approach you'd expect, when, for instance, you'd want to convert the decimal number 5\n * to binary 101. The downside of this approach is, that the relatively small max safe integer in JavaScript makes\n * converting large numbers, such as longer strings, impossible.\n *\n * 2. Therefore, the second approach takes the numeric approach, but combines it with chunking, splitting the value into\n * pieces, which are, by themselves, safely convertible. The downside is, that we need an extra character to delimit\n * chunks in the result, since values have non-uniform lengths. This means, that this does not work with the basic\n * binary base, and we need at least 3 alphabet characters.\n *\n * 3. The last approach uses the native base64 string encoding with `btoa()` as a safe translation layer, mapping the\n * resulting string to the target base, using a generated (and possibly paged) character map. This way treats all\n * values as strings and is not compatible to numerical conversion anymore, but uses the same characters. The result\n * of this approach can encode every string of every length without structural tricks, but has the longest results.\n *\n * This function is capable of all three approaches, which are equally safe for unicode values. The numerical\n * approach is the default. If you want to encode large numbers or strings longer than ~6 characters, select\n * a different approach using the `useCharacterMap` or `useChunks` parameters. Character mapping has preference, while\n * chunks have no effect in character mapping.\n *\n * Each encoding process ends with a self-test, checking if the result is actually decodable using\n * `fromBaseX()`, using the same settings again. This ensures, that every result is valid and retrievable in the future,\n * preventing any undiscovered errors, which would make it impossible to work with the original value again.\n *\n * You may define the base as an integer between 2 and 64 or as a custom alphabet in the same range. Integer based\n * alphabets are generated using defined base alphabets, which are sliced if necessary. Custom alphabets are\n * automatically sorted to match base64 are far as possible, pushing additional characters to the end, which are then\n * sorted ascending by character value.\n *\n * \"{\" and \"}\" are the only forbidden characters in a custom alphabet, since we need these to mark number values in\n * `fromBaseX()`.\n *\n * Numerical conversion keeps negative numbers negative and marks the result with a preceding \"-\".\n *\n * Hint: if you want to genrate codes to be presented to the user, see `Random:randomUserCode`.\n *\n * @param {Number|String} value - value to be encoded\n * @param {?Number|String|Array<String>} [baseOrAlphabet=64] - either the numerical base to convert to (64, 36, ...) or the alphabet of characters to use in encoding; numerical bases must be between 2 and 64 (if the result is chunked, we need a base 3)\n * @param {?Boolean} [useCharacterMap=true] - set to true, to use a character map, based on btoa(), instead of numerical conversion\n * @param {?Boolean} [useChunks=false] - set to true, to add chunking to the numerical approach, converting the value in groups separated by a delimiter, which is the first letter of the base's alphabet\n * @param {?Number} [chunkSize=6] - define a different chunks size; only change this, if 6 seems too big in your context, going higher is not advisable\n * @throws error if baseOrAlphabet is not usable\n * @throws error if result is not decodable again using the same settings\n * @returns {String} the encoded value\n *\n * @memberof Conversion:toBaseX\n * @alias toBaseX\n * @see fromBaseX\n * @see https://developer.mozilla.org/en-US/docs/Glossary/Base64#the_unicode_problem\n * @see Random:randomUserCode\n * @example\n * toBaseX('foobar')\n * => 'Zm9vYmFy'\n * toBaseX(-5, 2)\n * => '-101'\n * toBaseX(42, 'abcdefghij')\n * => 'ec'\n * toBaseX('too-long-for-number-conversion', 36, true)\n * => 'U70R0DCN0F0DS04T0BQ040R0GCN0N0JSNA03TZ0J01S0K0N0KQOA0HRN0R0C'\n * toBaseX('too-long-for-number-conversion', 16, false, true)\n * => 'D3EF5D81F026D9DFDA970BBF17222402A47D5AD650CF6C2FE2102A494BCBDD0A2864C'\n */\nexport function toBaseX(value, baseOrAlphabet=64, useCharacterMap=false, useChunks=false, chunkSize=6){\n\tconst __methodName__ = 'toBaseX';\n\n\tconst\n\t\tvalueIsNumber = isInt(value),\n\t\tvalueIsNegativeNumber = valueIsNumber && (value < 0)\n\t;\n\n\tvalue = valueIsNumber ? `${Math.abs(value)}` : `${value}`;\n\tuseCharacterMap = orDefault(useCharacterMap, false, 'bool');\n\tuseChunks = orDefault(useChunks, false, 'bool');\n\tchunkSize = orDefault(chunkSize, 10, 'int');\n\n\tconst alphabet = buildAlphabet(__methodName__, baseOrAlphabet, useChunks);\n\tif( alphabet.includes('{') || alphabet.includes('}') ){\n\t\tthrow new Error(`${MODULE_NAME}:${__methodName__} | invalid alphabet, must not contain \"{\" or \"}\"`)\n\t}\n\n\tlet\n\t\tbase64Value = '',\n\t\tbase10Value = 0,\n\t\tbaseXValue = ''\n\t;\n\n\tif( useCharacterMap ){\n\t\tbase64Value = stringToBase64(value);\n\t\tif( baseOrAlphabet === 64 ) return base64Value;\n\n\t\tconst\n\t\t\tpageMap = buildPageMap(alphabet),\n\t\t\tcharMap = buildCharMap(pageMap, alphabet)\n\t\t;\n\n\t\tfor( let char of base64Value ){\n\t\t\tbaseXValue += charMap[char];\n\t\t}\n\t} else {\n\t\tif( valueIsNumber ){\n\t\t\tbase64Value = base10toBaseX(value, BASE64_ALPHABET);\n\t\t} else {\n\t\t\tbase64Value = stringToBase64(value);\n\t\t}\n\n\t\tconst\n\t\t\tchunks = [],\n\t\t\tchunkAlphabet = useChunks ? alphabet.slice(1) : alphabet,\n\t\t\tchunkSeparator = useChunks ? alphabet[0] : ''\n\t\t;\n\n\t\tif( useChunks ){\n\t\t\tlet chunkStart = 0;\n\t\t\twhile( chunkStart < base64Value.length ){\n\t\t\t\tchunks.push(base64Value.slice(chunkStart, chunkStart + chunkSize));\n\t\t\t\tchunkStart += chunkSize;\n\t\t\t}\n\t\t} else {\n\t\t\tchunks.push(base64Value);\n\t\t}\n\n\t\tfor( let chunk of chunks ){\n\t\t\tbase10Value = baseXToBase10(chunk, BASE64_ALPHABET);\n\n\t\t\tif( !useChunks && (baseOrAlphabet === 10) ){\n\t\t\t\tbaseXValue += base10Value;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tbaseXValue += `${chunkSeparator}${base10toBaseX(base10Value, chunkAlphabet)}`;\n\t\t}\n\n\t\tif( chunkSeparator !== '' ){\n\t\t\tbaseXValue = baseXValue.slice(1);\n\t\t}\n\t}\n\n\tbaseXValue = `${valueIsNegativeNumber ? '-' : ''}${baseXValue}`;\n\tconst decodedValue = `${fromBaseX(baseXValue, baseOrAlphabet, useCharacterMap, useChunks, valueIsNumber)}`;\n\tif( decodedValue !== `${valueIsNegativeNumber ? '-' : ''}${value}` ){\n\t\tthrow new Error(\n\t\t\t`${MODULE_NAME}:${__methodName__} | critical error, encoded value \"${baseXValue}\" `\n\t\t\t+`not decodable to \"${value}\", is \"${decodedValue}\" instead; `\n\t\t\t+`if this looks \"cut off\", this may be a problem with JS max safe integer size `\n\t\t\t+`(safe value length for number-based conversion is just ~8 chars), `\n\t\t\t+`try using character mapping or chunks to circumvent this problem`\n\t\t);\n\t}\n\treturn baseXValue;\n}\n\n\n\n/**\n * @namespace Conversion:fromBaseX\n */\n\n/**\n * This function converts a based representation back to its original number or string value.\n * This is the mirror function to `toBaseX()` and expects a value encoded with that function. See that function\n * for implementation details, modes and restrictions.\n *\n * The result of this function is always either a decimal number or a string, just as the input value. All numbers\n * apart from decimal ones are returned as strings without prefix. So, decimal 5 will be the number 5, but the binary\n * version will be the string \"101\".\n *\n * You may define the base as an integer between 2 and 64 or as a custom alphabet in the same range. Integer based\n * alphabets are generated using defined base alphabets, which are sliced if necessary. Custom alphabets are\n * automatically sorted to match base64 are far as possible, pushing additional characters to the end, which are then\n * sorted ascending by character value.\n *\n * \"{\" and \"}\" are the only forbidden characters in a custom alphabet, since we need these to mark number values in\n * `fromBaseX()`.\n *\n * Numerical conversion keeps negative numbers negative and marks the result with a preceding \"-\".\n *\n * @param {Number|String} value - value to be decoded\n * @param {?Number|String|Array<String>} [baseOrAlphabet=64] - either the numerical base to convert to (64, 36, ...) or the alphabet of characters to use in encoding; numerical bases must be between 2 and 64 (if the result is chunked, we need a base 3)\n * @param {?Boolean} [useCharacterMap=true] - set to true, to use a character map, based on btoa(), instead of numerical conversion\n * @param {?Boolean} [useChunks=false] - set to true, to add chunking to the numerical approach, converting the value in groups separated by a delimiter, which is the first letter of the base's alphabet\n * @param {?Boolean} [valueIsNumber=false] - if true, the given value is treated as a number for numerical conversion; this is necessary, since numbers such as binaries are defined as strings and are therefore not auto-detectable\n * @throws error if baseOrAlphabet is not usable\n * @throws error character mapped decoding fails, due to missing token/unmatched alphabet\n * @returns {String} the decoded value\n *\n * @memberof Conversion:fromBaseX\n * @alias fromBaseX\n * @see toBaseX\n * @example\n * fromBaseX('Zm9vYmFy')\n * => 'foobar'\n * fromBaseX('16W33YPUS', 36)\n * => 'äす'\n * fromBaseX('{-3C3}', 13)\n * => -666\n * fromBaseX('q', 64, false, false, true)\n * => 42\n * fromBaseX('U70R0DCN0F0DS04T0BQ040R0GCN0N0JSNA03TZ0J01S0K0N0KQOA0HRN0R0C', 36, true)\n * => 'too-long-for-number-conversion'\n * fromBaseX('D3EF5D81F026D9DFDA970BBF17222402A47D5AD650CF6C2FE2102A494BCBDD0A2864C', 16, false, true)\n * => 'too-long-for-number-conversion'\n */\nexport function fromBaseX(value, baseOrAlphabet=64, useCharacterMap=false, useChunks=false, valueIsNumber=false){\n\tconst __methodName__ = 'fromBaseX';\n\n\tvalueIsNumber = !!valueIsNumber\n\t\t|| isInt(value)\n\t\t|| (`${value}`.startsWith('{') && `${value}`.endsWith('}'))\n\t;\n\tvalue = `${value}`;\n\tif( valueIsNumber ){\n\t\tvalue = trim(value, ['{', '}']);\n\t}\n\tconst valueIsNegativeNumber = valueIsNumber && value.startsWith('-');\n\tif( valueIsNegativeNumber ){\n\t\tvalue = value.slice(1);\n\t}\n\n\tuseCharacterMap = orDefault(useCharacterMap, false, 'bool');\n\tuseChunks = orDefault(useChunks, false, 'bool');\n\n\tif(\n\t\t(baseOrAlphabet === 64)\n\t\t&& !useCharacterMap\n\t\t&& !useChunks\n\t\t&& !valueIsNumber\n\t) return base64ToString(value, __methodName__);\n\n\tconst alphabet = buildAlphabet(__methodName__, baseOrAlphabet, useChunks);\n\tif( alphabet.includes('{') || alphabet.includes('}') ){\n\t\tthrow new Error(`${MODULE_NAME}:${__methodName__} | invalid alphabet, must not contain \"{\" or \"}\"`)\n\t}\n\n\tlet\n\t\tbase64Value = '',\n\t\tbase10Value = 0,\n\t\tdecodedValue\n\t;\n\n\tif( useCharacterMap ){\n\t\tconst\n\t\t\tpageMap = buildPageMap(alphabet),\n\t\t\tcharMap = buildCharMap(pageMap, alphabet),\n\t\t\tinverseCharMap = Object.fromEntries(\n\t\t\t\tObject\n\t\t\t\t.entries(charMap)\n\t\t\t\t.map(([key, value]) => [value, key])\n\t\t\t),\n\t\t\ttokensByLength = Object.keys(inverseCharMap).sort((a, b) => {\n\t\t\t\treturn (a.length === b.length) ? 0 : ((a.length > b.length) ? -1 : 1);\n\t\t\t})\n\t\t;\n\n\t\tlet tokenFound = false;\n\t\twhile( value !== '' ){\n\t\t\tfor( let token of tokensByLength ){\n\t\t\t\ttokenFound = false;\n\t\t\t\tif( value.startsWith(token) ){\n\t\t\t\t\ttokenFound = true;\n\t\t\t\t\tbase64Value += inverseCharMap[token];\n\t\t\t\t\tvalue = value.slice(token.length);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif( !tokenFound ){\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`${MODULE_NAME}:${__methodName__} | unknown token at start of \"${value}\", likely due to non-matching alphabet`\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tdecodedValue = base64ToString(base64Value, __methodName__);\n\t\tif( valueIsNegativeNumber ){\n\t\t\tdecodedValue = `-${decodedValue}`;\n\t\t}\n\n\t\treturn decodedValue;\n\t} else {\n\t\tdecodedValue = '';\n\n\t\tconst\n\t\t\tchunkAlphabet = useChunks ? alphabet.slice(1) : alphabet,\n\t\t\tchunkSeparator = useChunks ? alphabet[0] : '',\n\t\t\tchunks = useChunks ? value.split(chunkSeparator) : [value]\n\t\t;\n\n\t\tfor( let chunk of chunks ){\n\t\t\tbase10Value = baseXToBase10(chunk, chunkAlphabet);\n\n\t\t\tif( valueIsNumber ){\n\t\t\t\tdecodedValue += `${base10Value}`;\n\t\t\t} else {\n\t\t\t\tbase64Value += base10toBaseX(base10Value, BASE64_ALPHABET);\n\t\t\t}\n\t\t}\n\n\t\tif( decodedValue === '' ){\n\t\t\tdecodedValue = base64ToString(base64Value, __methodName__)\n\t\t\tif( valueIsNegativeNumber ){\n\t\t\t\tdecodedValue = `-${decodedValue}`;\n\t\t\t}\n\t\t}\n\n\t\tif( !useChunks && valueIsNumber ){\n\t\t\tdecodedValue = Number(decodedValue);\n\t\t\tif( valueIsNegativeNumber && (decodedValue >= 0) ){\n\t\t\t\tdecodedValue = -decodedValue;\n\t\t\t}\n\t\t}\n\n\t\treturn decodedValue;\n\t}\n}\n"]}
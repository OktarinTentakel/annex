{"version":3,"file":"events.js","names":["MODULE_NAME","assert","isFunction","isString","isArray","isBoolean","isObject","isWindow","isEventTarget","isPlainObject","isElement","orDefault","hasValue","isEmpty","isSelector","slugify","removeFrom","detectInteractionType","warn","EVENT_MAP","Map","POST_MESSAGE_MAP","DEFAULT_NAMESPACE","SWIPE_DIRECTIONS","SWIPE_HANDLERS","WeakMap","SWIPE_TOUCH","startX","startY","endX","endY","EVENT_OPTION_SUPPORT","capture","once","passive","signal","options","window","addEventListener","removeEventListener","err","prepareEventMethodBaseParams","methodName","targets","events","handler","handlerIsOptional","length","targetsAreEventTargets","delegatedTargetsAreSelectorsAndHaveAncestor","forEach","target","targetIndex","ancestor","map","event","replace","replaceAll","prepareEventMethodAdditionalTargetInfo","prevTarget","nextTarget","hasDelegation","isDelegation","prepareEventMethodEventInfo","eventName","defaultNamespace","defaultEvent","eventParts","split","namespace","gatherTargetEvents","delegation","targetEvents","get","gatheredTargetEvents","nameSpaceScope","delegations","Set","add","Object","keys","ns","ev","cleanUpEventMap","concat","desertedTargets","has","targetNamespace","targetEvent","targetScope","handlerCount","handlers","delegationHandlerCount","push","desertedTarget","delete","createDelegatedHandler","e","delegationSelector","matches","syntheticTarget","createHandlerRemover","ignoreInvalidScope","__methodName__","handlerScope","removedHandlers","filter","existingHandler","removedHandler","action","createSelfRemovingHandler","removeLocatedHandler","delegationScope","removeHandlers","removedCount","Array","from","removeDelegatedHandlers","pauseLocatedHandlers","paused","pausedHandlers","pausedHandler","pauseHandlers","pausedCount","pauseDelegatedHandlers","createPauseAwareAction","managedHandler","nonPauseAwareAction","compileEventListenerOptions","supportedOptions","option","createSyntheticEvent","payload","bubbles","cancelable","EventConstructor","eventOptions","console","name","CustomEvent","detail","syntheticTargetElements","defineProperty","querySelectorAll","updateSwipeTouch","startOrEnd","includes","type","changedTouches","screenX","screenY","resolvePostMessageTarget","method","contentWindow","windowPostMessageHandler","currentTarget","targetPostMessages","origin","__AVA_ENV__","location","href","messageType","data","removePostMessageHandlers","handlerCountBefore","h","handlerCountAfter","on","removers","set","__default","remover","eventListenerOptions","off","tryNativeRemoval","pause","resume","fire","fireCount","syntheticEvent","emit","emitCount","element","dispatchEvent","offDetachedElements","offCount","document","body","contains","onSwipe","direction","dimensionFactor","hasToBeTouchDevice","eventNameSpace","originalHandler","swipeHandler","width","offsetWidth","height","offsetHeight","offSwipe","onDomReady","callback","readyState","wrappedCallback","onPostMessage","offPostMessage","emitPostMessage","message","postMessage"],"sources":["events.js"],"mappings":"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","sourcesContent":["/*!\n * Module Events\n */\n\n/**\n * @namespace Events\n */\n\nconst MODULE_NAME = 'Events';\n\n\n\n//###[ IMPORTS ]########################################################################################################\n\nimport {\n\tassert,\n\tisFunction,\n\tisString,\n\tisArray,\n\tisBoolean,\n\tisObject,\n\tisWindow,\n\tisEventTarget,\n\tisPlainObject,\n\tisElement,\n\torDefault,\n\thasValue,\n\tisEmpty,\n\tisSelector\n} from './basic.js';\nimport {slugify} from './strings.js';\nimport {removeFrom} from './arrays.js';\nimport {detectInteractionType} from './context.js';\nimport {warn} from './logging.js';\n\n\n\n//###[ DATA ]###########################################################################################################\n\nexport const\n\tEVENT_MAP = new Map(),\n\tPOST_MESSAGE_MAP = new Map()\n;\n\nconst\n\tDEFAULT_NAMESPACE = '__default',\n\tSWIPE_DIRECTIONS = ['up', 'right', 'down', 'left'],\n\tSWIPE_HANDLERS = new WeakMap(),\n\tSWIPE_TOUCH = {\n\t\tstartX : 0,\n\t\tstartY : 0,\n\t\tendX : 0,\n\t\tendY : 0\n\t},\n\tEVENT_OPTION_SUPPORT = {\n\t\tcapture : false,\n\t\tonce : false,\n\t\tpassive : false,\n\t\tsignal : false\n\t}\n;\n\ntry {\n\tconst options = {\n\t\tget capture(){\n\t\t\tEVENT_OPTION_SUPPORT.capture = true;\n\t\t\treturn false;\n\t\t},\n\t\tget once(){\n\t\t\tEVENT_OPTION_SUPPORT.once = true;\n\t\t\treturn false;\n\t\t},\n\t\tget passive(){\n\t\t\tEVENT_OPTION_SUPPORT.passive = true;\n\t\t\treturn false;\n\t\t},\n\t\tget signal(){\n\t\t\tEVENT_OPTION_SUPPORT.signal = true;\n\t\t\treturn false;\n\t\t},\n\t};\n\n\twindow.addEventListener('test', null, options);\n\twindow.removeEventListener('test', null, options);\n} catch (err){}\n\n\n\n//###[ HELPERS ]########################################################################################################\n\n/*\n * Takes the standard set of event function parameters, sanitizes the values and asserts basic compatability.\n * Returns the transformed parameters as an object, with keys of the same name as the relevant parameters.\n *\n * @private\n */\nfunction prepareEventMethodBaseParams(methodName, targets, events, handler, handlerIsOptional=false){\n\ttargets = orDefault(targets, [], 'arr');\n\tassert(targets.length > 0, `${MODULE_NAME}:${methodName} | no targets provided`);\n\tevents = orDefault(events, [], 'arr');\n\tassert(events.length > 0, `${MODULE_NAME}:${methodName} | no events provided`);\n\tif( !handlerIsOptional || hasValue(handler) ){\n\t\tassert(isFunction(handler), `${MODULE_NAME}:${methodName} | handler is not a function`);\n\t}\n\n\tlet\n\t\ttargetsAreEventTargets = true,\n\t\tdelegatedTargetsAreSelectorsAndHaveAncestor = true\n\t;\n\n\ttargets.forEach((target, targetIndex) => {\n\t\tif( isString(target) ){\n\t\t\tconst ancestor = (targetIndex > 0) ? targets[targetIndex - 1] : null;\n\t\t\tdelegatedTargetsAreSelectorsAndHaveAncestor &&= isSelector(target) && isEventTarget(ancestor);\n\t\t} else {\n\t\t\ttargetsAreEventTargets &&= isEventTarget(target);\n\t\t}\n\t});\n\n\tassert(targetsAreEventTargets, `${MODULE_NAME}:${methodName} | not all targets are event targets`);\n\tassert(\n\t\tdelegatedTargetsAreSelectorsAndHaveAncestor,\n\t\t`${MODULE_NAME}:${methodName} | not all delegated targets are a selector or have an ancestor`\n\t);\n\n\tevents = events\n\t\t.map(event => event.replace(`.${DEFAULT_NAMESPACE}`, '.-default-ns'))\n\t\t.map(event => slugify(event, {\n\t\t\t'.' : '___dot___',\n\t\t\t'*' : '___star___'\n\t\t}))\n\t\t.map(event => event.replaceAll('___dot___', '.'))\n\t\t.map(event => event.replaceAll('___star___', '*'))\n\t\t.map(event => event.replace('.-default-ns', `.${DEFAULT_NAMESPACE}`))\n\t;\n\n\treturn {targets, events, handler};\n}\n\n\n\n/*\n * Prepares basic information about the current target in a list of targets.\n * The current target is identified by index, since the same target may appear multiple times in a list,\n * for example as a target and a delegation ancestor.\n *\n * @private\n */\nfunction prepareEventMethodAdditionalTargetInfo(methodName, targets, targetIndex){\n\tconst\n\t\tprevTarget =  ((targetIndex - 1) >= 0) ? targets[targetIndex - 1] : null,\n\t\tnextTarget =  (targetIndex < (targets.length - 1)) ? targets[targetIndex + 1] : null,\n\t\thasDelegation = isSelector(nextTarget),\n\t\tisDelegation = isSelector(targets[targetIndex])\n\t;\n\n\tassert(\n\t\t!isDelegation || (isDelegation && isEventTarget(prevTarget)),\n\t\t`${MODULE_NAME}:${methodName} | delegation has no ancestor`\n\t);\n\n\treturn {prevTarget, nextTarget, hasDelegation, isDelegation};\n}\n\n\n\n/*\n * Prepares basic information about the current event in a list of events.\n * The current event is identified by a complete eventName string containing the event itself,\n * as well as the complete dot-separated namespace.\n *\n * @private\n */\nfunction prepareEventMethodEventInfo(eventName, defaultNamespace=null, defaultEvent=null){\n\tconst\n\t\teventParts = eventName.replace('.', '/////').split('/////'),\n\t\tevent = (isEmpty(eventParts[0]) || (eventParts[0] === '*')) ? defaultEvent : eventParts[0],\n\t\tnamespace = (isEmpty(eventParts[1]) || (eventParts[1] === '*')) ? defaultNamespace : eventParts[1]\n\t;\n\n\treturn {event, namespace};\n}\n\n\n\n/*\n * Gathers matching events with namespaces for a given target (with or without a delegation).\n * Returns the found namespaces and events as a dictionary of namespaces with values of sets containing\n * the corresponding event names.\n *\n * @private\n */\nfunction gatherTargetEvents(target, namespace=null, event=null, delegation=null){\n\tconst __methodName__ = 'gatherTargetEvents';\n\n\tconst targetEvents = EVENT_MAP.get(target);\n\tassert(isPlainObject(targetEvents), `${MODULE_NAME}:${__methodName__} | invalid target \"${target}\"`);\n\n\tconst gatheredTargetEvents = {};\n\n\tif( !hasValue(namespace) && !hasValue(event) ){\n\t\tObject.keys(targetEvents).forEach(ns => {\n\t\t\tgatheredTargetEvents[ns] = new Set([]);\n\t\t\tObject.keys(targetEvents[ns]).forEach(ev => {\n\t\t\t\tif( !hasValue(delegation) || hasValue(targetEvents[ns][ev].delegations[delegation]) ){\n\t\t\t\t\tgatheredTargetEvents[ns].add(ev);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t} else if( !hasValue(event) ){\n\t\tconst nameSpaceScope = targetEvents[namespace];\n\t\tif( hasValue(nameSpaceScope) ){\n\t\t\tgatheredTargetEvents[namespace] = new Set([]);\n\t\t\tObject.keys(targetEvents[namespace]).forEach(ev => {\n\t\t\t\tif( !hasValue(delegation) || hasValue(nameSpaceScope[ev].delegations[delegation]) ){\n\t\t\t\t\tgatheredTargetEvents[namespace].add(ev);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t} else if( !hasValue(namespace) ){\n\t\tObject.keys(targetEvents).forEach(ns => {\n\t\t\tconst nameSpaceScope = targetEvents[ns];\n\t\t\tif(\n\t\t\t\thasValue(nameSpaceScope[event])\n\t\t\t\t&& (!hasValue(delegation) || hasValue(nameSpaceScope[event].delegations[delegation]))\n\t\t\t){\n\t\t\t\tif( !hasValue(gatheredTargetEvents[ns]) ){\n\t\t\t\t\tgatheredTargetEvents[ns] = new Set([]);\n\t\t\t\t}\n\t\t\t\tgatheredTargetEvents[ns].add(event);\n\t\t\t}\n\t\t});\n\t} else {\n\t\tconst nameSpaceScope = targetEvents[namespace];\n\t\tif(\n\t\t\thasValue(nameSpaceScope)\n\t\t\t&& hasValue(nameSpaceScope[event])\n\t\t\t&& (!hasValue(delegation) || hasValue(nameSpaceScope[event].delegations[delegation]))\n\t\t){\n\t\t\tif( !hasValue(gatheredTargetEvents[namespace]) ){\n\t\t\t\tgatheredTargetEvents[namespace] = new Set([]);\n\t\t\t}\n\t\t\tgatheredTargetEvents[namespace].add(event);\n\t\t}\n\t}\n\n\treturn gatheredTargetEvents;\n}\n\n\n\n/*\n * Iterates through the event map (starting with a specific target or using all targets) and searches for\n * deserted handler definitions. Deletes definitions that do not contain any handlers anymore and recursively\n * removes the path back to the starting point(s) if it turns out to be empty afterwards.\n *\n * @private\n */\nfunction cleanUpEventMap(targets){\n\ttargets = hasValue(targets) ? new Set([].concat(targets)) : null;\n\n\tconst desertedTargets = [];\n\n\tEVENT_MAP.forEach((targetEvents, target) => {\n\t\tif( !hasValue(targets) || targets.has(target) ){\n\t\t\tObject.keys(targetEvents).forEach(targetNamespace => {\n\t\t\t\tObject.keys(targetEvents[targetNamespace]).forEach(targetEvent => {\n\t\t\t\t\tconst targetScope = targetEvents[targetNamespace][targetEvent];\n\t\t\t\t\tlet handlerCount = targetScope.handlers.length;\n\n\t\t\t\t\tObject.keys(targetScope.delegations).forEach(delegation => {\n\t\t\t\t\t\tconst delegationHandlerCount = targetScope.delegations[delegation].handlers.length;\n\t\t\t\t\t\thandlerCount += delegationHandlerCount;\n\n\t\t\t\t\t\tif( delegationHandlerCount === 0 ){\n\t\t\t\t\t\t\tdelete targetScope.delegations[delegation];\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\tif( handlerCount === 0){\n\t\t\t\t\t\tdelete targetEvents[targetNamespace][targetEvent];\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tif( Object.keys(targetEvents[targetNamespace]).length === 0 ){\n\t\t\t\t\tdelete targetEvents[targetNamespace];\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif( Object.keys(targetEvents).length === 0 ){\n\t\t\t\tdesertedTargets.push(target);\n\t\t\t}\n\t\t}\n\t});\n\n\tdesertedTargets.forEach(desertedTarget => {\n\t\tEVENT_MAP.delete(desertedTarget);\n\t});\n}\n\n\n\n/*\n * Takes a handler function and returns a new function wrapping the handler, making sure, that the handler only\n * executes, if the event target matches the given delegation selector. So, the returned function automatically\n * checks if the delegation is actually met.\n *\n * @private\n */\nfunction createDelegatedHandler(delegation, handler){\n\treturn function delegatedHandler(e){\n\t\tconst\n\t\t\tdelegationSelector = `${delegation}`,\n\t\t\tdelegationFulfilled = hasValue(e.target?.matches)\n\t\t\t\t? e.target.matches(delegationSelector)\n\t\t\t\t: (\n\t\t\t\t\tisEventTarget(e.syntheticTarget)\n\t\t\t\t\t|| (\n\t\t\t\t\t\tisArray(e.syntheticTarget)\n\t\t\t\t\t\t&& isSelector(e.syntheticTarget[1])\n\t\t\t\t\t)\n\t\t\t\t\t? (\n\t\t\t\t\t\tisEventTarget(e.syntheticTarget)\n\t\t\t\t\t\t? e.syntheticTarget.matches(delegationSelector)\n\t\t\t\t\t\t: (e.syntheticTarget[1] === delegationSelector))\n\t\t\t\t\t: null\n\t\t\t\t)\n\t\t;\n\n\t\tif( delegationFulfilled ){\n\t\t\thandler(e);\n\t\t}\n\t};\n}\n\n\n\n/*\n * Takes a handler function and returns a new function, which, when executed, removes the handler from the exact\n * path in the EVENT_MAP, defined by the given target, namespace and event (and, optionally, a delegation selector).\n * Using this function, one can undo the setting of a handler, using \"on\" or \"once\".\n *\n * @private\n */\nfunction createHandlerRemover(target, namespace, event, handler, delegation=null, ignoreInvalidScope=false){\n\tconst\n\t\t__methodName__ = 'createHandlerRemover',\n\t\ttargetEvents = EVENT_MAP.get(target)\n\t;\n\tlet handlerScope = targetEvents?.[namespace]?.[event];\n\n\tif( hasValue(delegation) ){\n\t\tassert(isSelector(delegation), `${MODULE_NAME}:${__methodName__} | invalid delegation \"${delegation}\"`);\n\t\thandlerScope = handlerScope.delegations[`${delegation}`];\n\t}\n\n\tif( !ignoreInvalidScope ){\n\t\tassert(isPlainObject(handlerScope), `${MODULE_NAME}:${__methodName__} | invalid handlerScope`);\n\t} else if( !isPlainObject(handlerScope) ){\n\t\treturn () => {};\n\t}\n\n\treturn function handlerRemover(){\n\t\tconst removedHandlers = handlerScope.handlers.filter(existingHandler => existingHandler.handler === handler);\n\t\thandlerScope.handlers = removeFrom(handlerScope.handlers, removedHandlers);\n\n\t\tremovedHandlers.forEach(removedHandler => {\n\t\t\ttarget.removeEventListener(event, removedHandler.action);\n\t\t});\n\n\t\tcleanUpEventMap(target);\n\t};\n}\n\n\n\n/*\n * Takes a handler function and returns a new function, which, when executed, calls the handler and, afterwards,\n * automatically removes the handler from the path in the EVENT_MAP, defined by the given target, namespace and event\n * (and, optionally, a delegation selector). So, the returned function is essentially a self-destructing handler.\n *\n * @private\n */\nfunction createSelfRemovingHandler(target, namespace, event, handler, delegation=null){\n\treturn function selfRemovingHandler(e){\n\t\thandler(e);\n\t\tcreateHandlerRemover(target, namespace, event, handler, delegation, true)();\n\t};\n}\n\n\n\n/*\n * Removes (a) handler(s) from a path in the EVENT_MAP, defined by the given target, namespace, event and handler\n * (and, optionally, a delegation selector).\n *\n * @private\n */\nfunction removeLocatedHandler(target, namespace, event, handler, delegation=null){\n\tconst\n\t\t__methodName__ = 'removeLocatedHandler',\n\t\ttargetEvents = EVENT_MAP.get(target),\n\t\ttargetScope = targetEvents?.[namespace]?.[event]\n\t;\n\n\tassert(isPlainObject(targetScope), `${MODULE_NAME}:${__methodName__} | invalid targetScope`);\n\n\tlet handlerScope;\n\tif( hasValue(delegation) ){\n\t\tconst delegationScope = targetScope.delegations[`${delegation}`];\n\t\tassert(isPlainObject(delegationScope), `${MODULE_NAME}:${__methodName__} | invalid delegation \"${delegation}\"`);\n\t\thandlerScope = delegationScope;\n\t} else {\n\t\thandlerScope = targetScope;\n\t}\n\tconst removedHandlers = handlerScope.handlers.filter(existingHandler => {\n\t\treturn hasValue(handler)\n\t\t\t? (handler === existingHandler.handler)\n\t\t\t: true\n\t\t;\n\t});\n\n\thandlerScope.handlers = removeFrom(handlerScope.handlers, removedHandlers);\n\n\tremovedHandlers.forEach(removedHandler => {\n\t\ttarget.removeEventListener(event, removedHandler.action);\n\t\ttarget.removeEventListener(event, removedHandler.action, {capture : true});\n\t});\n\n\treturn removedHandlers.length;\n}\n\n\n\n/*\n * Removes all handlers matching the given definition provided by target, namespace, event and handler\n * (and, optionally, a delegation selector). Leaving out namespace, event or handler works as a wildcard.\n *\n * @private\n */\nfunction removeHandlers(target, namespace=null, event=null, handler=null, delegation=null){\n\tconst targetEvents = gatherTargetEvents(target, namespace, event, delegation);\n\n\tlet removedCount = 0;\n\n\tObject.keys(targetEvents).forEach(ns => {\n\t\tArray.from(targetEvents[ns]).forEach(ev => {\n\t\t\tremovedCount += removeLocatedHandler(target, ns, ev, handler, delegation);\n\t\t});\n\t});\n\n\treturn removedCount;\n}\n\n\n\n/*\n * Shorthand-function for \"removeHandlers\" with more sane parameter order for delegations.\n *\n * @private\n */\nfunction removeDelegatedHandlers(ancestor, delegation, namespace=null, event=null, handler=null){\n\treturn removeHandlers(ancestor, namespace, event, handler, delegation);\n}\n\n\n\n/*\n * Pauses (a) handler(s) from a path in the EVENT_MAP, defined by the given target, namespace, event and handler\n * (and, optionally, a delegation selector). If paused is false, the function instead resumes the handlers.\n *\n * @private\n */\nfunction pauseLocatedHandlers(target, namespace, event, handler, delegation=null, paused=true){\n\tconst\n\t\t__methodName__ = 'pauseLocatedHandlers',\n\t\ttargetEvents = EVENT_MAP.get(target),\n\t\ttargetScope = targetEvents?.[namespace]?.[event]\n\t;\n\n\tassert(isPlainObject(targetScope), `${MODULE_NAME}:${__methodName__} | invalid targetScope`);\n\n\tlet handlerScope;\n\tif( hasValue(delegation) ){\n\t\tconst delegationScope = targetScope.delegations[`${delegation}`];\n\t\tassert(isPlainObject(delegationScope), `${MODULE_NAME}:${__methodName__} | invalid delegation \"${delegation}\"`);\n\t\thandlerScope = delegationScope;\n\t} else {\n\t\thandlerScope = targetScope;\n\t}\n\n\tconst pausedHandlers = handlerScope.handlers.filter(existingHandler => {\n\t\treturn hasValue(handler)\n\t\t\t? (handler === existingHandler.handler)\n\t\t\t: true\n\t\t;\n\t});\n\n\tpausedHandlers.forEach(pausedHandler => {\n\t\tpausedHandler.paused = !!paused;\n\t});\n\n\treturn pausedHandlers.length;\n}\n\n\n\n/*\n * Pauses all handlers matching the given definition provided by target, namespace, event and handler\n * (and, optionally, a delegation selector). Leaving out namespace, event or handler works as a wildcard.\n * If paused is false, the function instead resumes the handlers.\n *\n * @private\n */\nfunction pauseHandlers(target, namespace=null, event=null, handler=null, delegation=null, paused=true){\n\tconst targetEvents = gatherTargetEvents(target, namespace, event, delegation);\n\n\tlet pausedCount = 0;\n\n\tObject.keys(targetEvents).forEach(ns => {\n\t\tArray.from(targetEvents[ns]).forEach(ev => {\n\t\t\tpausedCount += pauseLocatedHandlers(target, ns, ev, handler, delegation, paused);\n\t\t});\n\t});\n\n\treturn pausedCount;\n}\n\n\n\n/*\n * Shorthand-function for \"pauseHandlers\" with more sane parameter order for delegations.\n *\n * @private\n */\nfunction pauseDelegatedHandlers(ancestor, delegation, namespace=null, event=null, handler=null, paused=true){\n\treturn pauseHandlers(ancestor, namespace, event, handler, delegation, paused);\n}\n\n\n\n/*\n * Takes a handler object and a corresponding action, which is not yet aware of its pause state and\n * returns an action function, which checks if the handler is paused, before executing the original action.\n * Using this, we can wrap handler actions to automatically react to the handler's pause state, preventing any\n * handler execution if the handler is currently paused.\n *\n * @private\n */\nfunction createPauseAwareAction(managedHandler, nonPauseAwareAction){\n\treturn function pauseAwareHandler(e){\n\t\tif( !managedHandler.paused ){\n\t\t\tnonPauseAwareAction(e);\n\t\t}\n\t};\n}\n\n\n\n/*\n * Takes an event listener options object as provided by the user, to be used as the third parameter of\n * addEventListener, and returns a sanitized version, taking into regard what options the browser actually supports\n * and falling back to boolean capture values, if the browser does not know about listener options at all.\n *\n * @private\n */\nfunction compileEventListenerOptions(options){\n\tif( isBoolean(options) ) return options;\n\tif( !isObject(options) ) return null;\n\n\tconst supportedOptions = {};\n\n\tObject.keys(EVENT_OPTION_SUPPORT).forEach(option => {\n\t\tif( !!EVENT_OPTION_SUPPORT[option] && hasValue(options[option]) ){\n\t\t\tsupportedOptions[option] = options[option];\n\t\t}\n\t});\n\n\tif( (Object.keys(supportedOptions).length === 0) && !!options.capture ){\n\t\treturn true;\n\t}\n\n\treturn supportedOptions;\n}\n\n\n\n/*\n * Creates a synthetic event to dispatch on an event target.\n *\n * @private\n */\nfunction createSyntheticEvent(\n\tevent,\n\tnamespace=null,\n\tpayload=null,\n\tbubbles=null,\n\tcancelable=null,\n\tsyntheticTarget=null,\n\tEventConstructor=null,\n\teventOptions=null\n){\n\tconst __methodName__ = 'createSyntheticEvent';\n\n\tevent = `${event}`;\n\tbubbles = orDefault(bubbles, false, 'bool');\n\tcancelable = orDefault(cancelable, bubbles, 'bool');\n\teventOptions = isPlainObject(eventOptions) ? eventOptions : {};\n\n\tlet e;\n\tif( isFunction(EventConstructor) ){\n\t\tif( isPlainObject(payload) ){\n\t\t\tconsole.warn(`${MODULE_NAME}:${__methodName__} | can't add payload to event \"${EventConstructor.name}\", skipping`);\n\t\t}\n\t\te = new EventConstructor(event, {bubbles, cancelable, ...eventOptions});\n\t} else {\n\t\te = isPlainObject(payload)\n\t\t\t? new CustomEvent(event, {detail : payload, bubbles, cancelable, ...eventOptions})\n\t\t\t// we could use new Event() here, but jsdom and ava cannot use that constructor for dispatchEvent :(\n\t\t\t: new CustomEvent(event, {bubbles, cancelable, ...eventOptions})\n\t\t;\n\t}\n\n\tif( hasValue(namespace) ){\n\t\te.namespace = `${namespace}`;\n\t}\n\n\tif( isEventTarget(syntheticTarget) ){\n\t\te.syntheticTarget = syntheticTarget;\n\t\te.syntheticTargetElements = [syntheticTarget]\n\t} else if(\n\t\tisArray(syntheticTarget)\n\t\t&& isEventTarget(syntheticTarget[0])\n\t\t&& isSelector(syntheticTarget[1])\n\t){\n\t\te.syntheticTarget = syntheticTarget;\n\t\tObject.defineProperty(e, 'syntheticTargetElements', {\n\t\t\tget(){\n\t\t\t\treturn Array.from(syntheticTarget[0].querySelectorAll(`${syntheticTarget[1]}`));\n\t\t\t}\n\t\t});\n\t}\n\n\treturn e;\n}\n\n\n\n/*\n * Updates touch data for a start swipe event.\n *\n * @private\n */\nfunction updateSwipeTouch(e){\n\tconst startOrEnd = ['touchstart', 'mousedown'].includes(e.type) ? 'start' : 'end';\n\tif( ['touchstart', 'touchend'].includes(e.type) ){\n\t\tSWIPE_TOUCH[`${startOrEnd}X`] = e.changedTouches[0].screenX;\n\t\tSWIPE_TOUCH[`${startOrEnd}Y`] = e.changedTouches[0].screenY;\n\t} else {\n\t\tSWIPE_TOUCH[`${startOrEnd}X`] = e.screenX;\n\t\tSWIPE_TOUCH[`${startOrEnd}Y`] = e.screenY;\n\t}\n}\n\n\n\n/*\n * Tries to find a usable target for post messages, based on a given target element.\n *\n * @private\n */\nfunction resolvePostMessageTarget(target, method){\n\ttarget = isWindow(target)\n\t\t? target\n\t\t: (\n\t\t\tisWindow(target?.contentWindow)\n\t\t\t? target.contentWindow\n\t\t\t: null\n\t\t)\n\t;\n\n\tassert(hasValue(target), `${MODULE_NAME}:${method} | no usable target`);\n\n\treturn target\n}\n\n\n\n/*\n * Default handling for post messages for a window.\n *\n * @private\n */\nfunction windowPostMessageHandler(e){\n\tconst\n\t\ttarget = e.currentTarget,\n\t\ttargetPostMessages = POST_MESSAGE_MAP.get(target),\n\t\torigin = !isEmpty(e.origin) ? e.origin : (!!window.__AVA_ENV__ ? window.location.href : null),\n\t\tmessageType = e.data?.type\n\t;\n\n\tif( hasValue(targetPostMessages) ){\n\t\tconst messageTypes = hasValue(messageType) ? [messageType] : Object.keys(targetPostMessages);\n\t\tmessageTypes.forEach(messageType => {\n\t\t\t(targetPostMessages[messageType] ?? []).forEach(handler => {\n\t\t\t\tif( (handler.origin === '*') || (handler.origin === origin) ){\n\t\t\t\t\thandler.handler(e);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n}\n\n\n\n/*\n * Iterates message handlers for a target, and removes handlers, based on given handler and origin.\n *\n * @private\n */\nfunction removePostMessageHandlers(targetPostMessages, messageType, origin=null, handler=null){\n\tif( hasValue(targetPostMessages[messageType]) ){\n\t\tconst handlerCountBefore = targetPostMessages[messageType].length;\n\n\t\tif( !hasValue(origin) && !hasValue(handler) ){\n\t\t\ttargetPostMessages[messageType] = [];\n\t\t} else if( hasValue(origin) && !hasValue(handler) ){\n\t\t\ttargetPostMessages[messageType] = targetPostMessages[messageType].filter(h => h.origin !== origin);\n\t\t} else if( !hasValue(origin) && hasValue(handler) ){\n\t\t\ttargetPostMessages[messageType] = targetPostMessages[messageType].filter(h => h.handler !== handler);\n\t\t} else if( hasValue(origin, handler) ) {\n\t\t\ttargetPostMessages[messageType] = targetPostMessages[messageType].filter(\n\t\t\t\th => (h.origin !== origin) && (h.handler !== handler)\n\t\t\t);\n\t\t}\n\n\t\tconst handlerCountAfter = targetPostMessages[messageType].length;\n\n\t\tif( targetPostMessages[messageType].length === 0 ){\n\t\t\tdelete targetPostMessages[messageType];\n\t\t}\n\n\t\treturn handlerCountBefore - handlerCountAfter;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\n\n\n//###[ EXPORTS ]########################################################################################################\n\n/**\n * @namespace Events:on\n */\n\n/**\n * Registers (an) event listener(s) to (a) valid EventTarget(s) (most likely (a) DOM-element(s)).\n *\n * This method is inspired by jQuery and cash, though not identical.\n * You may define one or more targets as well as one or more events to register a handler to, by either providing single\n * arguments or arrays. You may also, additionally, namespace events, like in jQuery/cash, by adding it after the event\n * name, separated by a dot ('click.namespace').\n *\n * This method returns a remover function, which removes all event registrations done by this method call.\n * So, in essence, calling that function, removes exactly, what was added, in a single call.\n *\n * @param {EventTarget|Array<EventTarget>} targets - the target(s) to register event handlers on\n * @param {String|Array<String>} events - the event name(s) to listen to, can be either a single name or a list of names, each name may also have a namespace, separated by a dot, to target all events/namespaces, you may use \"*\"/\"*.*\"\n * @param {Function} handler - the callback to execute if the event(s) defined in events are being received on target\n * @param {?Object|Boolean} [options=null] - event listener options according to \"addEventListener\"-syntax, will be ignored, if browser does not support this, if boolean, will be used as \"useCapture\", the same will happen if options are not supported, but you defined \"{capture : true}\", \"{once : true}\" will not be applied directly to the listener, but will, instead, set the \"once\"-parameter to true (otherwise delegated listeners would self-destroy immediately on any check)\n * @param {?Boolean} [once=false] - defines if the handler should only execute once, after which it self-destroys automatically, this will automatically be enabled, if you set options.once to true\n * @throws error in case no targets are defined\n * @throws error in case no events are defined\n * @throws error in case handler is not a function\n * @throws error in case targets are not all usable event targets\n * @throws error in case delegations are missing viable ancestor targets\n * @returns {Function} remover function, which removes all handlers again, added by the current execution\n *\n * @memberof Events:on\n * @alias on\n * @see off\n * @see once\n * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget\n * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener?retiredLocale=de#syntax\n * @example\n * on(linkElement, 'click', e => {\te.stopPropagation(); });\n * on(someElementWithCustomEvents, 'crash.test', () => { alert('crashed!'); });\n * on([ancestorElement, 'a'], 'click', e => { e.target.classList.add('clicked'); });\n * on(buttonElement, 'click', () => { console.log('click twice, but I'll just print once); }, {passive : true, once : true});\n * on([ancestorElement, '.btn[data-foobar=\"test\"]'], 'click', () => { console.log('I'll just fire once); }, null, true);\n * on(document.body, 'click', e => { console.log(`oh, a bubbled event, let's see what has been clicked: \"${e.target}\"`); });\n * on([foo, foo, 'button', bar], ['mousedown', 'touchstart'], e => { e.target.classList.add('interaction-start'); });\n */\nexport function on(targets, events, handler, options=null, once=false){\n\tconst __methodName__ = 'on';\n\n\t({targets, events, handler} = prepareEventMethodBaseParams(__methodName__, targets, events, handler));\n\tonce = !!once || !!options?.once;\n\tdelete options?.once;\n\n\tconst removers = [];\n\n\ttargets.forEach((target, targetIndex) => {\n\t\tconst {\n\t\t\tprevTarget,\n\t\t\thasDelegation,\n\t\t\tisDelegation\n\t\t} = prepareEventMethodAdditionalTargetInfo(__methodName__, targets, targetIndex);\n\n\t\tlet targetEvents = EVENT_MAP.get(target);\n\t\tif( isDelegation ){\n\t\t\ttargetEvents = EVENT_MAP.get(prevTarget);\n\t\t} else if( !hasValue(targetEvents) ){\n\t\t\tEVENT_MAP.set(target, {[DEFAULT_NAMESPACE] : {}});\n\t\t\ttargetEvents = EVENT_MAP.get(target);\n\t\t}\n\n\t\tif( !hasDelegation ){\n\t\t\tevents.forEach(eventName => {\n\t\t\t\tconst {event, namespace} = prepareEventMethodEventInfo(eventName, DEFAULT_NAMESPACE);\n\n\t\t\t\tif( !hasValue(targetEvents[namespace]) ){\n\t\t\t\t\ttargetEvents[namespace] = {};\n\t\t\t\t}\n\n\t\t\t\tif( !hasValue(targetEvents[namespace][event]) ){\n\t\t\t\t\ttargetEvents[namespace][event] = {\n\t\t\t\t\t\ttarget : isDelegation ? prevTarget : target,\n\t\t\t\t\t\thandlers : [],\n\t\t\t\t\t\tdelegations : {}\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tconst targetScope = targetEvents[namespace][event];\n\t\t\t\tlet handlerScope, action, remover;\n\n\t\t\t\tif( isDelegation ){\n\t\t\t\t\tif( !hasValue(targetScope.delegations[target]) ){\n\t\t\t\t\t\ttargetScope.delegations[target] = {handlers : []};\n\t\t\t\t\t}\n\t\t\t\t\thandlerScope = targetScope.delegations[target];\n\n\t\t\t\t\taction = !!once\n\t\t\t\t\t\t? createDelegatedHandler(\n\t\t\t\t\t\t\ttarget,\n\t\t\t\t\t\t\tcreateSelfRemovingHandler(targetScope.target, namespace, event, handler, target)\n\t\t\t\t\t\t)\n\t\t\t\t\t\t: createDelegatedHandler(target, handler)\n\t\t\t\t\t;\n\t\t\t\t\tremover = createHandlerRemover(targetScope.target, namespace, event, handler, target);\n\t\t\t\t} else {\n\t\t\t\t\thandlerScope = targetScope;\n\t\t\t\t\taction = !!once\n\t\t\t\t\t\t? createSelfRemovingHandler(targetScope.target, namespace, event, handler)\n\t\t\t\t\t\t: handler\n\t\t\t\t\t;\n\t\t\t\t\tremover = createHandlerRemover(targetScope.target, namespace, event, handler);\n\t\t\t\t}\n\n\t\t\t\tconst managedHandler = {\n\t\t\t\t\thandler,\n\t\t\t\t\tremover,\n\t\t\t\t\tpaused : false,\n\t\t\t\t};\n\t\t\t\tmanagedHandler.action = createPauseAwareAction(managedHandler, action);\n\t\t\t\thandlerScope.handlers = handlerScope.handlers.concat(managedHandler);\n\n\t\t\t\tconst eventListenerOptions = compileEventListenerOptions(options);\n\t\t\t\tif( hasValue(eventListenerOptions) ){\n\t\t\t\t\ttargetScope.target.addEventListener(event, managedHandler.action, eventListenerOptions);\n\t\t\t\t} else {\n\t\t\t\t\ttargetScope.target.addEventListener(event, managedHandler.action);\n\t\t\t\t}\n\n\t\t\t\tremovers.push(remover);\n\t\t\t});\n\t\t}\n\t});\n\n\treturn (removers.length > 1)\n\t\t? function(){\n\t\t\tremovers.forEach(remover => remover());\n\t\t}\n\t\t: (\n\t\t\t(removers.length > 0)\n\t\t\t? removers[0]\n\t\t\t: null\n\t\t)\n\t;\n}\n\n\n\n/**\n * @namespace Events:once\n */\n\n/**\n * Registers (an) event listener(s) to (a) valid EventTarget(s) (most likely (a) DOM-element(s)).\n *\n * This version automatically removes the handler, after it has fired once.\n *\n * This method is inspired by jQuery and cash, though not identical.\n * You may define one or more targets as well as one or more events to register a handler to, by either providing single\n * arguments or arrays. You may also, additionally, namespace events, like in jQuery/cash, by adding it after the event\n * name, separated by a dot ('click.namespace').\n *\n * This method returns a remover function, which removes all event registrations done by this method call.\n * So, in essence, calling that function, removes exactly, what was added, in a single call.\n *\n * @param {EventTarget|Array<EventTarget>} targets - the target(s) to register event handlers on\n * @param {String|Array<String>} events - the event name(s) to listen to, can be either a single name or a list of names, each name may also have a namespace, separated by a dot, to target all events/namespaces, you may use \"*\"/\"*.*\"\n * @param {Function} handler - the callback to execute if the event(s) defined in events are being received on target\n * @param {?Object|Boolean} [options=null] - event listener options according to \"addEventListener\"-syntax, will be ignored, if browser does not support this, if boolean, will be used as \"useCapture\", the same will happen if options are not supported, but you defined \"{capture : true}\", \"{once : true}\" makes no sense in this case, because the behaviour will automatically be applied anyway\n * @throws error in case no targets are defined\n * @throws error in case no events are defined\n * @throws error in case handler is not a function\n * @throws error in case targets are not all usable event targets\n * @throws error in case delegations are missing viable ancestor targets\n * @returns {Function} remover function, which removes all handlers again, added by the current execution\n *\n * @memberof Events:once\n * @alias once\n * @see on\n * @see off\n * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget\n * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener?retiredLocale=de#syntax\n * @example\n * once(linkElement, 'click', e => {\te.stopPropagation(); });\n * once(someElementWithCustomEvents, 'crash.test', () => { alert('crashed!'); });\n * once([ancestorElement, 'a'], 'click', e => { e.target.classList.add('clicked'); });\n * once(buttonElement, 'click', () => { console.log('click twice, but I'll just print once); }, {passive : true});\n * once([ancestorElement, '.btn[data-foobar=\"test\"]'], 'click', () => { console.log('I'll just fire once); });\n * once(document.body, 'click', e => { console.log(`oh, a bubbled event, let's see what has been clicked: \"${e.target}\"`); });\n * once([foo, foo, 'button', bar], ['mousedown', 'touchstart'], e => { e.target.classList.add('interaction-start'); });\n */\nexport function once(targets, events, handler, options=null){\n\treturn on(targets, events, handler, options, true);\n}\n\n\n\n/**\n * @namespace Events:off\n */\n\n/**\n * Removes (a), previously defined, event listener(s) on (a) valid EventTarget(s) (most likely (a) DOM-element(s)).\n *\n * The definition of targets and events works exactly as in \"on\" and \"once\", the only difference being, that the handler\n * is optional in this case, which results in the removal of all handlers, without targeting a specific one.\n *\n * To specifically target handlers without a namespace, please use the namespace-string \"__default\".\n *\n * This function does _not_ differentiate between removal of capture/non-capture events, but always removes both.\n *\n * If you try to remove event handlers not previously created with `on` (and therefore there are no fitting target\n * entries in the EVENT_MAP), the function will fall back to native `removeEventListener`\n * (if `tryNativeRemoval` is true), but in that case, a handler has to be defined and the return value will not\n * increment, since we do not know if the removal really worked.\n *\n * @param {EventTarget|Array<EventTarget>} targets - the target(s) to remove event handlers from\n * @param {String|Array<String>} events - the event name(s) to remove, can be either a single name or a list of names, each name may also have a namespace, separated by a dot, to target all events/namespaces, you may use \"*\"/\"*.*\"\n * @param {?Function} [handler=null] - a specific callback function to remove\n * @param {?Boolean} [tryNativeRemoval=true] - if a target is not part of the EVENT_MAP native removeEventListener is used as a fallback if this is true (handler needs to be set in that case)\n * @throws error in case no targets are defined\n * @throws error in case no events are defined\n * @throws error in case a defined handler is not a function\n * @throws error in case targets are not all usable event targets\n * @throws error in case delegations are missing viable ancestor targets\n * @returns {Number} the number of handlers actually removed by the function call, may also be 0 if nothing matched\n *\n * @memberof Events:off\n * @alias off\n * @see on\n * @see once\n * @example\n * off(buttonElement, 'click');\n * off(bar, '*.__default');\n * off(customEventElement, 'crash');\n * off([ancestorElement, 'a'], 'click');\n * off([ancestorElement, '.btn[data-foobar=\"test\"]'], '*.delegated', fSpecificHandler);\n * off(linkElement, '*', fSpecificHandler);\n * off(customEventElement, ['*.test', '*.site']);\n * off([ancestorElement, 'a', ancestorElement, '.btn[data-foobar=\"test\"]'], '*.*', fSpecificHandler);\n * off(buttonElement, '*.*');\n */\nexport function off(targets, events, handler=null, tryNativeRemoval=true){\n\tconst __methodName__ = 'off';\n\n\t({targets, events, handler} = prepareEventMethodBaseParams(__methodName__, targets, events, handler, true));\n\ttryNativeRemoval = orDefault(tryNativeRemoval, true, 'bool');\n\n\tlet removedCount = 0;\n\n\ttargets.forEach((target, targetIndex) => {\n\t\tconst {\n\t\t\tprevTarget,\n\t\t\thasDelegation,\n\t\t\tisDelegation\n\t\t} = prepareEventMethodAdditionalTargetInfo(__methodName__, targets, targetIndex);\n\n\t\tif( !hasDelegation ){\n\t\t\tconst targetEvents = isDelegation ? EVENT_MAP.get(prevTarget) : EVENT_MAP.get(target);\n\n\t\t\tevents.forEach(eventName => {\n\t\t\t\tconst {event, namespace} = prepareEventMethodEventInfo(eventName);\n\n\t\t\t\tif( hasValue(targetEvents) ){\n\t\t\t\t\tif( isDelegation ){\n\t\t\t\t\t\tremovedCount += removeDelegatedHandlers(prevTarget, target, namespace, event, handler);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tremovedCount += removeHandlers(target, namespace, event, handler);\n\t\t\t\t\t}\n\n\t\t\t\t\tcleanUpEventMap(isDelegation ? prevTarget : target);\n\t\t\t\t} else if( tryNativeRemoval ){\n\t\t\t\t\tif( hasValue(handler) ){\n\t\t\t\t\t\t(isDelegation ? prevTarget : target).removeEventListener(eventName, handler);\n\t\t\t\t\t\t(isDelegation ? prevTarget : target).removeEventListener(eventName, handler, {capture : true});\n\t\t\t\t\t} else {\n\t\t\t\t\t\twarn(`${MODULE_NAME}:${__methodName__} | native fallback event removal for \"${eventName}\" not possible, handler is missing`);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t});\n\n\treturn removedCount;\n}\n\n\n\n/**\n * @namespace Events:pause\n */\n\n/**\n * Pauses (a), previously defined, event listener(s), without actually removing anything. Subsequent executions\n * of the handler will not fire, while the handler is paused, which also means, that paused handlers, set up to only\n * fire once, will not self-destroy while being paused.\n *\n * The definition of targets and events works exactly as in \"on\" and \"once\", the only difference being, that the handler\n * is optional in this case, which results in the pausing of all handlers, without targeting a specific one.\n *\n * To specifically target handlers without a namespace, please use the namespace-string \"__default\".\n *\n * @param {EventTarget|Array<EventTarget>} targets - the target(s) to pause event handlers on\n * @param {String|Array<String>} events - the event name(s) to pause, can be either a single name or a list of names, each name may also have a namespace, separated by a dot, to target all events/namespaces, you may use \"*\"/\"*.*\"\n * @param {?Function} [handler=null] - a specific callback function to pause\n * @param {?Boolean} [paused=true] - defines if the matched handlers are being paused or resumed\n * @throws error in case no targets are defined\n * @throws error in case no events are defined\n * @throws error in case a defined handler is not a function\n * @throws error in case targets are not all usable event targets\n * @throws error in case delegations are missing viable ancestor targets\n * @returns {Number} the number of handlers actually paused by the function call, may also be 0 if nothing matched\n *\n * @memberof Events:pause\n * @alias pause\n * @see on\n * @see resume\n * @example\n * pause(buttonElement, 'click');\n * pause(linkElement, '*.__default');\n * pause(customEventElement, 'crash');\n * pause([ancestorElement, 'a'], 'click');\n * pause([ancestorElement, '.btn[data-foobar=\"test\"]'], '*.delegated', fSpecificHandler);\n */\nexport function pause(targets, events, handler=null, paused=true){\n\tconst __methodName__ = 'pause';\n\n\t({targets, events, handler} = prepareEventMethodBaseParams(__methodName__, targets, events, handler, true));\n\n\tlet pausedCount = 0;\n\n\ttargets.forEach((target, targetIndex) => {\n\t\tconst {\n\t\t\tprevTarget,\n\t\t\thasDelegation,\n\t\t\tisDelegation\n\t\t} = prepareEventMethodAdditionalTargetInfo(__methodName__, targets, targetIndex);\n\n\t\tif( !hasDelegation ){\n\t\t\tconst targetEvents = isDelegation ? EVENT_MAP.get(prevTarget) : EVENT_MAP.get(target);\n\n\t\t\tif( hasValue(targetEvents) ){\n\t\t\t\tevents.forEach(eventName => {\n\t\t\t\t\tconst {event, namespace} = prepareEventMethodEventInfo(eventName);\n\n\t\t\t\t\tif( isDelegation ){\n\t\t\t\t\t\tpausedCount += pauseDelegatedHandlers(prevTarget, target, namespace, event, handler, paused);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpausedCount += pauseHandlers(target, namespace, event, handler, null, paused);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t});\n\n\treturn pausedCount;\n}\n\n\n\n/**\n * @namespace Events:resume\n */\n\n/**\n * Resumes (a), previously paused, event listener(s). Subsequent executions of the handler will fire again.\n *\n * The definition of targets and events works exactly as in \"on\" and \"once\", the only difference being, that the handler\n * is optional in this case, which results in the un-pausing of all handlers, without targeting a specific one.\n *\n * To specifically target handlers without a namespace, please use the namespace-string \"__default\".\n *\n * @param {EventTarget|Array<EventTarget>} targets - the target(s) to resume event handlers on\n * @param {String|Array<String>} events - the event name(s) to resume, can be either a single name or a list of names, each name may also have a namespace, separated by a dot, to target all events/namespaces, you may use \"*\"/\"*.*\"\n * @param {?Function} [handler=null] - a specific callback function to resume\n * @throws error in case no targets are defined\n * @throws error in case no events are defined\n * @throws error in case a defined handler is not a function\n * @throws error in case targets are not all usable event targets\n * @throws error in case delegations are missing viable ancestor targets\n * @returns {Number} the number of handlers actually resumed by the function call, may also be 0 if nothing matched\n *\n * @memberof Events:resume\n * @alias resume\n * @see on\n * @see pause\n * @example\n * resume(linkElement, '*', fSpecificHandler);\n * resume(customEventElement, ['*.test', '*.site']);\n * resume([ancestorElement, 'a', ancestorElement, '.btn[data-foobar=\"test\"]'], '*.*', fSpecificHandler);\n * resume(buttonElement, '*.*');\n */\nexport function resume(targets, events, handler=null){\n\treturn pause(targets, events, handler, false);\n}\n\n\n\n/**\n * @namespace Events:fire\n */\n\n/**\n * Fires event handlers of all matched targets for given events.\n *\n * This function does not actually dispatch events, but identifies matches in the internal event map, based on\n * previously registered handlers using \"on\" and \"once\" and executes the attached handlers, providing them a synthetic\n * CustomEvent as first parameter, carrying the event name as well as a potential payload. So this, function is\n * using the event map as an event bus, instead of the DOM, so these events also will never bubble, but just hit the\n * currently present handlers identified exactly by the provided parameters.\n *\n * The definition of targets and events works exactly as in \"on\" and \"once\", the only difference being, that we have no\n * handler, since if we'd have the handler already, we could just call it.\n *\n * Since we do not use the DOM in this function, we also do not have native events, and therefore we do not have normal\n * event targets we can work with. Instead, this implementation adds the \"syntheticTarget\" and the\n * \"syntheticTargetElements\" event properties to the event that is given to the handler. \"syntheticTarget\" contains\n * the defined event map target, either as a EventTarget or an array of an EventTarget and a corresponding delegation\n * selector (just as you defined them before), while \"syntheticTargetElements\" returns the actual elements as an\n * iterable array. So, in case of a delegation, this gives you the power to actually work with the current delegation\n * targets, without having to write own logic for this.\n *\n * @param {EventTarget|Array<EventTarget>} targets - the target(s) to execute event handlers on\n * @param {String|Array<String>} events - the event name(s) to fire, can be either a single name or a list of names, each name may also have a namespace, separated by a dot, to target all events/namespaces, you may use \"*\"/\"*.*\"\n * @param {?Object} [payload=null] - a plain object payload to relay to the event handlers via the detail of the CustomEvent given to the handler as first parameter\n * @throws error in case no targets are defined\n * @throws error in case no events are defined\n * @throws error in case targets are not all usable event targets\n * @throws error in case delegations are missing viable ancestor targets\n * @returns {Number} the number of handlers actually executed by the function call, may also be 0 if nothing matched\n *\n * @memberof Events:fire\n * @alias fire\n * @see on\n * @see once\n * @see emit\n * @example\n * fire(buttonElement, 'click');\n * fire(linkElement, '*.__default', {importantFlag : true});\n * fire(divElement, 'crash');\n * fire([ancestorElement, 'a'], 'click', {linkWasClicked : true});\n * fire([ancestorElement, '.btn[data-foobar=\"test\"]'], '*.delegated');\n * fire(linkElement, '*');\n * fire([ancestorElement, 'a', ancestorElement, '.btn[data-foobar=\"test\"]'], '*.*');\n * fire(buttonElement, 'click.*', {price : 666});\n */\nexport function fire(targets, events, payload=null){\n\tconst __methodName__ = 'fire';\n\n\t({targets, events} = prepareEventMethodBaseParams(__methodName__, targets, events, null, true));\n\n\tlet fireCount = 0;\n\n\ttargets.forEach((target, targetIndex) => {\n\t\tconst {\n\t\t\tprevTarget,\n\t\t\thasDelegation,\n\t\t\tisDelegation\n\t\t} = prepareEventMethodAdditionalTargetInfo(__methodName__, targets, targetIndex);\n\n\t\tif( !hasDelegation ){\n\t\t\tconst targetEvents = isDelegation ? EVENT_MAP.get(prevTarget) : EVENT_MAP.get(target);\n\n\t\t\tif( hasValue(targetEvents) ){\n\t\t\t\tevents.forEach(eventName => {\n\t\t\t\t\tconst {event, namespace} = prepareEventMethodEventInfo(eventName);\n\n\t\t\t\t\tlet gatheredTargetEvents;\n\t\t\t\t\tif( isDelegation ){\n\t\t\t\t\t\tgatheredTargetEvents = gatherTargetEvents(prevTarget, namespace, event, target);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgatheredTargetEvents = gatherTargetEvents(target, namespace, event);\n\t\t\t\t\t}\n\n\t\t\t\t\tObject.keys(gatheredTargetEvents).forEach(ns => {\n\t\t\t\t\t\tArray.from(gatheredTargetEvents[ns]).forEach(ev => {\n\t\t\t\t\t\t\tconst\n\t\t\t\t\t\t\t\thandlerScope = isDelegation\n\t\t\t\t\t\t\t\t\t? targetEvents[ns][ev].delegations[target]\n\t\t\t\t\t\t\t\t\t: targetEvents[ns][ev]\n\t\t\t\t\t\t\t\t,\n\t\t\t\t\t\t\t\tsyntheticEvent = isDelegation\n\t\t\t\t\t\t\t\t\t? createSyntheticEvent(ev, ns, payload, false, false, [prevTarget, target])\n\t\t\t\t\t\t\t\t\t: createSyntheticEvent(ev, ns, payload, false, false, target)\n\t\t\t\t\t\t\t;\n\n\t\t\t\t\t\t\thandlerScope.handlers.forEach(handler => {\n\t\t\t\t\t\t\t\thandler.action(syntheticEvent);\n\t\t\t\t\t\t\t\tfireCount++;\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t});\n\n\treturn fireCount;\n}\n\n\n\n/**\n * @namespace Events:emit\n */\n\n/**\n * Dispatches synthetic events on all given targets.\n *\n * In contrast to \"fire\", this function actually dispatches bubbling events on the provided EventTargets. Delegations\n * are resolved using \"querySelectorAll\". This function does not check actual handler presence using the event map, but\n * blindly emits what has been given, purely using the DOM as the event bus. Handlers defined with \"on\" and \"once\" will\n * of course still be triggered if hit, since they always also register a native event listener. The events emitted\n * are purely synthetic basic Events and CustomEvents, lacking special properties, which, for example, MouseEvents\n * provide. So, using \"screenX\" in the handler will not work. If you need a certain base class for the created events,\n * use the \"EventConstructor\" to provide the base class and add special options via \"eventOptions\".\n *\n * The definition of targets and events works almost as in \"on\" and \"once\", the only differences being, that we have no\n * handler, and we cannot leave out the event name. Using a wildcard for the namespace will leave out the namespace in\n * the created events.\n *\n * @param {EventTarget|Array<EventTarget>} targets - the target(s) to dispatch events on\n * @param {String|Array<String>} events - the event name(s) to emit, can be either a single name or a list of names, each name may also have a namespace, separated by a dot, to target all events/namespaces, you may use \"*\"/\"*.*\"\n * @param {?Object} [payload=null] - a plain object payload to relay to the event handlers via the detail of the CustomEvent given to the handler as first parameter\n * @param {?Function} [EventConstructor=null] - the default constructor is Event/CustomEvent, if you need another specific synthetic event, provide a constructor such as MouseEvent here\n * @param {?Object} [eventOptions=null] - use this plain object to provide constructor specific options to use in event construction, this should especially come in handy in case you provide a custom EventConstructor\n * @throws error in case no targets are defined\n * @throws error in case no events are defined\n * @throws error in case targets are not all usable event targets\n * @throws error in case delegations are missing viable ancestor targets\n * @returns {Number} the number of events actually dispatched by the function call, may also be 0 if nothing matched\n *\n * @memberof Events:emit\n * @alias emit\n * @see on\n * @see once\n * @see fire\n * @example\n * emit([buttonElement, ancestorElement, 'a'], 'click');\n * emit(linkElement, 'click.__default', {defaultClick: true});\n * emit([divElement, document.body], 'crash');\n * emit([ancestorElement, 'a'], 'click', {trackingId : 'abc123'});\n * emit([ancestorElement, '.btn[data-foobar=\"test\"]'], 'click.delegated');\n * emit(ancestorElement, ['crash.test', 'crash.site'], {damage : 1000});\n * emit([ancestorElement, 'a', ancestorElement, '.btn[data-foobar=\"test\"]'], 'click.delegated', null, null, {bubbles : false});\n * emit(buttonElement, 'click.*', {price : 666}, MouseEvent, {bubbles : false});\n */\nexport function emit(targets, events, payload=null, EventConstructor=null, eventOptions=null){\n\tconst __methodName__ = 'emit';\n\n\t({targets, events} = prepareEventMethodBaseParams(__methodName__, targets, events, null, true));\n\n\tlet emitCount = 0;\n\n\ttargets.forEach((target, targetIndex) => {\n\t\tconst {\n\t\t\tprevTarget,\n\t\t\thasDelegation,\n\t\t\tisDelegation\n\t\t} = prepareEventMethodAdditionalTargetInfo(__methodName__, targets, targetIndex);\n\n\t\tif( !hasDelegation ){\n\t\t\tevents.forEach(eventName => {\n\t\t\t\tconst {event, namespace} = prepareEventMethodEventInfo(eventName);\n\n\t\t\t\tassert(hasValue(event), `${MODULE_NAME}:${__methodName__} | missing event name`);\n\n\t\t\t\tif( isDelegation ){\n\t\t\t\t\tArray.from(prevTarget.querySelectorAll(target)).forEach(element => {\n\t\t\t\t\t\telement.dispatchEvent(\n\t\t\t\t\t\t\tcreateSyntheticEvent(event, namespace, payload, true, true, null, EventConstructor, eventOptions)\n\t\t\t\t\t\t);\n\t\t\t\t\t\temitCount++;\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\ttarget.dispatchEvent(\n\t\t\t\t\t\tcreateSyntheticEvent(event, namespace, payload, true, true, null, EventConstructor, eventOptions)\n\t\t\t\t\t);\n\t\t\t\t\temitCount++;\n\t\t\t\t}\n\t\t\t});\n\n\t\t}\n\t});\n\n\treturn emitCount;\n}\n\n\n\n/**\n * @namespace Events:offDetachedElements\n */\n\n/**\n * This method completely removes all handlers and listeners for provided targets in case that they\n * are actually an element and not part of the DOM (anymore).\n *\n * The most common use-case for this is to clean the event map after dynamically removing an element from the interface\n * during runtime, maybe as a reaction to a user interaction.\n *\n * Since we are overlaying the DOM event system with a separate (non-weak) event map, handlers in the map do not\n * automatically disappear if the event targets, being elements, are removed from the DOM. In that case, we have to\n * actually unregister events again, for which this is a handy little helper method.\n *\n * There are two common ways to use this:\n * 1. Just call it with the removed element, after removal of the element. This will only remove all data for that\n *    element, if it actually is an element and is not currently in the DOM.\n * 2. Call it without parameters, to iterate all current targets, check if they are elements and currently not in the\n *    DOM and remove all handlers and listeners in that case.\n *\n * So, you can either directly clean-up anything you remove or remove everything, that needs removing and do a general\n * clean-up after everything has been done.\n *\n * Be aware, that the definition of what an element is and if that element is part of the dom is defined by the actual\n * event target. So delegations are not automatically covered by this, since they rely on the ancestor element for\n * event handling.\n *\n * @param {?EventTarget|Array<EventTarget>} [targets=null] - the target(s) to remove from the event map, if not set, all event targets in the current event map are used\n * @returns {Number} the number of targets for which registered handlers and listeners have been removed\n *\n * @memberof Events:offDetachedElements\n * @alias offDetachedElements\n * @example\n * button.remove();\n * offDetachedElements(button);\n * => 1\n * link.innerText = 'test';\n * button.remove();\n * offDetachedElements([link, button]);\n * => 1\n * offDetachedElements()\n * => number of all currently registered targets, being elements and not in the dom\n */\n\nexport function offDetachedElements(targets){\n\ttargets = orDefault(targets, [], 'arr');\n\n\tif( targets.length === 0 ){\n\t\ttargets = Array.from(EVENT_MAP.keys());\n\t}\n\n\tlet offCount = 0;\n\n\ttargets.forEach(target => {\n\t\tif( isElement(target) && !document.body.contains(target) && EVENT_MAP.has(target) ){\n\t\t\toffCount++;\n\t\t\toff(target, '*');\n\t\t}\n\t});\n\n\treturn offCount;\n}\n\n\n\n/**\n * @namespace Events:onSwipe\n */\n\n/**\n * Defines a handler for a swipe gesture on (an) element(s).\n * Offers four swipe directions (up/right/down/left), where triggering the handler depends on the distance\n * between touchstart and touchend in relation to the element's width or height, depending on the direction,\n * multiplied by a factor to express a percentage.\n *\n * You may also set this method to also fire upon mouse swipes, by setting \"hasToBeTouchDevice\" to false.\n *\n * @param {EventTarget|Array<EventTarget>} targets - the target(s) to register event handlers on\n * @param {String} direction - the direction to bind => up/down/left/right\n * @param {Function} handler - the callback to execute if the event(s) defined in events are being received on target\n * @param {?Number} [dimensionFactor=0.2] - to determine what registers as a swipe we use a percentage of the element's width/height, the touch has to move, default is 20%\n * @param {?Boolean} [hasToBeTouchDevice=true] - if true, makes sure the handlers are only active on touch devices, if false, also reacts to mouse swipes\n * @param {?String} [eventNameSpace='annex-swipe'] - apply an event namespace, which identifies specific events, helpful for a specific unbind later using the same namespace\n * @throws error in case no targets are defined\n * @throws error in case unknown direction is defined\n * @throws error in case handler is not a function\n * @throws error in case targets are not all usable event targets\n * @throws error in case delegations are missing viable ancestor targets\n * @returns {Function} remover function, which removes all handlers again, added by the current execution\n *\n * @memberof Events:onSwipe\n * @alias onSwipe\n * @see offSwipe\n * @example\n * onSwipe(slider, 'up', e => { e.currentTarget.fadeOut(); });\n * onSwipe(slider, 'right', () => { document.body.dispatchEvent(new CustomEvent('load-previous-thing')); }, 0.15, false, 'foobar-prev');\n */\nexport function onSwipe(targets, direction, handler, dimensionFactor=0.2, hasToBeTouchDevice=true, eventNameSpace='annex-swipe'){\n\tconst __methodName__ = 'onSwipe';\n\n\tdirection = orDefault(direction, '', 'str');\n\tdimensionFactor = orDefault(dimensionFactor, 0.2, 'float');\n\thasToBeTouchDevice = orDefault(hasToBeTouchDevice, true, 'bool');\n\teventNameSpace = orDefault(eventNameSpace, 'annex-swipe', 'str');\n\n\tassert(SWIPE_DIRECTIONS.includes(direction), `${MODULE_NAME}:${__methodName__} | unknown direction \"${direction}\"`);\n\n\tlet events = [`touchstart.${eventNameSpace}-${direction}`, `touchend.${eventNameSpace}-${direction}`];\n\tif( !hasToBeTouchDevice ){\n\t\tevents.push(`mousedown.${eventNameSpace}-${direction}`);\n\t\tevents.push(`mouseup.${eventNameSpace}-${direction}`);\n\t}\n\n\t({targets, events, handler} = prepareEventMethodBaseParams(__methodName__, targets, events, handler));\n\n\tconst originalHandler = handler;\n\thandler = (hasToBeTouchDevice && (detectInteractionType() !== 'touch')) ? () => {} : originalHandler;\n\tconst swipeHandler = SWIPE_HANDLERS.get(originalHandler) ?? (e => {\n\t\tupdateSwipeTouch(e);\n\n\t\tif( ['touchend', 'mouseup'].includes(e.type) ){\n\t\t\tconst\n\t\t\t\twidth = e.currentTarget.offsetWidth,\n\t\t\t\theight = e.currentTarget.offsetHeight\n\t\t\t;\n\n\t\t\tif(\n\t\t\t\t(!hasToBeTouchDevice || (detectInteractionType() === 'touch'))\n\t\t\t\t&& (\n\t\t\t\t\t((direction === 'up') && (SWIPE_TOUCH.startY > (SWIPE_TOUCH.endY + height * dimensionFactor)))\n\t\t\t\t\t|| ((direction === 'right') && (SWIPE_TOUCH.startX < (SWIPE_TOUCH.endX - width * dimensionFactor)))\n\t\t\t\t\t|| ((direction === 'down') && (SWIPE_TOUCH.startY < (SWIPE_TOUCH.endY - height * dimensionFactor)))\n\t\t\t\t\t|| ((direction === 'left') && (SWIPE_TOUCH.startX > (SWIPE_TOUCH.endX + width * dimensionFactor)))\n\t\t\t\t)\n\t\t\t){\n\t\t\t\thandler(e);\n\t\t\t}\n\t\t}\n\t});\n\tSWIPE_HANDLERS.set(originalHandler, swipeHandler);\n\n\treturn on(targets, events, swipeHandler);\n}\n\n\n\n/**\n * @namespace Events:offSwipe\n */\n\n/**\n * Removes (a) handler(s) for a swipe gesture from (an) element(s).\n *\n * Normally all directions are removed individually, but if you leave out `direction` all directions are removed at once.\n *\n * @param {EventTarget|Array<EventTarget>} targets - the target(s) to remove event handlers from\n * @param {?String} [direction=null] - the direction to remove => up/down/left/right, if empty, all directions are removed\n * @param {?Function} [handler=null] - a specific callback function to remove\n * @param {?String} [eventNameSpace='annex-swipe'] - event namespace to remove\n * @throws error in case no targets are defined\n * @throws error in case unknown direction is defined\n * @throws error in case a defined handler is not a function\n * @throws error in case targets are not all usable event targets\n * @throws error in case delegations are missing viable ancestor targets\n * @returns {Number} the number of handlers actually removed by the function call, may also be 0 if nothing matched\n *\n * @memberof Events:offSwipe\n * @alias offSwipe\n * @see onSwipe\n * @example\n * offSwipe(slider, 'right');\n * offSwipe(slider, 'left', fSpecialHandler, 'foobar-prev');\n * offSwipe(slider);\n */\nexport function offSwipe(targets, direction=null, handler=null, eventNameSpace='annex-swipe'){\n\tconst __methodName__ = 'offSwipe';\n\n\tdirection = orDefault(direction, '', 'str');\n\teventNameSpace = orDefault(eventNameSpace, 'annex-swipe', 'str');\n\n\tassert(SWIPE_DIRECTIONS.concat('').includes(direction), `${MODULE_NAME}:${__methodName__} | unknown direction \"${direction}\"`);\n\n\tconst directions = (direction === '') ? SWIPE_DIRECTIONS : [direction];\n\tlet removedCount = 0;\n\n\tdirections.forEach(direction => {\n\t\tlet events = [\n\t\t\t`touchstart.${eventNameSpace}-${direction}`,\n\t\t\t`touchend.${eventNameSpace}-${direction}`,\n\t\t\t`mousedown.${eventNameSpace}-${direction}`,\n\t\t\t`mouseup.${eventNameSpace}-${direction}`\n\t\t];\n\n\t\t({targets, events, handler} = prepareEventMethodBaseParams(__methodName__, targets, events, handler, true));\n\n\t\tif( hasValue(handler) ){\n\t\t\tconst swipeHandler = SWIPE_HANDLERS.get(handler);\n\t\t\tif( hasValue(swipeHandler) ){\n\t\t\t\tremovedCount += off(targets, events, swipeHandler);\n\t\t\t}\n\t\t} else {\n\t\t\tremovedCount += off(targets, events);\n\t\t}\n\t});\n\n\treturn removedCount;\n}\n\n\n\n/**\n * @namespace Events:onDomReady\n */\n\n/**\n * Executes a callback on document ready (DOM parsed, complete and usable, not loaded/onload).\n *\n * @param {Function} callback - function to execute, once document is parsed and ready\n *\n * @memberof Events:onDomReady\n * @alias onDomReady\n * @example\n * onDomReady(() => {\n *     document.body.classList.add('dom-ready');\n * });\n */\nexport function onDomReady(callback){\n\tif( document.readyState !== 'loading' ){\n\t\tcallback();\n\t} else {\n\t\tconst wrappedCallback = () => {\n\t\t\tdocument.removeEventListener('DOMContentLoaded', wrappedCallback);\n\t\t\tcallback();\n\t\t};\n\t\tdocument.addEventListener('DOMContentLoaded', wrappedCallback);\n\t}\n}\n\n\n\n/**\n * @namespace Events:onPostMessage\n */\n\n/**\n * Register an event handler for a post message on a valid target, like a window or an iframe.\n *\n * The handler will only be executed, if the messageType as well as the origin match. The messageType must be\n * part of the payload, using the key \"type\", which `emitPostMessage` does automatically.\n *\n * Putting the origin as an obligatory parameter at the second place, is deliberate by design, to force everyone\n * to really think about, what to use here. Usually, most people, just throw in the \"*\" wildcard, paying no attention\n * to the security implications. Please really think about what to use here.\n *\n * A word of advice: keep in mind, that, contrary to most other events in javascript, post messages actually work\n * asynchronously (so you cannot be sure, that the handler has been executed, directly after a post message has been\n * sent) and that messages/payload are not transferred as-is, but are cloned, using the \"structured clone algorithm\",\n * which means, that not every javascript object is transferable without losses.\n *\n * @param {Window|HTMLIFrameElement} target - window/iframe to register the handler to (iframes are automatically resolved to the contentWindow)\n * @param {String} origin - the origin the received post message has to have, for the handler to get executed (defaults to \"*\", if receiving a nullish value)\n * @param {String} messageType - the type/name the post message has to have, for the handler to get executed (will be checked using the key \"type\" in the message's payload)\n * @param {Function} handler - the handler to execute, if a post message, matching all conditions, is received\n * @throws error if target is not usable\n * @return a function, which, if executed, removes everything registered by the current call\n *\n * @memberof Events:onPostMessage\n * @alias onPostMessage\n * @see offPostMessage\n * @see emitPostMessage\n * @see https://developer.mozilla.org/en-US/docs/Glossary/Origin\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm\n * @example\n * const removeAgainFunction = onPostMessage(window, '*', 'foobar-message', () => { doSomething(); });\n * onPostMessage(iframeElement, 'https://foobar.com:80/', 'foobar-message', e => { resizeIframe(e.data.payload.height); });\n */\nexport function onPostMessage(target, origin, messageType, handler){\n\tconst __methodName__ = 'onPostMessage';\n\n\ttarget = resolvePostMessageTarget(target, __methodName__);\n\torigin = orDefault(origin, '*', 'str');\n\tmessageType = `${messageType}`;\n\n\tassert(isFunction(handler), `${MODULE_NAME}:${__methodName__} | handler is not a function`);\n\n\tif( !hasValue(POST_MESSAGE_MAP.get(target)) ){\n\t\tPOST_MESSAGE_MAP.set(target, {});\n\t\ttarget.addEventListener('message', windowPostMessageHandler);\n\t}\n\n\tconst targetPostMessages = POST_MESSAGE_MAP.get(target);\n\tif( !hasValue(targetPostMessages[messageType]) ){\n\t\ttargetPostMessages[messageType] = [];\n\t}\n\n\ttargetPostMessages[messageType].push({handler, origin});\n\n\treturn () => { offPostMessage(target, origin, messageType, handler); };\n}\n\n\n\n/**\n * @namespace Events:offPostMessage\n */\n\n/**\n * Unregister (an) event handler(s) for (a) post message(s) on a valid target, like a window or an iframe.\n *\n * Similar to `off`, this function can handle rather unspecific cases as well as very specific definitions.\n * Just setting the target, removes all registrations for that target. Setting an `origin` and/or a `messageType`\n * additionally, only removes handlers, that were registered explicitly for these values. Adding a handler only\n * removes that specific handler (without origin and/or messageType, the handler is removed everywhere).\n *\n * Putting the origin parameter at the second place, is deliberate by design, to force everyone to really think about,\n * what to use here. Usually, most people, just throw in the \"*\" wildcard, paying no attention to the security\n * implications, when setting a post message handler. Since we force this on `onPostMessage`, we keep the signature\n * here as well, just making everything except target optional.\n *\n * If you try to remove event handlers not previously created with `onPostMessage` (and therefore there are no fitting\n * target entries in the POST_MESSAGE_MAP), the function will fall back to native `removeEventListener`\n * (if `tryNativeRemoval` is true), but in that case, a handler has to be defined and the return value will not\n * increment, since we do not know if the removal really worked.\n *\n * @param {Window|HTMLIFrameElement} target - window/iframe to remove handler(s) from (iframes are automatically resolved to the contentWindow)\n * @param {?String} [origin=null] - the origin the received post message has to have, for the handler to get executed (defaults to \"*\", if receiving a nullish value)\n * @param {?String} [messageType=null] - the type/name the post message has to have, for the handler to get executed (will be checked using the key \"type\" in the message's payload)\n * @param {?Function} [handler=null] - the handler to execute, if a post message, matching all conditions, is received\n * @param {?Boolean} [tryNativeRemoval=true] - if a target is not part of the POST_MESSAGE_MAP native removeEventListener is used as a fallback if this is true (handler needs to be set in that case)\n * @throws error if target is not usable\n * @return the number of actually removed handlers, that matched the conditions\n *\n * @memberof Events:offPostMessage\n * @alias offPostMessage\n * @see onPostMessage\n * @see emitPostMessage\n * @see https://developer.mozilla.org/en-US/docs/Glossary/Origin\n * @example\n * const offCount = offPostMessage(window, 'https://foobar.com:80/', 'foobar-message');\n * offPostMessage(window, null, null, specialHandlerFunction);\n */\nexport function offPostMessage(target, origin=null, messageType=null, handler=null, tryNativeRemoval=true){\n\tconst __methodName__ = 'offPostMessage';\n\n\ttarget = resolvePostMessageTarget(target, __methodName__);\n\torigin = orDefault(origin, null, 'str');\n\tmessageType = orDefault(messageType, null, 'str');\n\ttryNativeRemoval = orDefault(tryNativeRemoval, true, 'bool');\n\n\tif( hasValue(handler) ){\n\t\tassert(isFunction(handler), `${MODULE_NAME}:${__methodName__} | handler is not a function`);\n\t}\n\n\tlet removedCount = 0;\n\n\tconst targetPostMessages = POST_MESSAGE_MAP.get(target);\n\tif( hasValue(targetPostMessages) ){\n\t\tconst messageTypes = hasValue(messageType) ? [messageType] : Object.keys(targetPostMessages);\n\t\tmessageTypes.forEach(messageType => {\n\t\t\tremovedCount += removePostMessageHandlers(targetPostMessages, messageType, origin, handler);\n\t\t});\n\n\t\tif( Object.keys(targetPostMessages).length === 0 ){\n\t\t\tPOST_MESSAGE_MAP.delete(target);\n\t\t}\n\t} else if( tryNativeRemoval ){\n\t\tif( hasValue(handler) ){\n\t\t\ttarget.removeEventListener('message', handler);\n\t\t} else {\n\t\t\twarn(`${MODULE_NAME}:${__methodName__} | native fallback event removal for \"${messageType}\" not possible, handler is missing`);\n\t\t}\n\t}\n\n\tif( !hasValue(POST_MESSAGE_MAP.get(target)) ){\n\t\ttarget.removeEventListener('message', windowPostMessageHandler);\n\t}\n\n\treturn removedCount;\n}\n\n\n\n/**\n * @namespace Events:emitPostMessage\n */\n\n/**\n * Emit/dispatch a post message on a valid target, like a window or an iframe.\n *\n * Putting the origin as an obligatory parameter at the second place, is deliberate by design, to force everyone\n * to really think about, what to use here. Usually, most people, just throw in the \"*\" wildcard, paying no attention\n * to the security implications. Please really think about what to use here.\n *\n * This function adds the `messageType` automatically to the message/payload using the key `type`. `onPostMessage` will\n * use that information additionally to the `origin` to determine if a registration fits the occurred event. The\n * `payload` will be placed in the message using the key `payload`. So `e.data` will look like this in the\n * handler at the end: `{type : messageType, payload : {...payload}}`\n *\n * A word of advice: keep in mind, that, contrary to most other events in javascript, post messages actually work\n * asynchronously (so you cannot be sure, that the handler has been executed, directly after a post message has been\n * sent) and that messages/payload are not transferred as-is, but are cloned, using the \"structured clone algorithm\",\n * which means, that not every javascript object is transferable without losses.\n *\n * @param {Window|HTMLIFrameElement} target - window/iframe to receive the post message (iframes are automatically resolved to the contentWindow)\n * @param {String} origin - the origin the current context has to have, to actually send the post message the received post message has to have, this does NOT set the origin! (defaults to \"*\", if receiving a nullish value)\n * @param {String} messageType - the type/name of the post message (will be checked using the key \"type\" in the message's payload, which will automatically be set using this function)\n * @param {?*} [payload=null] - a payload to add to the message under the key \"payload\"\n * @throws error if target is not usable\n * @return the resolved target of the post message\n *\n * @memberof Events:emitPostMessage\n * @alias emitPostMessage\n * @see onPostMessage\n * @see offPostMessage\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage\n * @see https://developer.mozilla.org/en-US/docs/Glossary/Origin\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm\n * @example\n * emitPostMessage(window, '*', 'foobar-message', {timestamp : new Date()});\n * emitPostMessage(iframeElement, 'https://foobar.com:80/', 'foobar-message');\n */\nexport function emitPostMessage(target, origin, messageType, payload=null){\n\tconst __methodName__ = 'emitPostMessage';\n\n\ttarget = resolvePostMessageTarget(target, __methodName__);\n\torigin = orDefault(origin, '*', 'str');\n\tmessageType = `${messageType}`;\n\n\tconst message = {type : messageType};\n\tif( hasValue(payload) ){\n\t\tmessage.payload = payload;\n\t}\n\n\ttarget.postMessage(message, origin);\n\n\treturn target;\n}\n"]}
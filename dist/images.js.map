{"version":3,"file":"images.js","names":["MODULE_NAME","orDefault","isA","isPlainObject","assert","isEmpty","hasValue","Deferred","waitForRepaint","PRELOADED_IMAGES","unnamed","named","preload","images","preloadedImages","deferred","newImages","Object","entries","forEach","key","value","Image","src","push","newImage","Array","from","Set","concat","provision","length","loaded","then","resolve","catch","reject","dimensionsNeeded","__methodName__","name","onLoad","e","image","currentTarget","naturalWidth","loadCount","map","removeEventListener","onError","loaderImages","error","filter","prototype","toString","call","slice","toLowerCase","addEventListener","parent","parentNode","isPicture","nodeName","complete","img","window","respimage","elements","querySelector","picturefill"],"sources":["images.js"],"mappings":"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","sourcesContent":["/*!\n * Module Images\n */\n\n/**\n * @namespace Images\n */\n\nconst MODULE_NAME = 'Images';\n\n\n\n//###[ IMPORTS ]########################################################################################################\n\nimport {orDefault, isA, isPlainObject, assert, isEmpty, hasValue, Deferred} from './basic.js';\nimport {waitForRepaint} from './timers.js';\n\n\n\n//###[ DATA ]###########################################################################################################\n\nconst PRELOADED_IMAGES = {\n\tunnamed : [],\n\tnamed : {}\n};\n\n\n\n//###[ EXPORTS ]########################################################################################################\n\n/**\n * @namespace Images:preload\n */\n\n/**\n * Preloads images by URL, so that subsequent usages are served from browser cache.\n * Images can be preloaded anonymously or with a given name. So you can either just use the url again,\n * or, to be super-sure, call the method again, with just the image name to get the preloaded image itself.\n *\n * The function returns a Deferred, which resolves, after the images have loaded, with either an array of preloaded\n * images or a single image, if only one has been defined. The Deferred contains all images newly created for\n * preloading on the provision property before the Deferred resolves.\n *\n * @param {(String|String[]|Object.<String, String>)} images - a URL, an array of URLs or a plain object containing named URLs. In case the string is an already used name, the image object from the named preloaded images cache is returned.\n * @returns {Deferred<Image|Image[]>|Image} either a Deferred, resolving after images are preloaded, or a requested cached image\n *\n * @memberof Images:preload\n * @alias preload\n * @example\n * preload([url1, url2, url3]).then(images => { alert(`loaded ${images.length} images`); });\n * const provisionalImage preload({name1 : url1, name2 : url2}}).provision.name1;\n * const preloadedImage = preload('name1');\n */\nexport function preload(images){\n\tconst\n\t\tpreloadedImages = [],\n\t\tdeferred = new Deferred()\n\t;\n\tlet newImages;\n\n\tif( !isPlainObject(images) && !isA(images, 'array') ){\n\t\timages = `${images}`;\n\n\t\tif( hasValue(PRELOADED_IMAGES.named[images]) ){\n\t\t\treturn PRELOADED_IMAGES.named[images];\n\t\t} else {\n\t\t\timages = [images];\n\t\t}\n\t}\n\n\tif( isPlainObject(images) ){\n\t\tnewImages = {};\n\n\t\tObject.entries(images).forEach(([key, value]) => {\n\t\t\tkey = `${key}`;\n\t\t\tvalue = `${value}`;\n\n\t\t\tif( !hasValue(PRELOADED_IMAGES.named[key]) ){\n\t\t\t\tnewImages[key] = new Image();\n\t\t\t\tnewImages[key].src = value;\n\t\t\t\tpreloadedImages.push(newImages[key]);\n\t\t\t}\n\t\t});\n\n\t\tPRELOADED_IMAGES.named = {...PRELOADED_IMAGES.named, ...newImages};\n\t} else if( isA(images, 'array') ){\n\t\tnewImages = [];\n\n\t\timages.forEach(value => {\n\t\t\tconst newImage = new Image();\n\t\t\tnewImage.src = `${value}`;\n\t\t\tnewImages.push(newImage);\n\t\t\tpreloadedImages.push(newImage);\n\t\t});\n\n\t\tPRELOADED_IMAGES.unnamed = Array.from(new Set(PRELOADED_IMAGES.unnamed.concat(newImages)));\n\t}\n\n\tdeferred.provision = (isA(newImages, 'array') && (newImages.length === 1)) ? newImages[0] : newImages;\n\tloaded(preloadedImages)\n\t\t.then(deferred.resolve)\n\t\t.catch(deferred.reject)\n\t;\n\n\treturn deferred;\n}\n\n\n\n/**\n * @namespace Images:loaded\n **/\n\n/**\n * Fixes problems with image \"load\" events and fires the event even in case the image is already loaded or served from\n * browser cache. So repeated calls to this method on the same loaded image will actually work.\n *\n * Also supports imgs inside picture elements, while automatically handling the polyfills respimage and picturefill if\n * present in window. Make sure to apply this method to the img _inside_ the picture and _not_ on the picture itself!\n *\n * Define \"dimensionsNeeded\" if your definition of \"loaded\" includes, that the loaded image should already have usable\n * image dimensions for layouting. Use this, if you need to do calculations based on image dimensions after load.\n * Dimensions are determined using the images \"naturalWidth\".\n *\n * The function returns a Deferred, which resolves, after the images have loaded, with either an array of loaded\n * images or a single image, if only one has been defined. The Deferred contains all initially given images on the\n * provision property before the Deferred resolves.\n *\n * @param {Image|Array<Image>} images - an image or an array of images\n * @param {?Boolean} [dimensionsNeeded=false] - tells the check if we expect the loaded image to have readable dimensions\n * @returns {Deferred<Image|Image[]>} a Deferred, resolving after all given images have loaded\n *\n * @memberof Images:loaded\n * @alias loaded\n * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/naturalWidth\n * @example\n * onLoad(image).then(image => { image.classList.remove('hidden'); });\n * onLoad([image1, image2, image3]).then(images => { alert(`all ${images.length} images have loaded`); })\n */\nexport function loaded(images, dimensionsNeeded=false){\n\tconst __methodName__ = loaded.name;\n\n\timages = orDefault(images, [], 'arr').filter(image => {\n\t\treturn Object.prototype.toString.call(image).slice(8, -1).toLowerCase() === 'htmlimageelement';\n\t});\n\tdimensionsNeeded = orDefault(dimensionsNeeded, false, 'bool');\n\n\tfunction onLoad(e){\n\t\tconst image = e.currentTarget;\n\t\tif( !dimensionsNeeded || (dimensionsNeeded && (image.naturalWidth > 0)) ){\n\t\t\tloadCount--;\n\t\t\tif( loadCount <= 0 ){\n\t\t\t\timages.map(image => {\n\t\t\t\t\timage.removeEventListener('load', onLoad);\n\t\t\t\t\timage.removeEventListener('error', onError);\n\t\t\t\t});\n\t\t\t\tloaderImages.map(image => {\n\t\t\t\t\timage.removeEventListener('load', onLoad);\n\t\t\t\t\timage.removeEventListener('error', onError);\n\t\t\t\t});\n\t\t\t\tdeferred.resolve((images.length === 1) ? images[0] : images);\n\t\t\t}\n\t\t} else {\n\t\t\twaitForRepaint(() => { onLoad(e); });\n\t\t}\n\t}\n\n\tfunction onError(error){\n\t\timages.map(image => {\n\t\t\timage.removeEventListener('load', onLoad);\n\t\t\timage.removeEventListener('error', onError);\n\t\t});\n\t\tloaderImages.map(image => {\n\t\t\timage.removeEventListener('load', onLoad);\n\t\t\timage.removeEventListener('error', onError);\n\t\t});\n\t\tdeferred.reject(error);\n\t}\n\n\tconst\n\t\tdeferred = new Deferred(),\n\t\tloaderImages = []\n\t;\n\tlet loadCount = images.length;\n\n\tdeferred.provision = (images.length === 1) ? images[0] : images;\n\timages.forEach(image => {\n\t\timage.removeEventListener('load', onLoad);\n\t\timage.addEventListener('load', onLoad);\n\t\timage.removeEventListener('error', onError);\n\t\timage.addEventListener('error', onError);\n\n\t\tconst\n\t\t\tsrc = image.src,\n\t\t\tparent = image.parentNode,\n\t\t\tisPicture = isA(image.parentNode, 'htmlelement') ? (parent.nodeName.toLowerCase() === 'picture') : false\n\t\t;\n\n\t\tassert(!isEmpty(src), `${MODULE_NAME}:${__methodName__} | image has no src`);\n\n\t\tif( isPicture || !!image.complete ){\n\t\t\tlet img;\n\n\t\t\tif( isPicture ){\n\t\t\t\tif( window.respimage ){\n\t\t\t\t\twindow.respimage({elements : [parent]});\n\t\t\t\t\timg = parent.querySelector('img');\n\t\t\t\t} else if( window.picturefill ){\n\t\t\t\t\twindow.picturefill({elements : [parent]});\n\t\t\t\t\timg = parent.querySelector('img');\n\t\t\t\t} else {\n\t\t\t\t\timg = image;\n\t\t\t\t}\n\n\t\t\t\tif( !!img.complete ){\n\t\t\t\t\timg = new Image();\n\t\t\t\t\timg.addEventListener('load', onLoad);\n\t\t\t\t\timg.addEventListener('error', onError);\n\t\t\t\t\timg.src = src;\n\t\t\t\t\tloaderImages.push(img);\n\t\t\t\t} else {\n\t\t\t\t\timg.removeEventListener('load', onLoad);\n\t\t\t\t\timg.addEventListener('load', onLoad);\n\t\t\t\t\timg.removeEventListener('error', onError);\n\t\t\t\t\timg.addEventListener('error', onError);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\timg = new Image();\n\t\t\t\timg.addEventListener('load', onLoad);\n\t\t\t\timg.addEventListener('error', onError);\n\t\t\t\timg.src = src;\n\t\t\t\tloaderImages.push(img);\n\t\t\t}\n\t\t}\n\t});\n\n\treturn deferred;\n}\n"]}
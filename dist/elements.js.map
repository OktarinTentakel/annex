{"version":3,"file":"elements.js","names":["MODULE_NAME","orDefault","isA","isPlainObject","hasValue","assert","size","NOT_AN_HTMLELEMENT_ERROR","createNode","tag","attributes","content","trim","outerNode","document","createElement","test","innerHTML","appendChild","node","firstChild","removeChild","attribute","setAttribute","textContent","insertNode","target","position","insertAdjacentElement","replaceNode","__methodName__","parentNode","getTextContent","onlyFirstLevel","childNodes","forEach","nodeType","isInDom","contains","body","getData","properties","data","property","attributeValue","getAttribute","JSON","parse","ex","Array","from","name","startsWith","replace","value","length","setData","dataSet","singleValue","singleKey","appliedValues","Object","entries","undefined","stringifiedValue","getValue","stringify","hasAttribute","removeAttribute","removeData","keys","reduce","removalDataSet"],"sources":["elements.js"],"mappings":"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","sourcesContent":["/*!\n * Module Elements\n */\n\n/**\n * @namespace Elements\n */\n\nconst MODULE_NAME = 'Elements';\n\n\n\n//###[ IMPORTS ]########################################################################################################\n\nimport {orDefault, isA, isPlainObject, hasValue, assert, size} from './basic.js';\n\n\n\n//###[ DATA ]###########################################################################################################\n\nconst NOT_AN_HTMLELEMENT_ERROR = 'given node/target is not an HTMLElement';\n\n\n\n//###[ EXPORTS ]########################################################################################################\n\n/**\n * @namespace Elements:createNode\n */\n\n/**\n * Creates an element on the fly programmatically, based on provided name, attributes and content or markup,\n * without inserting it into the DOM.\n *\n * If you provide markup as \"tag\", make sure that there is one single root element, this method returns exactly one\n * element, not a NodeList. Also be sure to _not_ just pass HTML source from an unsecure source, since this\n * method does not deal with potential security risks.\n *\n * One thing about dynamically creating script tags with this: if you want the script is javascript and you want to\n * actually execute the script upon adding it to the dom, you cannot provide the complete tag as a source string,\n * since scripts created with innerHTML will not execute.\n * (see: https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML#security_considerations)\n * Instead, just provide the tag name and define attributes and source via the parameters instead.\n *\n * @param {?String} [tag='span'] - tag of the element to create or markup for root element\n * @param {?Object} [attributes=null] - tag attributes as key/value-pairs, will also be added to provided markup\n * @param {?String} [content=null] - content to insert into the element as textContent, be aware, that this will replace other content in provided markup\n * @returns {HTMLElement} the created DOM-node\n *\n * @memberof Elements:createNode\n * @alias createNode\n * @example\n * document.body.appendChild(\n *   createNode('div', {id : 'content', style : 'display:none;'}, 'loading...')\n * );\n * document.body.appendChild(\n *   createNode('<div id=\"content\" style=\"display:none;\">loading...</div>')\n * );\n * document.body.appendChild(\n *   createNode('script', {type : 'text/javascript'}, 'alert(\"Hello World\");');\n * );\n */\nexport function createNode(tag, attributes=null, content=null){\n\ttag = orDefault(tag, 'span', 'str').trim();\n\tattributes = isPlainObject(attributes) ? attributes : null;\n\tcontent = orDefault(content, null, 'str');\n\n\t// using anything more generic like template results in non-standard nodes like\n\t// <script type=\"text/json\"> not being creatable\n\tconst outerNode = document.createElement('div');\n\n\tif(\n\t\t/^<[^\\/][^<>]*>/.test(tag)\n\t\t&& /<\\/[^<>\\/]+>$/.test(tag)\n\t){\n\t\t// using DOMParser results in non-standard nodes like\n\t\t// <script type=\"text/json\"> not being creatable\n\t\touterNode.innerHTML = tag;\n\t} else {\n\t\touterNode.appendChild(document.createElement(tag));\n\t}\n\n\tconst node = outerNode.firstChild;\n\touterNode.removeChild(node);\n\n\tif( hasValue(attributes) ){\n\t\tfor( let attribute in attributes ){\n\t\t\tnode.setAttribute(attribute, `${attributes[attribute]}`);\n\t\t}\n\t}\n\n\tif( hasValue(content) ){\n\t\tnode.textContent = content;\n\t}\n\n\treturn node;\n}\n\n\n\n/**\n * @namespace Elements:insertNode\n */\n\n/**\n * Inserts a node into the DOM in relation to a target element.\n *\n * If the node is not an element, the parameter is treated as source and a node is created\n * automatically based on that.\n *\n * The position can be determined with the same values as in \"insertAdjacentElement\"\n * (see: https://developer.mozilla.org/en-US/docs/Web/API/Element/insertAdjacentElement),\n * but we also added the more intuitive jQuery aliases for positions:\n *\n * - \"beforebegin\" can also be described as \"before\"\n * - \"afterbegin\" can also be described as \"prepend\"\n * - \"beforeend\" can also be described as \"append\"\n * - \"afterend\" can also be descrived as \"after\"\n *\n * @param {HTMLElement} target - the element to which the node will be inserted in relation to\n * @param {HTMLElement|String} node - the node to insert, either as element or source string\n * @param {?String} [position='beforeend'] - the position to insert the node in relation to target, the default value appends the node as the last child in target\n * @throws error if target is not an HTMLElement\n * @returns {HTMLElement} the inserted DOM-node\n *\n * @memberof Elements:insertNode\n * @alias insertNode\n * @example\n * insertNode(document.querySelector('.list-container'), listItemElement);\n * insertNode(document.querySelector('.list-container'), '<li>Item 42</li>', 'prepend');\n */\nexport function insertNode(target, node, position='beforeend'){\n\tconst __methodName__ = 'insertNode';\n\n\tassert(isA(target, 'htmlelement'), `${MODULE_NAME}.${__methodName__} | ${NOT_AN_HTMLELEMENT_ERROR}`);\n\n\tif( !isA(node, 'htmlelement') ){\n\t\tnode = createNode(`${node}`);\n\t}\n\n\tswitch( position ){\n\t\tcase 'beforebegin':\n\t\tcase 'before':\n\t\t\tposition = 'beforebegin';\n\t\tbreak;\n\t\tcase 'afterend':\n\t\tcase 'after':\n\t\t\tposition = 'afterend';\n\t\tbreak;\n\t\tcase 'afterbegin':\n\t\tcase 'prepend':\n\t\t\tposition = 'afterbegin';\n\t\tbreak;\n\t\tcase 'beforeend':\n\t\tcase 'append':\n\t\t\tposition = 'beforeend';\n\t\tbreak;\n\t\tdefault:\n\t\t\tposition = 'beforeend';\n\t\tbreak;\n\t}\n\n\ttarget.insertAdjacentElement(position, node);\n\n\treturn node;\n}\n\n\n\n/**\n * @namespace Elements:replaceNode\n */\n\n/**\n * Replaces a node with another one.\n *\n * If the node is not an element, the parameter is treated as source and a node is created\n * automatically based on that.\n *\n * The target node needs a parent node for this function to work.\n *\n * @param {HTMLElement} target - the element to replace\n * @param {HTMLElement|String} node - the node to replace the target with\n * @throws error if target is not an HTMLElement or does not have a parent\n * @returns {HTMLElement} the replacement node\n *\n * @memberof Elements:replaceNode\n * @alias replaceNode\n * @example\n * replaceNode(document.querySelector('.hint'), newHintElement);\n * replaceNode(document.querySelector('.hint'), '<p class=\"hint\">Sale tomorrow!</p>');\n */\nexport function replaceNode(target, node){\n\tconst __methodName__ = 'replaceNode';\n\n\tassert(isA(target, 'htmlelement'), `${MODULE_NAME}.${__methodName__} | ${NOT_AN_HTMLELEMENT_ERROR}`);\n\n\tif( !isA(node, 'htmlelement') ){\n\t\tnode = createNode(`${node}`);\n\t}\n\n\tassert(isA(target.parentNode, 'htmlelement'), `${MODULE_NAME}.${__methodName__} | given target does not have a parent)`);\n\n\tinsertNode(target, node, 'after');\n\ttarget.parentNode.removeChild(target);\n\n\treturn node;\n}\n\n\n\n/**\n * @namespace Elements:getTextContent\n */\n\n/**\n * Return the de-nodified text content of a node-ridden string or a DOM-node.\n * Returns the raw text content, with all markup cleanly removed.\n * Can also be used to return only the concatenated child text nodes.\n *\n * @param {(String|Node)} target - the node-ridden string or DOM-node to \"clean\"\n * @param {?Boolean} [onlyFirstLevel=false] - true if only the text of direct child text nodes is to be returned\n * @throws error if target is neither markup nor node\n * @returns {String} the text content of the provided markup or node\n *\n * @memberof Elements:getTextContent\n * @alias getTextContent\n * @example\n * someElement.textContent = getTextContent('<p onlick=\"destroyWorld();\">red button <a>meow<span>woof</span></a></p>');\n */\nexport function getTextContent(target, onlyFirstLevel=false){\n\tconst __methodName__ = 'getTextContent';\n\n\tonlyFirstLevel = orDefault(onlyFirstLevel, false, 'bool');\n\n\tif( isA(target, 'string') ){\n\t\ttarget = createNode(target);\n\t}\n\n\tassert(isA(target, 'htmlelement'), `${MODULE_NAME}:${__methodName__} | target is neither node nor markup`);\n\n\tif( onlyFirstLevel ){\n\t\tlet textContent = '';\n\n\t\ttarget.childNodes.forEach(node => {\n\t\t\tif( node.nodeType === 3 ){\n\t\t\t\ttextContent += node.textContent;\n\t\t\t}\n\t\t});\n\n\t\treturn textContent;\n\t} else {\n\t\treturn target.textContent;\n\t}\n}\n\n\n\n/**\n * @namespace Elements:isInDom\n */\n\n/**\n * Returns if an element is currently part of the DOM or in a detached state.\n *\n * @param {HTMLElement} node - the element to check, whether it is currently in the dom or detached\n * @throws error if node is not a usable HTML element\n * @returns {Boolean} true if the element is part of the DOM at the moment\n *\n * @memberof Elements:isInDom\n * @alias isInDom\n * @example\n * if( !isInDom(el) ){\n *     elementMetaInformation.delete(el);\n * }\n */\nexport function isInDom(node){\n\tconst __methodName__ = 'isInDom';\n\n\tassert(isA(node, 'htmlelement'), `${MODULE_NAME}:${__methodName__} | ${NOT_AN_HTMLELEMENT_ERROR}`);\n\n\treturn isA(document.contains, 'function') ? document.contains(node) : document.body.contains(node);\n}\n\n\n\n/**\n * @namespace Elements:getData\n */\n\n/**\n * Returns the element's currently set data attribute value(s).\n *\n * This method has two major differences from the standard browser dataset-implementations:\n * 1. Property names are _not_ handled camel-cased in any way.\n *    The data attribute `data-my-naughty-dog` property does _not_ magically become `myNaughtyDog` on access,\n *    but keeps the original notation, just losing the prefix, so access it, by using `my-naughty-dog`\n * 2. All property values are treated as JSON first and foremost, falling back to string values, if the\n *    value is not parsable. This means, that `{\"foo\" : \"bar\"}` becomes an object, `[1, 2, 3]` becomes an array,\n *    `42` becomes a number, `true` becomes a boolean and `null` becomes a null-value. But `foobar` actually becomes\n *    the string \"foobar\". JSON-style double quotes are removed, when handling a single string.\n *\n * Keep in mind that things like `new Date()` will not work out of the box, since this is not included in the JSON\n * standard, but has to be serialized/deserialized.\n *\n * @param {HTMLElement} node - the element to read data from\n * @param {?String|Array<String>} [properties=null] - if set, returns value(s) of that specific property/properties (single value for exactly one property, dictionary for multiple), if left out, all properties are returned as a dictionary object\n * @throws error if node is not a usable HTML element\n * @returns {*|Object|null} JSON-parsed attribute value(s) with string fallback; either a single value for exactly one property, a dictionary of values for multiple or a call without properties (meaning all) or null, in case no data was found\n *\n * @memberof Elements:getData\n * @alias getData\n * @see setData\n * @see removeData\n * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/dataset\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse\n * @example\n * getData(createNode('<div data-my-naughty-dog=\"42\"></div>'), 'my-naughty-dog')\n * => 42\n * getData(createNode('<div data-my-naughty-dog='{\"foo\" : [1, \"two\", true]}'></div>'), 'my-naughty-dog')\n * => {\"foo\" : [1, \"two\", true]}\n * getData(createNode('<div data-my-naughty-dog='1, \"two\", true'></div>'), 'my-naughty-dog')\n * => '1, \"two\", true'\n * getData(createNode('<div data-my-naughty-dog=\"42\" data-foo=\"true\" data-bar=\"test\"></div>'), ['foo', 'bar'])\n * => {\"foo\" : true, \"bar\" : \"test\"}\n * getData(createNode('<div data-my-naughty-dog=\"42\" data-foo=\"true\" data-bar=\"test\"></div>'))\n * => {\"my-naughty-dog\" : 42,\"foo\" : true, \"bar\" : \"test\"}\n */\nexport function getData(node, properties=null){\n\tconst __methodName__ = 'getData';\n\n\tproperties = orDefault(properties, null, 'arr');\n\n\tassert(isA(node, 'htmlelement'), `${MODULE_NAME}:${__methodName__} | ${NOT_AN_HTMLELEMENT_ERROR}`);\n\n\tlet data = {};\n\n\tif( hasValue(properties) ){\n\t\tproperties.forEach(property => {\n\t\t\tlet attributeValue = node.getAttribute(`data-${property}`);\n\t\t\tif( hasValue(attributeValue) ){\n\t\t\t\ttry {\n\t\t\t\t\tdata[property] = JSON.parse(attributeValue);\n\t\t\t\t} catch(ex){\n\t\t\t\t\tdata[property] = attributeValue;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t} else {\n\t\tArray.from(node.attributes).forEach(attribute => {\n\t\t\tif( attribute.name.startsWith('data-') ){\n\t\t\t\tconst property = attribute.name.replace(/^data-/, '');\n\t\t\t\ttry {\n\t\t\t\t\tdata[property] = JSON.parse(attribute.value);\n\t\t\t\t} catch(ex){\n\t\t\t\t\tdata[property] = attribute.value;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tif( size(data) === 0 ){\n\t\tdata = null;\n\t} else if( (properties?.length === 1) ){\n\t\tdata = data[properties[0]] ?? null;\n\t}\n\n\treturn data;\n}\n\n\n\n/**\n * @namespace Elements:setData\n */\n\n/**\n * Writes data to an element, by setting data-attributes.\n *\n * Setting a value of `undefined` or an empty string removes the attribute.\n *\n * This method has two major differences from the standard browser dataset-implementations:\n * 1. Property names are _not_ handled camel-cased in any way.\n *    The data attribute `my-naughty-dog` property is _not_ magically created from `myNaughtyDog`,\n *    but the original notation will be kept, just adding the prefix, so set `data-my-naughty-dog`\n *    by using `my-naughty-dog`\n * 2. All property values are treated as JSON first and foremost, falling back to basic string values, if the\n *    value is not stringifiable as JSON. If the top-level value ends up to be a simple JSON string like '\"foo\"'\n *    or \"'foo'\", the double quotes are removed before writing the value.\n *\n * Keep in mind that things like `new Date()` will not work out of the box, since this is not included in the JSON\n * standard, but has to be serialized/deserialized.\n *\n * @param {HTMLElement} node - the element to write data to\n * @param {Object<String,*>|String} dataSet - the data to write to the element, properties have to be exact data-attribute names without the data-prefix, values are stringified (first with JSON.stringify and then as-is as a fallback), if value is a function it gets executed and the return value will be used from there on; if this is a string, this defines a single property to set, with the singleValue being the value to set\n * @param {?*} [singleValue=null] - if you only want to set exactly one property, you may set dataSet to the property name as a string and provide the value via this parameter instead\n * @throws error if node is not a usable HTML element or if dataSet is not a plain object if no single value has been given\n * @returns {Object<String,*>|*|null} the value(s) actually written to the element's data-attributes as they would be returned by getData (removed attributes are marked with `undefined`); null will be returned if nothing was changed; if only a single value was set, only that value will be returned\n *\n * @memberof Elements:setData\n * @alias setData\n * @see getData\n * @see removeData\n * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/dataset\n * @example\n * setData(element, {foobar : 'hello kittens!'});\n * => {foobar : 'hello kittens!'}\n * setData(element, 'foobar', 'hello kittens!');\n * => 'hello kittens!'\n * setData(element, {foobar : {a : 'foo', b : [1, 2, 3], c : {d : true}}});\n * => {foobar : {a : 'foo', b : [1, 2, 3], c : {d : true}}}\n * setData(element, 'foobar', {a : 'foo', b : [1, 2, 3], c : {d : true}});\n * => {a : 'foo', b : [1, 2, 3], c : {d : true}}\n * setData(element, {foobar : () => { return 'hello kittens!'; }});\n * => {foobar : 'hello kittens!'}\n * setData(element, {foobar : undefined});\n * => {foobar : undefined}\n * setData(element, boofar, '');\n * => undefined\n */\nexport function setData(node, dataSet, singleValue=null){\n\tconst __methodName__ = 'setData';\n\n\tassert(isA(node, 'htmlelement'), `${MODULE_NAME}:${__methodName__} | ${NOT_AN_HTMLELEMENT_ERROR}`);\n\n\tlet singleKey = null;\n\tif( hasValue(singleValue) ){\n\t\tsingleKey = `${dataSet}`;\n\t\tdataSet = {\n\t\t\t[singleKey] : singleValue\n\t\t};\n\t}\n\n\tassert(isPlainObject(dataSet), `${MODULE_NAME}:${__methodName__} | dataSet is not a plain object`);\n\n\tconst appliedValues = {};\n\n\tObject.entries(dataSet).forEach(([property, value]) => {\n\t\tif( isA(value, 'function') ){\n\t\t\tvalue = value();\n\t\t}\n\n\t\tif( value !== undefined ){\n\t\t\tlet stringifiedValue, getValue;\n\t\t\ttry {\n\t\t\t\tstringifiedValue = JSON.stringify(value);\n\t\t\t\tgetValue = JSON.parse(stringifiedValue);\n\t\t\t} catch(ex){\n\t\t\t\tstringifiedValue = `${value}`;\n\t\t\t\tgetValue = stringifiedValue;\n\t\t\t}\n\t\t\tstringifiedValue = stringifiedValue.replace(/^['\"]/, '').replace(/['\"]$/, '').trim();\n\n\t\t\tif( stringifiedValue !== '' ){\n\t\t\t\tappliedValues[property] = getValue;\n\t\t\t\tnode.setAttribute(`data-${property}`, stringifiedValue);\n\t\t\t} else if( node.hasAttribute(`data-${property}`) ){\n\t\t\t\tappliedValues[property] = undefined;\n\t\t\t\tnode.removeAttribute(`data-${property}`);\n\t\t\t}\n\t\t} else if( node.hasAttribute(`data-${property}`) ){\n\t\t\tappliedValues[property] = undefined;\n\t\t\tnode.removeAttribute(`data-${property}`);\n\t\t}\n\t});\n\n\tif( hasValue(singleKey) ){\n\t\treturn (singleKey in appliedValues) ?  appliedValues[singleKey] : null;\n\t} else {\n\t\treturn (size(appliedValues) > 0) ? appliedValues : null;\n\t}\n}\n\n\n\n/**\n * @namespace Elements:removeData\n */\n\n/**\n * Removes data from an element, by removing corresponding data-attributes.\n *\n * This method has a major difference from the standard browser dataset-implementations:\n * Property names are _not_ handled camel-cased in any way.\n * The data attribute's `my-naughty-dog` property is _not_ magically created from `myNaughtyDog`,\n * but the original notation will be kept, just adding the prefix,\n * so use `my-naughty-dog` to remove `data-my-naughty-dog`\n *\n * @param {HTMLElement} node - the element to remove data from\n * @param {?String|Array<String>} [properties=null] - if set, removes specified property/properties, if left out, all data properties are removed\n * @throws error if node is not a usable HTML element\n * @returns {*|Object<String,*>|null} the removed data values as they would be returned from getData (single value for one property, dictionaries for multiple or all) or null if nothing was removed\n *\n * @memberof Elements:removeData\n * @alias removeData\n * @see getData\n * @see setData\n * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/dataset\n * @example\n * const testNode = createNode(`<span data-foobar=\"test\" data-boofar=\"null\" data-baz='{\"a\" : [\"1\", 2, 3.3], \"b\" : true}'></span>`)\n * removeData(testNode, 'foobar')\n * => 'test' (testNode.outerHTML === `<span data-boofar=\"null\" data-baz='{\"a\" : [\"1\", 2, 3.3], \"b\" : true}'></span>`)\n * removeData(testNode, ['foobar', 'baz', 'test'])\n * => {foobar : 'test', baz : {\"a\" : [\"1\", 2, 3.3], \"b\" : true}} (testNode.outerHTML === `<span data-boofar=\"null\"></span>`)\n * removeData(testNode)\n * => {foobar : 'test', boofar : null, baz : {\"a\" : [\"1\", 2, 3.3], \"b\" : true}} (testNode.outerHTML === `<span></span>`)\n * removeData(testNode, 'test')\n * => null\n */\nexport function removeData(node, properties=null){\n\tconst __methodName__ = 'removeData';\n\n\tproperties = orDefault(properties, null, 'arr');\n\n\tassert(isA(node, 'htmlelement'), `${MODULE_NAME}:${__methodName__} | ${NOT_AN_HTMLELEMENT_ERROR}`);\n\n\tlet data = getData(node, properties);\n\tif( hasValue(data) ){\n\t\tif( properties?.length === 1 ){\n\t\t\tsetData(node, {[properties[0]] : undefined});\n\t\t} else {\n\t\t\tsetData(node, Object.keys(data).reduce((removalDataSet, property) => {\n\t\t\t\tremovalDataSet[property] = undefined;\n\t\t\t\treturn removalDataSet;\n\t\t\t}, {}));\n\t\t}\n\t} else {\n\t\tdata = null;\n\t}\n\n\treturn data;\n}\n"]}
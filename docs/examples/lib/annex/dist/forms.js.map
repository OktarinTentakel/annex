{"version":3,"file":"forms.js","names":["MODULE_NAME","isFunction","isPlainObject","hasValue","formDataToObject","formDataOrForm","formData","append","getAll","entries","FormData","ex","formDataObject","Array","from","forEach","key","values","endsWith","slice","concat","length","objectToFormData","Object","fieldName","fieldValue","file","File","name","undefined","blob","Blob","mimeType","type"],"sources":["forms.js"],"mappings":";;;AAQA,MAAMA,YAAc,eAMZC,WAAYC,cAAeC,aAAe,oBAyD3C,SAASC,iBAAiBC,GAChC,IAAIC,EAGJ,GACCL,WAAWI,EAAeE,SACvBN,WAAWI,EAAeG,SAC1BP,WAAWI,EAAeI,SAE7BH,EAAWD,OAEX,IACCC,EAAW,IAAII,SAASL,EACzB,CAAE,MAAMM,GACPL,EAAW,IACZ,CAGD,IAAKH,SAASG,GAAY,OAAO,KAEjC,MAAMM,EAAiB,CAAC,EAexB,OAbAC,MAAMC,KAAKR,EAASG,WAAWM,SAAQ,EAAEC,EAAKC,MACzCD,EAAIE,SAAS,QAChBF,EAAMA,EAAIG,MAAM,GAAI,IAErBF,EAAS,GAAGG,OAAOH,GAEdd,SAASS,EAAeI,IAG5BJ,EAAeI,GAAO,GAAGI,OAAOR,EAAeI,GAAMC,GAFrDL,EAAeI,GAA0B,IAAlBC,EAAOI,OAAgBJ,EAAO,GAAKA,CAG3D,IAGML,CACR,QA8CO,SAASU,iBAAiBV,GAChC,MAAMN,EAAW,IAAII,SAsCrB,OApCAa,OAAOd,QAAQG,GAAgBG,SAAQ,EAAES,EAAWC,MAC/CD,EAAUN,SAAS,QACtBM,EAAYA,EAAUL,MAAM,GAAI,IAGjC,GAAGC,OAAOK,GAAYV,SAAQU,IAC7B,GAAIvB,cAAcuB,GACjB,GAAItB,SAASsB,EAAWC,OAAUD,EAAWC,gBAAgBC,KAC5DrB,EAASC,OACRiB,EACAC,EAAWC,KACXvB,SAASsB,EAAWG,MAAQ,GAAGH,EAAWG,YAASC,QAE9C,GAAI1B,SAASsB,EAAWK,MAAO,CACrC,MAAMA,EAAQL,EAAWK,gBAAgBC,KACtCN,EAAWK,KACX,IAAIC,KACL,CAAC,GAAGN,EAAWK,QACf3B,SAASsB,EAAWO,UAAY,CAACC,KAAO,GAAGR,EAAWO,iBAAcH,GAItEvB,EAASC,OACRiB,EACAM,EACA3B,SAASsB,EAAWG,MAAQ,GAAGH,EAAWG,YAASC,EAErD,MACCvB,EAASC,OAAOiB,EAAW,GAAGC,UAG/BnB,EAASC,OAAOiB,EAAWC,EAC5B,GACC,IAGInB,CACR","ignoreList":[],"sourcesContent":["/*!\n * Module Forms\n */\n\n/**\n * @namespace Forms\n */\n\nconst MODULE_NAME = 'Forms';\n\n\n\n//###[ IMPORTS ]########################################################################################################\n\nimport {isFunction, isPlainObject, hasValue} from './basic.js';\n\n\n\n//###[ EXPORTS ]########################################################################################################\n\n/**\n * @namespace Forms:formDataToObject\n */\n\n/**\n * Constructs a plain object from an existing FormData object or a given form element.\n *\n * The idea of this function is, to make working with form data easier in programmatic contexts by allowing operations\n * like optional chaining and \"in\" operators. This might especially come in handy if you need to do programmatic\n * validations.\n *\n * Additionally, this function streamlines field names, by discarding PHP-style array field name conventions like\n * \"files[]\", by removing the brackets. So, if you have a field named \"files[]\" and another field named \"files\",\n * both will just end up in one \"files\"-field, having an array as a value containing all combined values.\n *\n * Keep in mind, that the status of form fields in a form matters when retrieving FormData from a form element.\n * Disabled fields will not be included for example. Make sure to handle this before using the data.\n *\n * On Internet Explorers, this function needs a polyfill, which is not included in annex, due to its size and\n * complexity, since IEs, while supporting FormData basically, are lacking all functions to access values of an existing\n * FormData object, thereby making it impossible to iterate its values.\n *\n * @param {FormData|HTMLFormElement} formDataOrForm - either an existing FormData object or a form, from which we can retrieve formdata\n * @returns {Object} plain object, containing all form values based on the exisiting fields as key/value-pairs\n *\n * @memberof Forms:formDataToObject\n * @alias formDataToObject\n * @see objectToFormData\n * @see https://developer.mozilla.org/en-US/docs/Web/API/FormData/FormData\n * @see https://github.com/jimmywarting/FormData\n * @example\n * const formData = new FormData();\n * formData.append('secrethash', 123456789);\n * formData.append('firstname', 'Paul');\n * formData.append('lastname', 'Atreides');\n * formData.append('houses', 'Atreides');\n * formData.append('houses', 'Fremen');\n * formData.append('houses', 'Corrino');\n * formData.append('diary', new File(['Dear Diary, ...'], 'diary.txt', {type : 'text/plain', lastModified : new Date()}));\n * formData.append('instagramPage', new Blob(['<html>...</html>'], {type : 'text/html'}));\n * formDataToObject(formData)\n * =>\n * {\n *   secrethash : '123456789',\n * \t firstname : 'Paul',\n * \t lastname : 'Atreides',\n * \t houses : ['Atreides', 'Fremen', 'Corrino'],\n * \t diary : File,\n * \t instagramPage : Blob\n * }\n */\nexport function formDataToObject(formDataOrForm){\n\tlet formData;\n\n\t// let's do duck-typing to allow polyfills\n\tif(\n\t\tisFunction(formDataOrForm.append)\n\t\t&& isFunction(formDataOrForm.getAll)\n\t\t&& isFunction(formDataOrForm.entries)\n\t){\n\t\tformData = formDataOrForm;\n\t} else {\n\t\ttry {\n\t\t\tformData = new FormData(formDataOrForm);\n\t\t} catch(ex){\n\t\t\tformData = null;\n\t\t}\n\t}\n\n\tif( !hasValue(formData) ) return null;\n\n\tconst formDataObject = {};\n\n\tArray.from(formData.entries()).forEach(([key, values]) => {\n\t\tif( key.endsWith('[]') ){\n\t\t\tkey = key.slice(0, -2);\n\t\t}\n\t\tvalues = [].concat(values);\n\n\t\tif( !hasValue(formDataObject[key]) ){\n\t\t\tformDataObject[key] = (values.length === 1) ? values[0] : values;\n\t\t} else {\n\t\t\tformDataObject[key] = [].concat(formDataObject[key], values);\n\t\t}\n\t});\n\n\treturn formDataObject;\n}\n\n\n\n/**\n * @namespace Forms:objectToFormData\n */\n\n/**\n * Constructs a FormData object, to be used in requests, from a given (plain) object, iterating its entries.\n *\n * Additionally, this function streamlines field names, by discarding PHP-style array field name conventions like\n * \"files[]\", by removing the brackets. So, if you have a field named \"files[]\" and another field named \"files\",\n * both will just end up in one \"files\"-field.\n *\n * Files and Blobs can be provided as-is (constructed programmatically of retrieved from file inputs via `.files`).\n * Alternatively (and if you manually want to define the filename), you can provide plain objects to describe a File or\n * Blob to add to the FormData:\n * - use {file : File, ?name : String} to add \"file\" as a File and optionally set \"name\" to define a filename, taking\n *   precedence over what is already defined in the File object itself\n * - use {blob : Blob|String, ?name : String, ?mimeType : String} to add \"blob\" as a Blob (if this is a string, it\n *   will be treated as the content of a new Blob), optionally using \"name\" as the filename (I'd recommend to set this)\n *   and optionally setting the file type via the MIME type defined in \"mimeType\".\n *\n * In contrast to `formDataToObject`, this function does not need a polyfill in Internet Explorer, since it only uses\n * the FormData constructor and the `.append()` method, which are both supported.\n *\n * @param {Object} formDataObject - object to iterate, to create FormData based on its entries\n * @returns {FormData} FormData object to be used in a request\n *\n * @memberof Forms:objectToFormData\n * @alias objectToFormData\n * @see formDataToObject\n * @see https://developer.mozilla.org/en-US/docs/Web/API/FormData/FormData\n * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types\n * @example\n * const formData = objectToFormData({\n *   secrethash : 123456789,\n * \t firstname : 'Paul',\n * \t lastname : 'Atreides',\n * \t houses : ['Atreides', 'Fremen', 'Corrino'],\n * \t diary : {file : new File(['Dear Diary, ...'], 'diary.txt', {type : 'text/plain', lastModified : new Date()})},\n * \t instagramPage : {blob : '<html>...</html>', name : 'instagram.html', mimeType : 'text/html'},\n * }).getAll('houses');\n * => ['Atreides', 'Fremen', 'Corrino']\n */\nexport function objectToFormData(formDataObject){\n\tconst formData = new FormData();\n\n\tObject.entries(formDataObject).forEach(([fieldName, fieldValue]) => {\n\t\tif( fieldName.endsWith('[]') ){\n\t\t\tfieldName = fieldName.slice(0, -2);\n\t\t}\n\n\t\t[].concat(fieldValue).forEach(fieldValue => {\n\t\t\tif( isPlainObject(fieldValue) ){\n\t\t\t\tif( hasValue(fieldValue.file) && (fieldValue.file instanceof File) ){\n\t\t\t\t\tformData.append(\n\t\t\t\t\t\tfieldName,\n\t\t\t\t\t\tfieldValue.file,\n\t\t\t\t\t\thasValue(fieldValue.name) ? `${fieldValue.name}` : undefined\n\t\t\t\t\t);\n\t\t\t\t} else if( hasValue(fieldValue.blob) ){\n\t\t\t\t\tconst blob = (fieldValue.blob instanceof Blob)\n\t\t\t\t\t\t? fieldValue.blob\n\t\t\t\t\t\t: new Blob(\n\t\t\t\t\t\t\t[`${fieldValue.blob}`],\n\t\t\t\t\t\t\thasValue(fieldValue.mimeType) ? {type : `${fieldValue.mimeType}`} : undefined\n\t\t\t\t\t\t)\n\t\t\t\t\t;\n\n\t\t\t\t\tformData.append(\n\t\t\t\t\t\tfieldName,\n\t\t\t\t\t\tblob,\n\t\t\t\t\t\thasValue(fieldValue.name) ? `${fieldValue.name}` : undefined\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tformData.append(fieldName, `${fieldValue}`);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tformData.append(fieldName, fieldValue);\n\t\t\t}\n\t\t});\n\t});\n\n\treturn formData;\n}\n"]}
{"version":3,"sources":["viewport.js"],"names":["MODULE_NAME","hasValue","orDefault","isA","Deferred","EasingFunctions","requestAnimationFrame","isInViewport","element","mustBeFullyInside","bb","viewportBounds","getBoundingClientRect","err","top","right","window","innerWidth","bottom","innerHeight","left","scrollTo","durationMs","offset","easing","scrollEvenIfFullyInViewport","cancelOnUserScroll","easeInOutCubic","res","elementIsWindow","self","elementInViewport","start","targetY","cancelled","startY","pageYOffset","Math","round","diff","fScroll","timestamp","time","progress","min","resolve","fCancelScroll","reject","removeEventListener","addEventListener"],"mappings":";;;AAQA,MAAMA,YAAc,kBAIZC,SAAUC,UAAWC,IAAKC,aAAe,oBACzCC,oBAAsB,wBACtBC,0BAA4B,qBAwB7B,SAASC,aAAaC,EAASC,GAGrC,IAAIC,EAQAC,EAVJF,EAAoBP,UAAUO,GAAmB,EAAO,WAGxD,IACCC,EAAKF,EAAQI,wBACZ,MAAMC,GAEP,OAAO,EAoBR,OAfCF,EADGF,EACc,CAChBK,IAAK,EACLC,MAAQC,OAAOC,WACfC,OAASF,OAAOG,YAChBC,KAAO,GAGS,CAChBN,IAA8B,GAAtBJ,EAAGQ,OAASR,EAAGI,KACvBC,MAASC,OAAOC,YAAcP,EAAGK,MAAQL,EAAGU,MAAS,EACrDF,OAAUF,OAAOG,aAAeT,EAAGQ,OAASR,EAAGI,KAAQ,EACvDM,KAA+B,GAAtBV,EAAGK,MAAQL,EAAGU,OAKxBV,EAAGI,KAAOH,EAAeG,KACzBJ,EAAGK,OAASJ,EAAeI,OAC3BL,EAAGU,MAAQT,EAAeS,MAC1BV,EAAGQ,QAAUP,EAAeO,cA0CvB,SAASG,SAASb,EAASc,EAAYC,EAAQC,EAAQC,EAA6BC,GAC1FJ,EAAapB,UAAUoB,EAAY,IAAM,WACzCC,EAASrB,UAAUqB,EAAQ,EAAG,WAC9BC,EAAStB,UAAUsB,EAAQ,iBAAkB,UAC7CC,EAA8BvB,UAAUuB,GAA6B,EAAO,WAC5EC,EAAqBxB,UAAUwB,GAAoB,EAAO,WAKzDF,EAHIrB,IAAIE,gBAAgBmB,GAAS,YAGxBnB,gBAAgBmB,GAFhBnB,gBAAgBsB,eAK1B,MACCC,EAAM,IAAIxB,SACVyB,EAAmBrB,EAAQsB,OAAStB,EAIrC,IAAIuB,GAAoBF,GAA0BtB,aAAaC,GAAS,GAGxE,IACCA,EAAQI,wBACP,MAAMC,GACPkB,GAAoB,EAGrB,GAAIN,IAAgCM,EAAmB,CACtD,IAAIC,EAAOC,EAASC,GAAY,EAChC,MAAMC,EAASnB,OAAOoB,YAGrBH,EADGJ,EACON,EAEAP,OAAOoB,YAAc5B,EAAQI,wBAAwBE,IAAMuB,KAAKC,MAAMtB,OAAOG,YAAc,GAAKI,EAG3G,MACCgB,EAAON,EAAUE,EACjBK,EAAU,SAASC,GAClB,IAAKP,EAAW,CACVjC,SAAS+B,KACbA,EAAQS,GAGT,MACCC,EAAOD,EAAYT,EACnBW,EAAWnB,EAAOa,KAAKO,IAAIF,EAAOpB,EAAY,IAG/CN,OAAOK,SAAS,EAAGc,EAAUI,EAAOI,GAE/BD,EAAOpB,GAAgBqB,EAAW,EACtCrC,sBAAsBkC,GAEtBZ,EAAIiB,YAMR,GAAInB,EAAoB,CACvB,MAAMoB,EAAgB,WACrBZ,GAAY,EACZN,EAAImB,SACJ/B,OAAOgC,oBAAoB,iBAAkBF,GAC7C9B,OAAOgC,oBAAoB,aAAcF,IAG1C9B,OAAOiC,iBAAiB,iBAAkBH,GAC1C9B,OAAOiC,iBAAiB,aAAcH,GAG1B,IAATP,GACHjC,sBAAsBkC,GAIxB,OAAOZ","file":"viewport.js","sourcesContent":["/*!\n * Module Viewport\n */\n\n/**\n * @namespace Viewport\n */\n\nconst MODULE_NAME = 'Viewport';\n\n\n\nimport {hasValue, orDefault, isA, Deferred} from './basic.js';\nimport {EasingFunctions} from './animation.js';\nimport {requestAnimationFrame} from './timers.js';\n\n\n\n/**\n * @namespace Viewport:isInViewport\n */\n\n/**\n * Returns if the current element is visible in the window's viewport at the moment.\n * This method uses getBoundingClientRect(), which has to be supported by the browser, otherwise\n * the method will always return true.\n *\n * @param {HTMLElement} element - the element to check\n * @param {?Boolean} [mustBeFullyInside=false] - defines if the element has to be fully enclosed in the viewport, default is false\n * @returns {Boolean} true if in viewport\n *\n * @memberof Viewport:isInViewport\n * @alias isInViewport\n * @example\n * if( isInViewport(document.querySelector('div.moving'), true) ){\n *   ...\n * }\n */\nexport function isInViewport(element, mustBeFullyInside){\n\tmustBeFullyInside = orDefault(mustBeFullyInside, false, 'boolean');\n\n\tlet bb;\n\ttry {\n\t\tbb = element.getBoundingClientRect();\n\t} catch(err){\n\t\t// if we cannot calculate position, we must assume the element is in\n\t\treturn true;\n\t}\n\n\tlet viewportBounds;\n\tif( mustBeFullyInside ){\n\t\tviewportBounds = {\n\t\t\ttop: 0,\n\t\t\tright : window.innerWidth,\n\t\t\tbottom : window.innerHeight,\n\t\t\tleft : 0\n\t\t};\n\t} else {\n\t\tviewportBounds = {\n\t\t\ttop : -(bb.bottom - bb.top) + 1,\n\t\t\tright : (window.innerWidth + (bb.right - bb.left)) + 1,\n\t\t\tbottom : (window.innerHeight + (bb.bottom - bb.top)) + 1,\n\t\t\tleft : -(bb.right - bb.left) + 1\n\t\t};\n\t}\n\n\treturn (\n\t\tbb.top >= viewportBounds.top &&\n\t\tbb.right <= viewportBounds.right &&\n\t\tbb.left >= viewportBounds.left &&\n\t\tbb.bottom <= viewportBounds.bottom\n\t);\n}\n\n\n\n/**\n * @namespace Viewport:scrollTo\n */\n\n/**\n * Scrolls the viewport to the element's position (first pixel at half viewport height).\n * Does not do anything if target element is already fully in viewport, unless scrollEvenIfFullyInViewport is set to\n * true. Uses getBoundingClientRect to measure viewport check, scrolls always if missing.\n *\n * If you use this function on a window, the offset is directly used as scrollTop, so this function may also be used for\n * things like back to top buttons.\n *\n * Scrolls may be cancelled by setting cancelOnUserScroll to true, but keep in mind, that this will only work\n * with mousewheels and (maybe) touchpads on modern browsers. No keyboard or scrollbar support yet.\n * The root of the problem is that a user scroll is indistinguishable from a js-triggered scroll,\n * since both trigger the scroll event and look exactly the same. So we have to use exotic\n * and specific events like mousewheel and DOMMouseScroll. So, please, use cancelOnUserScroll only\n * as a convenience option and not as a must.\n *\n *\n * @param {HTMLElement} element - the element to scroll to\n * @param {?Number} [durationMs=1000] - duration of the scrolling animation\n * @param {?Number} [offset=0] - offset from the viewport center to apply to the end position\n * @param {?String} [easing='easeInOutCubic'] - easing function to use, can be any of Animation.EasingFunctions\n * @param {?Boolean} [scrollEvenIfFullyInViewport=false] - if true, forces method to always scroll no matter the element's position\n * @param {?Boolean} [cancelOnUserScroll=false] - if true, scrolling animation will immediately be canceled on manual user scroll, callback will not fire in that case\n * @returns {Promise} resolves when scroll complete, rejects if scroll fails or is cancelled\n *\n * @memberof Viewport:scrollTo\n * @alias scrollTo\n * @see EasingFunctions\n * @example\n * document.querySelector('a.jumpitem').addEventListener('click', function(){ scrollTo(document.querySelector('.jumptarget'), function(){ alert('scrolled!'); }, 500, -100, true); });\n * scrollTo(document.querySelector('.jumptarget'), function(){ alert('Not triggered if user uses mousewheel.'); }, 5000, -0, false, true);\n * scrollTo(window, null, 500, 0, false, true);\n */\nexport function scrollTo(element, durationMs, offset, easing, scrollEvenIfFullyInViewport, cancelOnUserScroll){\n\tdurationMs = orDefault(durationMs, 1000, 'integer');\n\toffset = orDefault(offset, 0, 'integer');\n\teasing = orDefault(easing, 'easeInOutCubic', 'string');\n\tscrollEvenIfFullyInViewport = orDefault(scrollEvenIfFullyInViewport, false, 'boolean');\n\tcancelOnUserScroll = orDefault(cancelOnUserScroll, false, 'boolean');\n\n\tif( !isA(EasingFunctions[easing], 'function') ){\n\t\teasing = EasingFunctions.easeInOutCubic;\n\t} else {\n\t\teasing = EasingFunctions[easing];\n\t}\n\n\tconst\n\t\tres = new Deferred(),\n\t\telementIsWindow = (element.self === element)\n\t;\n\n\t// the window itself is considered not to be in viewport\n\tlet elementInViewport = elementIsWindow ? false : isInViewport(element, true);\n\n\t// in this case missing support for bounding rects should result in scrolling\n\ttry {\n\t\telement.getBoundingClientRect();\n\t} catch(err){\n\t\telementInViewport = false;\n\t}\n\n\tif( scrollEvenIfFullyInViewport || !elementInViewport ){\n\t\tlet start, targetY, cancelled = false;\n\t\tconst startY = window.pageYOffset;\n\n\t\tif( elementIsWindow ){\n\t\t\ttargetY = offset;\n\t\t} else {\n\t\t\ttargetY = window.pageYOffset + element.getBoundingClientRect().top - Math.round(window.innerHeight / 2) + offset;\n\t\t}\n\n\t\tconst\n\t\t\tdiff = targetY - startY,\n\t\t\tfScroll = function(timestamp){\n\t\t\t\tif( !cancelled ){\n\t\t\t\t\tif( !hasValue(start) ){\n\t\t\t\t\t\tstart = timestamp;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst\n\t\t\t\t\t\ttime = timestamp - start,\n\t\t\t\t\t\tprogress = easing(Math.min(time / durationMs, 1))\n\t\t\t\t\t;\n\n\t\t\t\t\twindow.scrollTo(0, startY + (diff * progress));\n\n\t\t\t\t\tif( (time < durationMs) && (progress < 1) ){\n\t\t\t\t\t\trequestAnimationFrame(fScroll)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tres.resolve();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t;\n\n\t\tif( cancelOnUserScroll ){\n\t\t\tconst fCancelScroll = function(){\n\t\t\t\tcancelled = true;\n\t\t\t\tres.reject();\n\t\t\t\twindow.removeEventListener('DOMMouseScroll', fCancelScroll);\n\t\t\t\twindow.removeEventListener('mousewheel', fCancelScroll);\n\t\t\t};\n\n\t\t\twindow.addEventListener('DOMMouseScroll', fCancelScroll);\n\t\t\twindow.addEventListener('mousewheel', fCancelScroll);\n\t\t}\n\n\t\tif( diff !== 0 ){\n\t\t\trequestAnimationFrame(fScroll);\n\t\t}\n\t}\n\n\treturn res;\n}\n"]}
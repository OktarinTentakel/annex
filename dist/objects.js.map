{"version":3,"file":"objects.js","names":["MODULE_NAME","getType","isFunction","isObject","orDefault","clone","target","deep","seenReferences","Array","from","arguments","seenCopies","indexOf","targetType","arrayCopy","push","i","length","setCopy","WeakSet","Set","forEach","value","add","mapCopy","WeakMap","Map","key","set","objectCopy","Object","create","getPrototypeOf","__proto__","prop","hasOwnProperty","fragment","document","createDocumentFragment","element","appendChild","item","childNodes","Date","getTime","RegExp","cloneNode","merge","base","extensions","extension","keys"],"sources":["objects.js"],"mappings":";;;AAQA,MAAMA,YAAc,iBAMZC,QAASC,WAAYC,SAAUC,cAAgB,oBA6ChD,SAASC,MAAMC,EAAQC,GAAK,GAGlC,GAFAA,EAAOH,UAAUG,GAAM,EAAM,QAEzBL,WAAWI,GAAQD,OACtB,OAAOC,EAAOD,MAAME,GAGrB,MACCC,EAAiBC,MAAMC,KAAKC,WAAW,IAAM,GAC7CC,EAAaH,MAAMC,KAAKC,WAAW,IAAM,GAG1C,GAAIH,EAAeK,QAAQP,IAAW,EACrC,OAAOM,EAAWJ,EAAeK,QAAQP,IAG1C,MAAMQ,EAAab,QAAQK,GAC3B,OAAQQ,GACP,IAAK,QACJ,MAAMC,EAAY,IAAIT,GAKtB,GAHAE,EAAeQ,KAAKV,GACpBM,EAAWI,KAAKD,GAEZR,EAAM,CACT,IAAIU,EAAIF,EAAUG,OAClB,KAAOD,KACNF,EAAUE,GAAKZ,MAAMU,EAAUE,GAAIV,EAAMC,EAAgBI,EAE3D,CAEA,OAAOG,EAER,IAAK,MACL,IAAK,UACJ,MAAMI,EAA0B,YAAfL,EACd,IAAIM,QACJ,IAAIC,IAcP,OAXAb,EAAeQ,KAAKV,GACpBM,EAAWI,KAAKG,GAEhBb,EAAOgB,SAAQC,IACVhB,EACHY,EAAQK,IAAInB,MAAMkB,EAAOhB,EAAMC,EAAgBI,IAE/CO,EAAQK,IAAID,EACb,IAGMJ,EAER,IAAK,MACL,IAAK,UACJ,MAAMM,EAA0B,YAAfX,EACd,IAAIY,QACJ,IAAIC,IAcP,OAXAnB,EAAeQ,KAAKV,GACpBM,EAAWI,KAAKS,GAEhBnB,EAAOgB,SAAQ,CAACC,EAAOK,KAClBrB,EACHkB,EAAQI,IAAID,EAAKvB,MAAMkB,EAAOhB,EAAMC,EAAgBI,IAEpDa,EAAQI,IAAID,EAAKL,EAClB,IAGME,EAER,IAAK,SACJ,MAAMK,EAAaC,OAAOC,OAAOD,OAAOE,eAAiBF,OAAOE,eAAe3B,GAAUA,EAAO4B,WAEhG1B,EAAeQ,KAAKV,GACpBM,EAAWI,KAAKc,GAEhB,IAAK,IAAIK,KAAQ7B,EACZA,EAAO8B,eAAeD,KAExBL,EAAWK,GADR5B,EACgBF,MAAMC,EAAO6B,GAAO5B,EAAMC,EAAgBI,GAE1CN,EAAO6B,IAK7B,OAAOL,EAER,IAAK,WACJ,MAAMO,EAAWC,SAASC,yBAK1B,GAAIhC,EACHD,EAAOgB,SAAQkB,IACVjC,GACH8B,EAASI,YAAYpC,MAAMmC,EAASjC,EAAMC,EAAgBI,GAC3D,SAKD,KAAON,EAAOY,QACbmB,EAASI,YAAYnC,EAAOoC,KAAK,IAInC,OAAOL,EAASM,WAEjB,IAAK,OAAQ,OAAO,IAAIC,KAAKtC,EAAOuC,WACpC,IAAK,SAAU,OAAO,IAAIC,OAAOxC,GACjC,IAAK,cAAe,OAAOA,EAAOyC,UAAUxC,GAC5C,QAAS,OAAOD,EAElB,QAkCO,SAAS0C,MAAMC,KAASC,GAqB9B,OApBAD,EAAO5C,MAAM4C,GAEbxC,MAAMC,KAAKwC,GAAY5B,SAAQ6B,IAC9BA,EAAY9C,MAAM8C,GAElB,IAAK,IAAIhB,KAAQgB,EACZA,EAAUf,eAAeD,KAE3Bc,EAAKb,eAAeD,IAChBhC,SAAS8C,EAAKd,KAAUhC,SAASgD,EAAUhB,KAC3CJ,OAAOqB,KAAKD,EAAUhB,IAAOjB,OAAS,EAE1C+B,EAAKd,GAAQa,MAAMC,EAAKd,GAAOgB,EAAUhB,IAEzCc,EAAKd,GAAQgB,EAAUhB,GAG1B,IAGMc,CACR","sourcesContent":["/*!\n * Module Objects\n */\n\n/**\n * @namespace Objects\n */\n\nconst MODULE_NAME = 'Objects';\n\n\n\n//###[ IMPORTS ]########################################################################################################\n\nimport {getType, isFunction, isObject, orDefault} from './basic.js';\n\n\n\n//###[ EXPORTS ]########################################################################################################\n\n/**\n * @namespace Objects:clone\n */\n\n/**\n * Cloning arbitrary objects, values and structured values is no trivial task in JavaScript.\n * For basic values this can easily be achieved by serializing/deserializing via JSON.parse(JSON.stringify(value)), but\n * for everything not included in the JSON standard, such as nodes, sets, maps, functions and objects with constructors\n * this gets hairy pretty quickly.\n *\n * This function implements a fairly robust recursive cloning algorithm with circular dependency detection and should\n * be sufficient for 90% of your cloning needs. It can create deep and shallow copies, although I generally presume\n * that you need a deep copy if you are in need of a clone method to begin with. This method handles ordinal values,\n * regexes, dates and htmlelements/nodes, as well as nested structures consisting of arrays, plain objects,\n * simple constructed objects with settable properties, sets, maps and even nodelists.\n *\n * Be aware of these restrictions:\n * - map keys are not cloned since, if you would, you'd lose all access to values,\n *   because you would have no valid references\n * - cloning a nodelist in a shallow manner results in the original list being empty afterwards, since moving a node\n *   reference from one nodelist to another automatically removes the reference from the first, because a node may\n *   only appear at exactly one place in a dom tree\n *\n * If this function does not suffice, have a look at lodash's cloneDeep method, which is a very robust and complete\n * (but large and complex) solution: https://www.npmjs.com/package/lodash.clonedeep\n *\n * @param {*} target - the object/value to clone\n * @param {?Boolean} [deep=true] - define if nested objects/values are to be cloned as well or just referenced in a shallow way\n * @returns {*} the cloned object/value\n *\n * @memberof Objects:clone\n * @alias clone\n * @example\n * const foo = {foo : 'bar', bar : [new Foobar(1, 2, 3), new Set([new Date('2021-03-09'), new RegExp('^foobar$')])]};\n * const allNewFoo = clone(foo);\n * const shallowNewFoo = clone(foo, false);\n * const thatOneTextAgain = clone(document.querySelector('p.that-one-text'));\n * thatOneTextAgain.classList.add('hooray');\n */\nexport function clone(target, deep=true){\n\tdeep = orDefault(deep, true, 'bool');\n\n\tif( isFunction(target?.clone) ){\n\t\treturn target.clone(deep);\n\t}\n\n\tconst\n\t\tseenReferences = Array.from(arguments)[2] ?? [],\n\t\tseenCopies = Array.from(arguments)[3] ?? []\n\t;\n\n\tif( seenReferences.indexOf(target) >= 0 ){\n\t\treturn seenCopies[seenReferences.indexOf(target)];\n\t}\n\n\tconst targetType = getType(target);\n\tswitch( targetType ){\n\t\tcase 'array':\n\t\t\tconst arrayCopy = [...target];\n\n\t\t\tseenReferences.push(target);\n\t\t\tseenCopies.push(arrayCopy);\n\n\t\t\tif( deep ){\n\t\t\t\tlet i = arrayCopy.length;\n\t\t\t\twhile( i-- ){\n\t\t\t\t\tarrayCopy[i] = clone(arrayCopy[i], deep, seenReferences, seenCopies);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn arrayCopy;\n\n\t\tcase 'set':\n\t\tcase 'weakset':\n\t\t\tconst setCopy = (targetType === 'weakset')\n\t\t\t\t? new WeakSet()\n\t\t\t\t: new Set()\n\t\t\t;\n\n\t\t\tseenReferences.push(target);\n\t\t\tseenCopies.push(setCopy);\n\n\t\t\ttarget.forEach(value => {\n\t\t\t\tif( deep ){\n\t\t\t\t\tsetCopy.add(clone(value, deep, seenReferences, seenCopies));\n\t\t\t\t} else {\n\t\t\t\t\tsetCopy.add(value);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn setCopy;\n\n\t\tcase 'map':\n\t\tcase 'weakmap':\n\t\t\tconst mapCopy = (targetType === 'weakmap')\n\t\t\t\t? new WeakMap()\n\t\t\t\t: new Map()\n\t\t\t;\n\n\t\t\tseenReferences.push(target);\n\t\t\tseenCopies.push(mapCopy);\n\n\t\t\ttarget.forEach((value, key) => {\n\t\t\t\tif( deep ){\n\t\t\t\t\tmapCopy.set(key, clone(value, deep, seenReferences, seenCopies));\n\t\t\t\t} else {\n\t\t\t\t\tmapCopy.set(key, value);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn mapCopy;\n\n\t\tcase 'object':\n\t\t\tconst objectCopy = Object.create(Object.getPrototypeOf ? Object.getPrototypeOf(target) : target.__proto__);\n\n\t\t\tseenReferences.push(target);\n\t\t\tseenCopies.push(objectCopy);\n\n\t\t\tfor( let prop in target ){\n\t\t\t\tif( target.hasOwnProperty(prop) ){\n\t\t\t\t\tif( deep ){\n\t\t\t\t\t\tobjectCopy[prop] = clone(target[prop], deep, seenReferences, seenCopies);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tobjectCopy[prop] = target[prop];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn objectCopy;\n\n\t\tcase 'nodelist':\n\t\t\tconst fragment = document.createDocumentFragment();\n\n\t\t\t// no optimization with seenReferences or seenCopies, since, in a dom tree, we cannot reuse\n\t\t\t// references or elements, since that would mean reattaching a node, which would move the node\n\n\t\t\tif( deep ){\n\t\t\t\ttarget.forEach(element => {\n\t\t\t\t\tif( deep ){\n\t\t\t\t\t\tfragment.appendChild(clone(element, deep, seenReferences, seenCopies));\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t// shallow copying a nodelist is destructive, since appending the original element, empties the original\n\t\t\t// list, since every node may only exist once inside a dom\n\t\t\t} else {\n\t\t\t\twhile( target.length ){\n\t\t\t\t\tfragment.appendChild(target.item(0));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn fragment.childNodes;\n\n\t\tcase 'date': return new Date(target.getTime());\n\t\tcase 'regexp': return new RegExp(target);\n\t\tcase 'htmlelement': return target.cloneNode(deep);\n\t\tdefault: return target;\n\t}\n}\n\n\n\n/**\n * @namespace Objects:merge\n */\n\n/**\n * Merging objects in JS is easy, using spread operators, as long as we are talking about shallow merging of the first\n * level. This method aims to deep merge recursively, always returning a new object, never touching or changing the\n * original one.\n *\n * This method implements LIFO precedence: the last extension wins.\n *\n * Possible differences to other implementations (like lodash's):\n * - arrays are not concatenated here, but replaced.\n * - explicitly extending an empty object, replaces the value with the empty object instead of doing nothing\n * - all involved objects are cloned, so references in the resulting object will differ\n *\n * @param {Object} base - the object to extend\n * @param {Array<Object>} extensions - one or more objects to merge into base sequentially, the last taking precedence\n * @returns {Object} the (newly created) merged object\n *\n * @memberof Objects:merge\n * @alias merge\n * @example\n * merge(\n *   {ducks : {uncles : ['Donald', 'Scrooge'], nephews : {huey : true}}},\n *   {ducks : {nephews : {dewey : true}}, mice : ['Mickey']},\n *   {ducks : {uncles : ['Gladstone'], nephews : {louie : true}}, mice : ['Mickey', 'Minnie']}\n * )\n * => {ducks : {uncles : ['Gladstone'], nephews : {huey : true, dewey : true, louie : true}}, mice : ['Mickey', 'Minnie']}\n */\nexport function merge(base, ...extensions){\n\tbase = clone(base);\n\n\tArray.from(extensions).forEach(extension => {\n\t\textension = clone(extension);\n\n\t\tfor( let prop in extension ){\n\t\t\tif( extension.hasOwnProperty(prop) ){\n\t\t\t\tif(\n\t\t\t\t\tbase.hasOwnProperty(prop)\n\t\t\t\t\t&& (isObject(base[prop]) && isObject(extension[prop]))\n\t\t\t\t\t&& (Object.keys(extension[prop]).length > 0)\n\t\t\t\t){\n\t\t\t\t\tbase[prop] = merge(base[prop], extension[prop]);\n\t\t\t\t} else {\n\t\t\t\t\tbase[prop] = extension[prop];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\treturn base;\n}\n"]}